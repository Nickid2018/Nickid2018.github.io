<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步 · Nickid2018的博客</title><meta name="description" content="Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步 - Nickid2018"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://Nickid2018.github.io/atom.xml" title="Nickid2018的博客"><!-- ------><script src="/script/headLinkSubmit.js"></script><script src="/script/headCount.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Nickid2018的博客" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Nickid2018的博客</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><ul class="shortcut-icons"><a href="https://github.com/Nickid2018" target="_blank"><img src="/images/github.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步</h1><div class="post-info">Oct 5, 2021</div><div class="post-content"><p>上次讲过了操作栈与数值运算操作，这篇专栏主要讲ASM中有关于类型、数组与方法调用的字节码。</p>
<p><em>P.S.ASM库已经更新到了9.2版本，可以试试解析Java 18的类了。</em></p>
<h1 id="一-有关于类型的字节码"><a href="#一-有关于类型的字节码" class="headerlink" title="一.有关于类型的字节码"></a>一.有关于类型的字节码</h1><p>有关于类型的字节码都是用visitTypeInsn进行写入的。这类字节码共有4个：NEW，ANEWARRAY，INSTANCEOF和CHECKCAST。ANEWARRAY在之后的数组字节码里面会仔细去讲。</p>
<h2 id="1-new"><a href="#1-new" class="headerlink" title="[1. new]"></a>[1. new]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：无</span><br><span class="line">输出：一个指定类型的对象</span><br><span class="line">方法：visitTypeInsn</span><br><span class="line">参数：类型</span><br><span class="line">使用范例：</span><br><span class="line">	mv.visitTypeInsn(NEW, <span class="string">&quot;java/lang/Object&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>NEW只进行创建对象，不负责调用构造函数，所以内部字段的值都为默认值。调用构造函数必须用invokespecial字节码进行调用（下文）。</p>
<p>在调用这个字节码时，如果指向的类没有初始化，就它的调用静态初始化函数&lt;clinit&gt;。如果在初始化中发生异常就会抛出错误。如果目标类的类格式有误，则抛出异常。如果目标类时抽象的，则抛出<code>InstantiationError</code>。</p>
<h2 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="[2. instanceof]"></a>[2. instanceof]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：一个对象</span><br><span class="line">输出：布尔值，代表是否为指定类的对象（栈上表示为一个四字节数据）</span><br><span class="line">方法：visitTypeInsn</span><br><span class="line">参数：类型（对于数组是描述符）</span><br><span class="line">使用范例：</span><br><span class="line">  mv.visitTypeInsn(INSTANCEOF, <span class="string">&quot;java/lang/String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>instanceof用于检查对象是否为这个类型的实例，如果是则返回boolean值true，即操作栈上的一个int数据1；如果不是就返回0。</p>
<p>对于null对象，该字节码永远返回0。</p>
<h2 id="3-checkcast"><a href="#3-checkcast" class="headerlink" title="[3. checkcast]"></a>[3. checkcast]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：一个对象</span><br><span class="line">输出：类型检查后的对象</span><br><span class="line">方法：visitTypeInsn</span><br><span class="line">参数：类型（对于数组是描述符）</span><br><span class="line">使用范例：</span><br><span class="line">  mv.visitTypeInsn(CHECKCAST, <span class="string">&quot;java/io/InputStream&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>checkcast用于检查对象的类型，类似于instanceof。但不同的是，如果无法将对象转换为指定类型，该字节码会抛出ClassCastException。这个字节码经常见于泛型中。</p>
<p>加入这个字节码通常是为了指定对象是某个类型好让验证器验证，在局部变量无法得知确切类型时必须加入此字节码保证验证通过（运行时报错就是另一回事了）。</p>
<p>下面是这三个字节码组合的例子：</p>
<p>要生成的Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">testTypeASM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object object = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  <span class="keyword">boolean</span> bool = object <span class="keyword">instanceof</span> String;</span><br><span class="line">  <span class="keyword">return</span> (String) object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的生成这段代码的字节码程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span></span><br><span class="line"><span class="comment">// ---- 第一行语句 -----</span></span><br><span class="line">mv.visitTypeInsn(NEW, <span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">mv.visitInsn(DUP); <span class="comment">// 栈上复制一份对象</span></span><br><span class="line">mv.visitLdcInsn(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/String&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">false</span>); <span class="comment">// 执行构造函数</span></span><br><span class="line">mv.visitVarInsn(ASTORE, <span class="number">0</span>); <span class="comment">// 存在局部变量表0号位</span></span><br><span class="line"><span class="comment">// ---- 第二行语句 -----</span></span><br><span class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>); <span class="comment">// 取出局部变量object</span></span><br><span class="line">mv.visitTypeInsn(INSTANCEOF, <span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">mv.visitVarInsn(ISTORE, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// ---- 第三行语句 -----</span></span><br><span class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">mv.visitTypeInsn(CHECKCAST, <span class="string">&quot;java/lang/String&quot;</span>); <span class="comment">// 注：此处可以不加这个CHECKCAST，因为局部变量表已知是String。如果局部变量表无法判断是否真的为String且没有加入这个语句，在验证时下方ARETURN字节码会报错</span></span><br><span class="line">mv.visitInsn(ARETURN);</span><br><span class="line"><span class="comment">// ---- 结束 ----</span></span><br><span class="line">mv.visitMaxs(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">mv.visitEnd();</span><br></pre></td></tr></table></figure>

<h1 id="二-数组操作的字节码"><a href="#二-数组操作的字节码" class="headerlink" title="二.数组操作的字节码"></a>二.数组操作的字节码</h1><p>数组操作的字节码一共有20个，其中加载指令8个，存储指令8个，三个创建还有一个获取数组长度的字节码。</p>
<h2 id="1-newarray"><a href="#1-newarray" class="headerlink" title="[1. newarray]"></a>[1. newarray]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">int</span>，代表数组长度</span><br><span class="line">输出：指定长度的数组</span><br><span class="line">方法：visitIntInsn</span><br><span class="line">参数：数组的类型，有<span class="number">8</span>个常量值分别代表了不同的值类型</span><br><span class="line">使用范例：</span><br><span class="line">  mv.visitIntInsn(NEWARRAY, T_INT);</span><br></pre></td></tr></table></figure>

<p>和newarray字节码用于创建基本类型的数组，它的参数代表了它的类型，在Opcodes类中一共有8个：T_BOOLEAN（boolean），T_CHAR（char），T_FLOAT（float），T_DOUBLE（double），T_BYTE（byte），T_SHORT（short），T_INT（int）和T_LONG（long）。</p>
<p>如果数组长度小于0，这个字节码会抛出<code>NegativeArraySizeException</code>。</p>
<h2 id="2-anewarray"><a href="#2-anewarray" class="headerlink" title="[2. anewarray]"></a>[2. anewarray]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">int</span>，代表数组长度</span><br><span class="line">输出：指定长度的数组</span><br><span class="line">方法：visitTypeInsn</span><br><span class="line">参数：类型</span><br><span class="line">使用范例：</span><br><span class="line">  mv.visitTypeInsn(ANEWARRAY, <span class="string">&quot;java/lang/String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>基本类型的数组由newarray创建，而不是基本类型的数组由anewarray创建。</p>
<p>和newarray一样，如果数组长度小于0，这个字节码会抛出<code>NegativeArraySizeException</code>。</p>
<h2 id="3-multianewarray"><a href="#3-multianewarray" class="headerlink" title="[3. multianewarray]"></a>[3. multianewarray]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：一系列的<span class="keyword">int</span>，代表多维数组中每一维的长度</span><br><span class="line">输出：多维数组</span><br><span class="line">方法：visitMultiANewArrayInsn</span><br><span class="line">参数：描述符和维度</span><br><span class="line">使用范例：</span><br><span class="line">  mv.visitMultiANewArrayInsn(<span class="string">&quot;[[Ljava/lang/String;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  mv.visitMultiANewArrayInsn(<span class="string">&quot;[[[I&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>创建一个多维数组，多维数组的描述符要与第二个参数维度相匹配。和另两个字节码相同，如果多维数组任意一维的长度小于0，这个字节码就会抛出<code>NegativeArraySizeException</code>。</p>
<p>下面是使用这三个字节码的例子：</p>
<p>Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrayInt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[][] multi2Int = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line">String[] strings = <span class="keyword">new</span> String[<span class="number">30</span>];</span><br><span class="line">String[][] multiStrings = <span class="keyword">new</span> String[<span class="number">127</span>][<span class="number">128</span>];</span><br></pre></td></tr></table></figure>

<p>生成这些代码的字节码程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span></span><br><span class="line"><span class="comment">// new int[10]</span></span><br><span class="line">mv.visitIntInsn(BIPUSH, <span class="number">10</span>);</span><br><span class="line">mv.visitIntInsn(NEWARRAY, T_INT);</span><br><span class="line">mv.visitVarInsn(ASTORE, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// new int[100][2]</span></span><br><span class="line">mv.visitIntInsn(BIPUSH, <span class="number">100</span>);</span><br><span class="line">mv.visitInsn(ICONST_2);</span><br><span class="line">mv.visitMultiANewArrayInsn(<span class="string">&quot;[[I&quot;</span>, <span class="number">2</span>);</span><br><span class="line">mv.visitVarInsn(ASTORE, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// new String[30]</span></span><br><span class="line">mv.visitIntInsn(BIPUSH, <span class="number">30</span>);</span><br><span class="line">mv.visitTypeInsn(ANEWARRAY, <span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">mv.visitVarInsn(ASTORE, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// new String[127][128]</span></span><br><span class="line">mv.visitIntInsn(BIPUSH, <span class="number">127</span>);</span><br><span class="line">mv.visitIntInsn(SIPUSH, <span class="number">128</span>);</span><br><span class="line">mv.visitMultiANewArrayInsn(<span class="string">&quot;[[Ljava/lang/String;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">mv.visitVarInsn(ASTORE, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>在创建数组时，如果是一维数组就用newarray或anewarray。multianewarray也能创建一维数组，但是使用上面的两个更加高效。</p>
<h2 id="4-arraylength"><a href="#4-arraylength" class="headerlink" title="[4. arraylength]"></a>[4. arraylength]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：数组</span><br><span class="line">输出：数组长度</span><br><span class="line">方法：visitInsn</span><br><span class="line">参数：无</span><br><span class="line">使用范例：</span><br><span class="line">	mv.visitInsn(ARRAYLENGTH);</span><br></pre></td></tr></table></figure>

<p>获取数组的长度，返回int。如果数组输入为null，抛出空指针异常。</p>
<h2 id="5-xaload"><a href="#5-xaload" class="headerlink" title="[5. xaload]"></a>[5. xaload]</h2><p>x=a,b,c,d,f,i,l,s, 其中b同时负责了byte和boolean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：数组，<span class="keyword">int</span>类型的下标</span><br><span class="line">输出：数组元素</span><br><span class="line">方法：visitInsn</span><br><span class="line">参数：无</span><br><span class="line">使用范例：</span><br><span class="line">	mv.visitInsn(BALOAD);</span><br></pre></td></tr></table></figure>

<p>xaload的作用是从数组指定下标取元素。如果下标超过数组长度，抛出<code>ArrayIndexOutOfBoundsException</code>。对于多维数组的提取元素方式类似下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 代码：</span></span><br><span class="line"><span class="comment">// 设int[][] multi = new int[10][20];位于局部变量表0位</span></span><br><span class="line"><span class="keyword">return</span> multi[<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 字节码：</span></span><br><span class="line"><span class="comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span></span><br><span class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">mv.visitInsn(ICONST_1);</span><br><span class="line">mv.visitInsn(AALOAD);</span><br><span class="line">mv.visitInsn(ICONST_4);</span><br><span class="line">mv.visitInsn(IALOAD);</span><br><span class="line">mv.visitInsn(IRETURN);</span><br></pre></td></tr></table></figure>

<h2 id="6-xastore"><a href="#6-xastore" class="headerlink" title="[6. xastore]"></a>[6. xastore]</h2><p>x=a,b,c,d,f,i,l,s, 其中b同时负责了byte和boolean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：数组，<span class="keyword">int</span>类型的下标，一个变量</span><br><span class="line">输出：无</span><br><span class="line">方法：visitInsn</span><br><span class="line">参数：无</span><br><span class="line">使用范例：</span><br><span class="line">	mv.visitInsn(BASTORE);</span><br></pre></td></tr></table></figure>

<p>将对象存入数组指定下标。如果下标超过数组长度，抛出<code>ArrayIndexOutOfBoundsException</code>。对于多维数组，存储对象需要和xaload一起配合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 代码：</span></span><br><span class="line"><span class="comment">// 设int[][] multi = new int[10][20];位于局部变量表0位</span></span><br><span class="line">multi[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 字节码：</span></span><br><span class="line"><span class="comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span></span><br><span class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">mv.visitInsn(ICONST_1);</span><br><span class="line">mv.visitInsn(AALOAD);</span><br><span class="line">mv.visitInsn(ICONST_4);</span><br><span class="line">mv.visitIntInsn(BIPUSH, <span class="number">20</span>);</span><br><span class="line">mv.visitInsn(IASTORE);</span><br></pre></td></tr></table></figure>

<h1 id="三-操作字段的字节码"><a href="#三-操作字段的字节码" class="headerlink" title="三.操作字段的字节码"></a>三.操作字段的字节码</h1><p>在代码中我们经常会调用类中的字段，例如<code>System.out</code>。Java提供了四个字节码用于访问和修改字段。</p>
<h2 id="1-getfield"><a href="#1-getfield" class="headerlink" title="[1. getfield]"></a>[1. getfield]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：一个对象</span><br><span class="line">输出：对应字段的值</span><br><span class="line">方法：visitFieldInsn</span><br><span class="line">参数：字段所处的类、字段名、字段描述符</span><br><span class="line">使用范例：</span><br><span class="line">	mv.visitFieldInsn(GETFIELD, <span class="string">&quot;org/objectweb/asm/MethodVisitor&quot;</span>, <span class="string">&quot;mv&quot;</span>, <span class="string">&quot;Lorg/objectweb/asm/MethodVisitor;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>getfield用于获取非静态字段的值。如果它作用目标是一个静态字段，则在类连接验证时抛出<code>IncompatibleClassChangeError</code>。</p>
<p>如果输入的对象是null，这个字节码会在运行时抛出空指针异常。</p>
<p>这个字节码不能调用数组的length字段，在编译的时候length字段会自行转变成arraylength字节码。</p>
<h2 id="2-getstatic"><a href="#2-getstatic" class="headerlink" title="[2. getstatic]"></a>[2. getstatic]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：无</span><br><span class="line">输出：对应字段的值</span><br><span class="line">方法：visitFieldInsn</span><br><span class="line">参数：字段所处的类、字段名、字段描述符</span><br><span class="line">使用范例：</span><br><span class="line"> mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>getstatic用于获取静态字段的值。如果它作用目标是一个非静态字段，则在类连接验证时抛出<code>IncompatibleClassChangeError</code>。</p>
<h2 id="3-putfield"><a href="#3-putfield" class="headerlink" title="[3. putfield]"></a>[3. putfield]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：一个对象、准备修改成的对象</span><br><span class="line">输出：无</span><br><span class="line">方法：visitFieldInsn</span><br><span class="line">参数：字段所处的类、字段名、字段描述符</span><br><span class="line">使用范例：</span><br><span class="line"> mv.visitFieldInsn(PUTFIELD, <span class="string">&quot;org/objectweb/asm/MethodVisitor&quot;</span>, <span class="string">&quot;mv&quot;</span>, <span class="string">&quot;Lorg/objectweb/asm/MethodVisitor;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>putfield用于修改非静态字段的值。如果它作用目标是一个静态字段，则在类连接验证时抛出<code>IncompatibleClassChangeError</code>。</p>
<p>如果输入的对象是null，这个字节码会在运行时抛出空指针异常。</p>
<p>对于final字段，如果不是在初始化对象时修改（构造函数中），那么就会抛出<code>IllegalAccessError</code>。</p>
<h2 id="4-putstatic"><a href="#4-putstatic" class="headerlink" title="[4. putstatic]"></a>[4. putstatic]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：准备修改成的对象</span><br><span class="line">输出：无</span><br><span class="line">方法：visitFieldInsn</span><br><span class="line">参数：字段所处的类、字段名、字段描述符</span><br><span class="line">使用范例：</span><br><span class="line"> mv.visitFieldInsn(PUTSTATIC, <span class="string">&quot;io/github/nickid2018/Constants&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;Z&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>putstatic用于修改静态字段的值。如果它作用目标是一个非静态字段，则在类连接验证时抛出<code>IncompatibleClassChangeError</code>。</p>
<p>对于final字段，如果不是在类初始化时修改（&lt;clinit&gt;中），那么就会抛出<code>IllegalAccessError</code>。</p>
<h1 id="四-调用方法的字节码"><a href="#四-调用方法的字节码" class="headerlink" title="四.调用方法的字节码"></a>四.调用方法的字节码</h1><p>调用方法的字节码共有五个：invokevirtual，invokespecial，invokestatic，invokeinterface和invokedynamic。invokedynamic使用了BSM（BootStrap Method），讲解起来很复杂，所以这个要单独分出来一篇文章去讲。这篇文章主要讨论前四个。</p>
<h2 id="1-invokevirtual"><a href="#1-invokevirtual" class="headerlink" title="[1. invokevirtual]"></a>[1. invokevirtual]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：一个对象，传入参数</span><br><span class="line">输出：与方法返回值有关</span><br><span class="line">方法：visitMethodInsn</span><br><span class="line">参数：方法所在的类，方法名，方法描述符，固定值<span class="keyword">false</span></span><br><span class="line">使用范例：</span><br><span class="line"> mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>这个字节码用于调用实例方法：如果对象是子类的对象且子类复写了这个方法，则调用子类的方法；如果对象就是该类的直接对象或者对象所属子类没有复写这个方法，就调用现在类的方法。</p>
<p>在编译时，如果子类调用了父类的方法且子类没有实现此方法，那么方法所在的类要写为父类。如果使用<code>super</code>，要用invokespecial调用（下文）。</p>
<p>如果方法调用目标是静态的，在连接验证时会抛出<code>IncompatibleClassChangeError</code>。</p>
<p>如果方法调用目标是抽象的，并且在继承树上没有任何实现此方法的类，在调用时会抛出<code>AbstractMethodError</code>。</p>
<p>如果方法调用目标是抽象的，而继承树上由多个实现此方法的类，且这些方法都是可被选中成为调用目标的方法（比如一个类继承于一个抽象类，又实现了两个接口，两个接口中都有一个同样的default方法可作为抽象类中抽象方法的实现目标），这时此字节码会抛出<code>IncompatibleClassChangeError</code>。</p>
<p>如果方法调用目标是native的，且没有任何JNI连接查询到这个方法和哪个C函数相连接，这时这个字节码抛出<code>UnsatisfiedLinkError</code>。</p>
<h2 id="2-invokespecial"><a href="#2-invokespecial" class="headerlink" title="[2. invokespecial]"></a>[2. invokespecial]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：一个对象，传入参数</span><br><span class="line">输出：与方法返回值有关</span><br><span class="line">方法：visitMethodInsn</span><br><span class="line">参数：方法所在的类，方法名，方法描述符，固定值<span class="keyword">false</span></span><br><span class="line">使用范例：</span><br><span class="line"> mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;equals&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>invokespecial类似于invokevirtual，但不同的是，它和调用方法的对象的类型无关：它的方法调用对象就是字节码内部标定的方法，如果这个类找不到就寻找直接超类的方法，而不是像invokevirtual要考虑继承树所有的方法。</p>
<p>这个方法经常在构造函数中看到，因为无论什么类都需要有一个构造函数，而构造函数内部必须自动调用父类构造函数。</p>
<p>一个默认的构造函数类似于下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在生成类时，如果没有自定义其他构造函数，就要加上这个默认构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">cw.visit(V17, ACC_PUBLIC + ACC_SUPER, <span class="string">&quot;Test&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>); <span class="comment">// 加载自身(this)</span></span><br><span class="line">mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="keyword">false</span>); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">mv.visitInsn(RETURN);</span><br><span class="line">mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">mv.visitEnd();</span><br><span class="line">cw.visitEnd();</span><br></pre></td></tr></table></figure>

<h2 id="3-invokestatic"><a href="#3-invokestatic" class="headerlink" title="[3. invokestatic]"></a>[3. invokestatic]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：一个对象，传入参数</span><br><span class="line">输出：与方法返回值有关</span><br><span class="line">方法：visitMethodInsn</span><br><span class="line">参数：方法所在的类，方法名，方法描述符，固定值<span class="keyword">false</span></span><br><span class="line">使用范例：</span><br><span class="line"> mv.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;java/lang/Math&quot;</span>, <span class="string">&quot;sin&quot;</span>, <span class="string">&quot;(D)D&quot;</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>invokestatic用于调用静态方法，如果调用目标不是个静态方法，抛出<code>IncompatibleClassChangeError</code>。</p>
<p>和invokevirtual一样，如果目标是个native方法而JNI找不到连接的C函数，该字节码抛出<code>UnsatisfiedLinkError</code>。</p>
<h2 id="4-invokeinterface"><a href="#4-invokeinterface" class="headerlink" title="[4. invokeinterface]"></a>[4. invokeinterface]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：一个对象，传入参数</span><br><span class="line">输出：与方法返回值有关</span><br><span class="line">方法：visitMethodInsn</span><br><span class="line">参数：方法所在的类，方法名，方法描述符，固定值<span class="keyword">true</span></span><br><span class="line">使用范例：</span><br><span class="line"> mv.visitMethodInsn(INVOKEINTERFACE, <span class="string">&quot;java/util/Set&quot;</span>, <span class="string">&quot;clear&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>这个字节码类似于invokevirtual，异常情况的处理也和它类似。它用于调用接口方法，而不是像invokevirtual的实例方法。</p>
<h1 id="五-抛出异常的字节码：athrow"><a href="#五-抛出异常的字节码：athrow" class="headerlink" title="五.抛出异常的字节码：athrow"></a>五.抛出异常的字节码：athrow</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：一个Throwable对象</span><br><span class="line">输出：操作栈不变</span><br><span class="line">方法：visitInsn</span><br><span class="line">参数：无</span><br><span class="line">使用范例：</span><br><span class="line"> mv.visitInsn(ATHROW);</span><br></pre></td></tr></table></figure>

<p>athrow负责将一个Throwable对象抛出。如果对象是null，那么就不会抛出这个null，而是抛出<code>NullPointerException</code>。</p>
<p>通常情况下，我们都是直接new一个Throwable对象然后直接抛出，就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;error!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>翻译为字节码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span></span><br><span class="line">mv.visitTypeInsn(NEW, <span class="string">&quot;java/lang/Exception&quot;</span>);</span><br><span class="line">mv.visitInsn(DUP);</span><br><span class="line">mv.visitLdcInsn(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/Exception&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">mv.visitInsn(ATHROW);</span><br></pre></td></tr></table></figure>

<h1 id="六-同步字节码"><a href="#六-同步字节码" class="headerlink" title="六.同步字节码"></a>六.同步字节码</h1><p>同步操作共有两个字节码，monitorenter和monitorexit，成套使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：一个对象</span><br><span class="line">输出：无</span><br><span class="line">方法：visitInsn</span><br><span class="line">参数：无</span><br><span class="line">使用范例：</span><br><span class="line"> mv.visitInsn(MONITORENTER);</span><br><span class="line"> mv.visitInsn(MONITOREXIT);</span><br></pre></td></tr></table></figure>

<p>输入的对象必须是引用类型对象，不能是基本类型的值。</p>
<p>使用同步块时，代码类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];<span class="comment">//设0号位</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span></span><br><span class="line">mv.visitInsn(ICONST_0);</span><br><span class="line">mv.visitIntInsn(NEWARRAY, T_BYTE);</span><br><span class="line">mv.visitVarInsn(ASTORE, <span class="number">0</span>);</span><br><span class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">mv.visitInsn(MONITORENTER);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">mv.visitInsn(MONITOREXIT);</span><br></pre></td></tr></table></figure>

<p>monitorenter就是尝试加锁的操作。如果这个对象的监视器条目计数为0，此线程会把这个计数设置为1，这时此线程就是这个对象的监视器；如果不为0且线程不是该对象的监视器，线程会阻塞直到计数为0时重新尝试加锁；如果线程已经是这个对象的监视器，计数递增。</p>
<p>monitorexit就是释放锁的操作。如果线程是这个对象的监视器，计数递减，当计数减为0时该线程就不是这个对象的监视器了。如果线程不是这个对象的监视器，这个字节码会抛出<code>IllegalMonitorStateException</code>。</p>
<p>monitorenter可以和很多monitorexit一起出现，在一个方法的所有可能流程中的加锁次数和释放次数必须相同，否则在调用时会发生<code>IllegalMonitorStateException</code>。</p>
<p>对于同步方法（访问标志含有ACC_SYNCHRONIZED），不需要手动对自身对象或类加锁。JVM在调用方法前隐式加锁，在调用之后隐式释放。</p>
<h1 id="七-应用：计算两数之积"><a href="#七-应用：计算两数之积" class="headerlink" title="七.应用：计算两数之积"></a>七.应用：计算两数之积</h1><p>学到了这些字节码，接下来我们要试试用纯字节码解决这道简单的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：两个双精度浮点数a,b</span><br><span class="line">输出：一个保留5位小数部分的双精度浮点数，代表a*b</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">3.22 6.11</span><br><span class="line">输出：</span><br><span class="line">19.67420</span><br></pre></td></tr></table></figure>

<p>在Java代码下，我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里不写main方法，而是写了一个静态的test方法用于后续调用</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">double</span> a = scanner.nextDouble();</span><br><span class="line">    <span class="keyword">double</span> b = scanner.nextDouble();</span><br><span class="line">    System.out.printf(<span class="string">&quot;%.5f&quot;</span>, a * b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是用ASM生成的步骤：</p>
<p>首先还是创建类和方法，不再多说。</p>
<p>第一行，创建Scanner对象，这里用到的就是new。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span></span><br><span class="line">mv.visitTypeInsn(NEW, <span class="string">&quot;java/util/Scanner&quot;</span>);</span><br><span class="line">mv.visitInsn(DUP);</span><br><span class="line">mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;in&quot;</span>, <span class="string">&quot;Ljava/io/InputStream;&quot;</span>);</span><br><span class="line">mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/util/Scanner&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/io/InputStream;)V&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">mv.visitVarInsn(ASTORE, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>第二行和第三行都是读取double，这里是调用了Scanner的<code>nextDouble</code>方法，这里只给第二行的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/util/Scanner&quot;</span>, <span class="string">&quot;nextDouble&quot;</span>, <span class="string">&quot;()D&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">mv.visitVarInsn(DSTORE, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>接下来是个重头戏。首先来看看<code>PrintStream::printf</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object ... args)</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，args是个不定长参数，这怎么表示呢？</p>
<p>在Java中，不定长参数都被解析为数组，也就是说，它在字节码中的表示其实是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object[] args)</span></span></span><br></pre></td></tr></table></figure>

<p>现在我们需要传递的参数就是一个字符串和一个Object数组。可是double不是引用类型，这又要怎么办呢？</p>
<p>在Java中，基本类型都有它们的“包装类”。double的包装类是java.lang.Double，通过<code>Double::valueOf</code>方法就可以把double值转变为Double对象，也就是装箱操作。在平常编写时，Java编译器会自动为我们添加装箱操作，也就是自动装箱。</p>
<p>经过这样的解析，最后这句话的Java代码表示就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%.5f&quot;</span>, <span class="keyword">new</span> Object[] &#123; Double.valueOf(a * b) &#125;);</span><br></pre></td></tr></table></figure>

<p>其中Object[]是一个长度为1的数组，也就是先创建它然后将Double对象用aastore字节码放入就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>); <span class="comment">// System.out</span></span><br><span class="line">mv.visitLdcInsn(<span class="string">&quot;%.5f&quot;</span>); <span class="comment">// printf的第一个参数</span></span><br><span class="line">mv.visitInsn(ICONST_1); <span class="comment">// Object[]的长度</span></span><br><span class="line">mv.visitTypeInsn(ANEWARRAY, <span class="string">&quot;java/lang/Object&quot;</span>); <span class="comment">// 创建Object[]</span></span><br><span class="line">mv.visitInsn(DUP); <span class="comment">// 复制一份数组，一份用于放入对象，一份用于传入方法</span></span><br><span class="line">mv.visitInsn(ICONST_0); <span class="comment">// 放入数组的位置，0</span></span><br><span class="line">mv.visitVarInsn(DLOAD, <span class="number">1</span>); <span class="comment">// 取出a</span></span><br><span class="line">mv.visitVarInsn(DLOAD, <span class="number">3</span>); <span class="comment">// 取出b（3是因为double要占两个局部变量槽位！）</span></span><br><span class="line">mv.visitInsn(DMUL); <span class="comment">// 计算 a * b</span></span><br><span class="line">mv.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;java/lang/Double&quot;</span>, <span class="string">&quot;valueOf&quot;</span>, <span class="string">&quot;(D)Ljava/lang/Double;&quot;</span>, <span class="keyword">false</span>); <span class="comment">// 装箱</span></span><br><span class="line">mv.visitInsn(AASTORE); <span class="comment">// 放入数组</span></span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;printf&quot;</span>, <span class="string">&quot;(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;&quot;</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>最后写入return和visitMaxs，局部变量一共5个槽位，最大的操作栈大小是9：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv.visitInsn(RETURN);</span><br><span class="line">mv.visitMaxs(<span class="number">9</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>下面就可以实验了！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.22 6.11</span><br><span class="line">19.67420</span><br></pre></td></tr></table></figure>

<p>测试结果和预测一样！</p>
<p>全部代码：<a target="_blank" rel="noopener" href="https://paste.ubuntu.com/p/NXDfFpQ4y6/">https://paste.ubuntu.com/p/NXDfFpQ4y6/</a></p>
<p>这篇专栏的内容结束了，下一篇：Java ASM详解：MethodVisitor与Opcode（三）标签，选择结构，循环结构，栈帧</p>
<p>这篇文章一共讲了34个字节码，从开始到现在一共讲了164个。</p>
<p>有错误在评论中指出。</p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'Nickid2018';
var disqus_identifier = '2021/10/05/Java-ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步/';
var disqus_title = 'Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步';
var disqus_url = 'http://Nickid2018.github.io/2021/10/05/Java-ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//Nickid2018.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2021/08/08/JEP-412-Foreign-Function-Memory-FFM-API-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E5%AD%98API/" class="next">NEXT</a></div><div class="copyright"><p>© 2021 <a href="http://Nickid2018.github.io">Nickid2018</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>