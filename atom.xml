<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nickid2018的博客</title>
  
  
  <link href="http://nickid2018.github.io/atom.xml" rel="self"/>
  
  <link href="http://nickid2018.github.io/"/>
  <updated>2022-04-06T14:59:42.797Z</updated>
  <id>http://nickid2018.github.io/</id>
  
  <author>
    <name>Nickid2018</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java ASM详解：类的结构（一）</title>
    <link href="http://nickid2018.github.io/2022/03/30/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://nickid2018.github.io/2022/03/30/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-03-30T00:00:00.000Z</published>
    <updated>2022-04-06T14:59:42.797Z</updated>
    
    <content type="html"><![CDATA[<p>了解了各个字节码的意义，我们可以构建出方法。这篇文章开始不再讲具体的字节码，而是开始介绍类的结构。今天这篇文章主要讲类的成员/属性和它们在字节码中的写入表示。</p><h2 id="类静态初始化方法"><a href="#类静态初始化方法" class="headerlink" title="类静态初始化方法"></a>类静态初始化方法</h2><p>当一个类被装载入内存，它是没有<code>静态初始化</code>过的。当从其他类调用它内部的方法或字段时，类才会被静态初始化。静态初始化只进行一次。</p><p>静态初始化的主要工作是在类加载之后使用之前进行内部数据的初始化操作。在Java代码中，它使用<code>static块</code>声明，一个类文件可以有多个static块。</p><pre><code class="hljs Java"><span class="hljs-keyword">static</span> &#123;  <span class="hljs-comment">// Code...</span>&#125;</code></pre><p>在字节码中，静态初始化会被写入成为一个方法，名称为<code>&lt;clinit&gt;</code>，是<code>Class Initialization</code>的缩写。它的描述符要求是<code>()V</code>，不带有泛型签名，不抛出异常，访问标志必须含有<code>static</code>。如果&lt;clinit&gt;不满足这些条件，会产生下面这些报错：</p><div class="table-container"><table><thead><tr><th style="text-align:center">错误输入</th><th style="text-align:left">报错</th></tr></thead><tbody><tr><td style="text-align:center">访问标志不存在static</td><td style="text-align:left">java.lang.ClassFormatError: Method &lt;clinit&gt; is not static in class file *</td></tr><tr><td style="text-align:center">方法描述符不是<code>()V</code></td><td style="text-align:left">java.lang.ClassFormatError: Method “&lt;clinit&gt;” in class * has illegal signature *</td></tr></tbody></table></div><p>和static块不同，在字节码中&lt;clinit&gt;<strong>只能存在一个</strong>。多个static块合成一个&lt;clinit&gt;会按照static块的顺序一块一块进行拼接，同时局部变量也会进行拼接。例如下方的代码：</p><pre><code class="hljs Java"><span class="hljs-keyword">static</span> &#123;  String a = <span class="hljs-string">&quot;a&quot;</span>;  System.out.println(a);&#125;<span class="hljs-keyword">static</span> &#123;  Object a = <span class="hljs-string">&quot;b&quot;</span>;  System.out.println(a);&#125;</code></pre><p>在字节码中会进行拼接，翻译后变成这样：</p><pre><code class="hljs Java"><span class="hljs-keyword">static</span> &#123;  &#123;    String a = <span class="hljs-string">&quot;a&quot;</span>;    System.out.println(a);  &#125;  &#123;    Object a = <span class="hljs-string">&quot;b&quot;</span>;    System.out.println(a);  &#125;&#125;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建某个类的对象必然会调用某一个具体的构造函数。构造函数的意义就是对类对象内部数据进行初始化。</p><p>在字节码中，构造函数的名称是<code>&lt;init&gt;</code>而非类名。它要求返回值是<code>void（V）</code>，访问标志只包含访问权限标志（public/protected/private），对于参数列表和异常列表不加限制。如果不满足上面的条件，JVM在加载阶段会抛出下面的异常：</p><div class="table-container"><table><thead><tr><th style="text-align:center">错误输入</th><th style="text-align:left">报错</th></tr></thead><tbody><tr><td style="text-align:center">访问标志存在不合法的标志</td><td style="text-align:left">java.lang.ClassFormatError: Method &lt;init&gt; in class * has illegal modifiers: *</td></tr><tr><td style="text-align:center">方法描述符返回值不是<code>V</code></td><td style="text-align:left">java.lang.ClassFormatError: Method “&lt;init&gt;” in class * has illegal signature *</td></tr></tbody></table></div><p>构造函数的另一项限制在它的内部。构造函数必须调用它父类的构造函数或本类的另一个构造函数，否则会在验证时抛出<code>java.lang.VerifyError: Constructor must call super() or this() before return</code>。</p><p>每个类都要含有一个构造函数。如果源码中没有构造函数，那么编译时会自动添加默认构造函数，它的Java源码和字节码写入如下：</p><p>【注意：这里的代码不适用于非静态内部类，下文会详细介绍】</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassName</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">super</span>();&#125;<span class="hljs-comment">// --- 字节码</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// 加载this</span>mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 类名需要改成父类</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);</code></pre><h2 id="类字段的初始化"><a href="#类字段的初始化" class="headerlink" title="类字段的初始化"></a>类字段的初始化</h2><p>类中的静态字段不和类对象绑定而和类绑定，因此它们必须在静态初始化时被初始化；而类中的实例字段和对象绑定，需要在对象构造时被初始化。</p><ul><li>如果初始化语句是一个常量字面值且字段是静态字段，如<code>字符串</code>、<code>数字</code>、<code>null</code>或<code>XXXX.class</code>，它们的初始化字节码应该直接使用<code>visitField</code>的<code>value</code>参数将初始值传入。</li><li>如果初始化语句不是常量字面值或不是静态字段，如<code>调用方法语句</code>、<code>对象创建</code>、<code>数组创建</code>等，它们的初始化字节码应该在<code>&lt;clinit&gt;</code>或<code>&lt;init&gt;</code>方法内。</li></ul><p>根据这个规则，我们可以推断出一段静态字段初始化的代码的具体实现：</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONST_INT = <span class="hljs-number">1</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> START_TIME = System.currentTimeMillis();<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object object;</code></pre><p>在写入字节码时，Java代码应该是这样的：</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONST_INT = <span class="hljs-number">1</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> START_TIME;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object object;<span class="hljs-keyword">static</span> &#123;  START_TIME = System.currentTimeMillis();&#125;</code></pre><p>写入字节码的代码：</p><pre><code class="hljs Java"><span class="hljs-comment">// 类名为Test，省略ClassWriter创建</span>FieldVisitor fv = cw.visitField(ACC_PUBLIC + ACC_STATIC + ACC_FINAL, <span class="hljs-string">&quot;CONST_INT&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>);fv.visitEnd();fv = cw.visitField(ACC_PUBLIC + ACC_STATIC + ACC_FINAL, <span class="hljs-string">&quot;START_TIME&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);fv.visitEnd();fv = cw.visitField(ACC_PUBLIC + ACC_STATIC, <span class="hljs-string">&quot;object&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/Object;&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);fv.visitEnd();MethodVisitor mv = cw.visitMethod(ACC_STATIC, <span class="hljs-string">&quot;&lt;clinit&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;currentTimeMillis&quot;</span>, <span class="hljs-string">&quot;()J&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitFieldInsn(PUTSTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;START_TIME&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>);mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);mv.visitEnd();</code></pre><p>在字节码中，静态初始化方法内可以对一个静态常量字段进行多次赋值，并且JVM不报错。如果在静态初始化中不存在初始化某个静态字段的代码，那么它们就会使用默认值，也就是<code>visitField</code>中<code>value</code>参数决定的值。</p><p>实例字段的初始化类似于静态初始化，只是它们在构造函数内写入。</p><h2 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h2><p>在介绍桥接方法（Bridge Method）之前，先来简单介绍<strong>重写</strong>（Override）。</p><p>重写就是子类将父类的某个方法进行覆盖，进而实际执行时会执行子类方法而不是父类的。重写需要满足：</p><ul><li><strong>名称相同</strong>：父类的方法名称必须与子类的方法名称相同。</li><li><strong>参数列表对应</strong>：父类的方法参数列表应该与子类一一对应，这一点适用于泛型，也就是子类确定的类型参数应该在重写方法中带入类型参数确定的类型。</li><li><strong>异常列表不增添</strong>：子类的复写方法不能出现父类没有声明抛出的异常。</li><li><strong>访问权限不缩小</strong>：子类的复写方法的可见性不能低于父类方法可见性，如父类的访问可见性为<code>public</code>，那么子类也必须声明为<code>public</code>。</li></ul><p>下面是具体的例子，下方的重写案例都是正常能通过编译的：</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SupClass</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(T t)</span></span>;  <span class="hljs-function">R <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">R <span class="hljs-title">test4</span><span class="hljs-params">(T t)</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span>&lt;<span class="hljs-title">R</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">SupClass</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">R</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> ...</span><span class="hljs-function">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(String s)</span> ...</span><span class="hljs-function">  <span class="hljs-keyword">public</span> R <span class="hljs-title">test3</span><span class="hljs-params">()</span> ...</span><span class="hljs-function">  <span class="hljs-keyword">public</span> R <span class="hljs-title">test4</span><span class="hljs-params">(String s)</span> ...</span><span class="hljs-function">&#125;</span></code></pre><p>之前我们说到，泛型的实现是所谓的<strong>泛型擦除</strong>，也就是类型参数会被擦除到其限定的父类上。现在来看看<code>test2</code>这个方法，在父类和子类中，它们的方法描述符和泛型签名是不一样的：</p><pre><code class="hljs Java">SupClass test2:  (Ljava/lang/Object;)V &lt;T:Ljava/lang/Object;&gt;(T)VBaseClass test2: (Ljava/lang/String;)V <span class="hljs-keyword">null</span></code></pre><p>虽然描述符不同，但是在逻辑上已经达成了重写条件，应该当作重写处理。但是，因为方法描述符不同，实际调用时JVM是找不到这个方法的：<code>invokevirtual</code>字节码<strong>只会寻找名称相同且方法描述符相同的方法</strong>。因此，桥接方法出现用于解决这个问题。它的代码意义就是将确定的类型参数强制转换，将父类泛型化的参数传入具体化的子类复写方法中。</p><p>例如test2，编译器给出的桥接方法就像下面这样：</p><pre><code class="hljs Java"><span class="hljs-comment">// BaseClass</span><span class="hljs-comment">// 注意：不要在源码中这样写！编译器会因为&quot;具有相同擦除但不构成重写&quot;抛出异常</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(Object s)</span> </span>&#123; <span class="hljs-comment">// 父类的方法描述符</span>  test2((String) s); <span class="hljs-comment">// 通过强制类型转换，将参数列表转换以满足子类的方法描述符</span>&#125;</code></pre><p>桥接方法仅出现在<strong>父类方法和子类重写方法擦除后的方法描述符不一致</strong>时，如下方的例子：</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SupClass</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>, <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(T t)</span></span>;  <span class="hljs-function">R <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> E</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span>&lt;<span class="hljs-title">R</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStream</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">SupClass</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">R</span>, <span class="hljs-title">IOException</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(String s)</span> ...</span><span class="hljs-function">  <span class="hljs-comment">// 需要生成桥接方法：参数列表描述符不同</span></span><span class="hljs-function">  R <span class="hljs-title">test2</span><span class="hljs-params">()</span> ...</span><span class="hljs-function">  <span class="hljs-comment">// 需要生成桥接方法：R擦除到的类型和父类擦除不一样</span></span><span class="hljs-function">  <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException ...</span><span class="hljs-function">  <span class="hljs-comment">// 不需要生成桥接方法：方法描述符相同</span></span><span class="hljs-function">&#125;</span></code></pre><p>桥接方法拥有下面的特性：</p><ul><li>名称与方法描述符相同：为了<code>invokevirtual</code>字节码能成功定位到这个重写方法，桥接方法必须和父类的目标方法名称和描述符一致。</li><li>访问标志带有<code>ACC_SYNTHETIC</code>和<code>ACC_BRIDGE</code>标志。</li><li>访问权限和子类重写方法相同。</li><li>异常列表和父类方法相同。</li></ul><p>接下来我们要使用字节码实现<code>BaseClass</code>：</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SupClass</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span>:</span><span class="hljs-function">&#125;</span><span class="hljs-function"></span><span class="hljs-function">class BaseClass implements SupClass&lt;String&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String s)</span> </span>&#123;    System.out.println(s);  &#125;&#125;</code></pre><p>字节码：</p><pre><code class="hljs Java"><span class="hljs-comment">// 略过构造函数，cw是ClassWriter</span>MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>);mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);mv.visitEnd();<span class="hljs-comment">// 桥接方法</span>mv = cw.visitMethod(ACC_PUBLIC + ACC_SYNTHETIC + ACC_BRIDGE, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Object;)V&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>);mv.visitTypeInsn(CHECKCAST, <span class="hljs-string">&quot;java/lang/String&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);mv.visitEnd();</code></pre><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类的内部成员除了字段和方法外，还有内部类。内部类分为两种：</p><ul><li>静态内部类：使用static修饰的内部类。内部接口、内部枚举默认带有static访问标志，因此它们也属于静态内部类。</li><li>非静态内部类：不使用static修饰的内部类。</li></ul><p>内部类的字节码数据不应该在外部类中的类文件数据中出现，应该独立于外部类。命名方式为<code>外部类名称$内部类名称</code>；如果内部类是局部内部类，在内部类名称前还需要加上编号；如果内部类是一个匿名内部类，应该使用编号代替。</p><p>虽然内部类不需要写在外部类文件里面，但是外部类文件还是要声明它的。声明使用<code>ClassWriter</code>的<code>visitInnerClass</code>方法，它的每个参数的意义如下：</p><ul><li>name - 内部类的全限定名。例如<code>test.Test</code>下的内部类<code>Inner</code>这项值就是<code>test/Test$Inner</code>。</li><li>outerName - 外部类的全限定名，如果内部类是匿名内部类或局部内部类，这项是<code>null</code>。</li><li>innerName - 内部类的名称，如果内部类是匿名内部类，这项是<code>null</code>。</li><li>access - 内部类的访问标志。</li></ul><p>最外层外部类需要写出它内部所有的类，包括嵌套的内部类。</p><p>下面是一些内部类和它们的声明：</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner1</span> </span>&#123; ... &#125; <span class="hljs-comment">// 内部类1 - 成员内部类</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner2</span> </span>&#123; ... &#125; <span class="hljs-comment">// 内部类2 - 局部内部类</span>    System.out.println(<span class="hljs-keyword">new</span> Test() &#123; ... &#125;); <span class="hljs-comment">// 内部类3 - 匿名内部类</span>  &#125;&#125;<span class="hljs-comment">// --- 字节码 外部类Test cw是ClassWriter</span>cw.visitInnerClass(<span class="hljs-string">&quot;Test$Inner1&quot;</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Inner1&quot;</span>, ACC_PRIVATE);cw.visitInnerClass(<span class="hljs-string">&quot;Test$1Inner2&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Inner2&quot;</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 局部内部类无访问标志</span>cw.visitInnerClass(<span class="hljs-string">&quot;Test$1&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 匿名内部类无访问标志</span></code></pre><p>在Java 11，JEP 181（Nest-Based Access Control）加入了<code>NestHost</code>和<code>NestMember</code>两项属性用于辅助访问权限控制，规定了所有内部类（包括嵌套的内部类）是最外层外部类的<code>NestMember</code>，最外层的外部类是所有内部类（包括嵌套）的<code>NestHost</code>。</p><p>声明<code>NestMember</code>使用<code>ClassWriter</code>的<code>visitNestMember</code>方法，参数是内部类的全限定名。写入它的字节码如下（仍然使用上方的代码）：</p><pre><code class="hljs Java">cw.visitNestMember(<span class="hljs-string">&quot;Test$Inner1&quot;</span>);cw.visitNestMember(<span class="hljs-string">&quot;Test$1Inner2&quot;</span>);cw.visitNestMember(<span class="hljs-string">&quot;Test$1&quot;</span>);</code></pre><p>说回到内部类文件，它也需要声明外部类和<code>NestHost</code>。声明外部类也使用<code>visitInnerClass</code>方法，需要写出所有的外部类，包括嵌套；声明<code>NestHost</code>使用<code>visitNestHost</code>方法，参数是最外层外部类全限定名。</p><p>下面是<code>Inner1</code>声明外部类的字节码写入：</p><pre><code class="hljs Java">cw.visitNestHost(<span class="hljs-string">&quot;Test&quot;</span>);cw.visitInnerClass(<span class="hljs-string">&quot;Test$Inner1&quot;</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Inner1&quot;</span>, ACC_PRIVATE);</code></pre><p>内部类的声明到此为止，接下来看看内部类和外部类的不同之处。</p><p>对于非静态内部类，它的类对象需要依托于一个外部类实例才能创建。例如下方的代码：</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;  &#125;&#125;<span class="hljs-comment">// ----</span>OuterClass outer = <span class="hljs-keyword">new</span> OuterClass();InnerClass inner = outer.<span class="hljs-function">new <span class="hljs-title">InnerClass</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 正确：使用外部类实例调用内部类默认构造函数</span>InnerClass inner2 = <span class="hljs-keyword">new</span> InnerClass(); <span class="hljs-comment">// 错误：需要一个外部类对象创建内部类对象</span></code></pre><p>非静态内部类保存了外部类的实例，保存的字段名称是<code>this$嵌套类深度-1</code>（如果名称已存在那么就在这个名字后加<code>$</code>直到不存在有这个名称的字段），以<code>InnerClass</code>举例，它的字节码实际上类似于这样：</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-comment">/* synthetic */</span> OuterClass <span class="hljs-keyword">this</span>$<span class="hljs-number">0</span>;   ...&#125;</code></pre><p>外部类实例字段要求访问标志是<code>ACC_FINAL</code>和<code>ACC_SYNTHETIC</code>。使用<code>类名.this</code>相当于使用这个字段逐级获取，下面两个代码等价：</p><pre><code class="hljs Java">OuterClass.<span class="hljs-keyword">this</span><span class="hljs-keyword">this</span>.<span class="hljs-keyword">this</span>$<span class="hljs-number">0</span></code></pre><p>为了适应外部类实例字段的加入，非静态内部类的构造函数和普通的构造函数不同。它的第一个局部变量仍然是<code>this</code>，但是第二个局部变量（或者说是第一个形式参数）成为了<strong>外部类的实例</strong>，从第二个形式参数开始才是真正在源码层级的参数列表。内部类的默认构造函数如下（使用<code>InnerClass</code>举例）。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClass</span><span class="hljs-params">(OuterClass <span class="hljs-keyword">this</span>$<span class="hljs-number">0</span>)</span> </span>&#123; <span class="hljs-comment">// 源码中这样写和字节码中是不一样的，编译器会自动在第一个参数前加上这个参数</span>  <span class="hljs-comment">// 字节码中不要求super调用是第一句语句</span>  <span class="hljs-keyword">this</span>.<span class="hljs-keyword">this</span>$<span class="hljs-number">0</span> = <span class="hljs-keyword">this</span>$<span class="hljs-number">0</span>;  <span class="hljs-keyword">super</span>();&#125;</code></pre><p>字节码如下：</p><pre><code class="hljs Java"><span class="hljs-comment">// cw是ClassVisitor</span>MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(LOuterClass;)V&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>);mv.visitFieldInsn(PUTFIELD, <span class="hljs-string">&quot;OuterClass$InnerClass&quot;</span>, <span class="hljs-string">&quot;this$0&quot;</span>, <span class="hljs-string">&quot;LOuterClass;&quot;</span>); <span class="hljs-comment">// 赋值字段</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 调用super</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);mv.visitEnd();</code></pre><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>密封类（Sealed Class）于Java 15（JEP 360）被加入，它限制了类可被哪些类继承。下面是例子：</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> sealed <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupClass</span> <span class="hljs-title">permits</span> <span class="hljs-title">SubA</span>, <span class="hljs-title">SubB</span> </span>&#123; <span class="hljs-comment">// 密封类要求至少有一个子类</span>&#125;<span class="hljs-keyword">public</span> non-sealed <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SupClass</span> </span>&#123; <span class="hljs-comment">// 密封类子类要求必须具有non-sealed/sealed/final修饰</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SupClass</span> </span>&#123;&#125;</code></pre><p>声明密封类属性只需要<code>ClassWriter</code>的<code>visitPermittedSubclass</code>，参数是子类全限定名。上面的<code>SupClass</code>字节码可以这样写入：</p><pre><code class="hljs Java"><span class="hljs-comment">// cw是ClassWriter</span>cw.visitPermittedSubclass(<span class="hljs-string">&quot;SubA&quot;</span>);cw.visitPermittedSubclass(<span class="hljs-string">&quot;SubB&quot;</span>);</code></pre><hr><p>类的基本结构就到这里，下一期：类的结构（二），主要讲解枚举、记录等特殊的类结构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;了解了各个字节码的意义，我们可以构建出方法。这篇文章开始不再讲具体的字节码，而是开始介绍类的结构。今天这篇文章主要讲类的成员/属性和它们在字节码中的写入表示。&lt;/p&gt;
&lt;h2 id=&quot;类静态初始化方法&quot;&gt;&lt;a href=&quot;#类静态初始化方法&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="ASM" scheme="http://nickid2018.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Java ASM详解：泛型</title>
    <link href="http://nickid2018.github.io/2022/02/13/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B/"/>
    <id>http://nickid2018.github.io/2022/02/13/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B/</id>
    <published>2022-02-13T00:00:00.000Z</published>
    <updated>2022-02-13T04:35:53.486Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的字节码学习中，我们都是对有确定类型的数据/类进行操作。可是，Java有着一种“黑”操作用于更好的检查对象类型：在Java 5加入的泛型。</p><h2 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h2><p>在正式导入泛型声明之前，先说说泛型描述符。</p><p>普通的非基本类型的描述符的命名方法是<code>L+类名+;</code>，但是泛型不能以这种方式命名——它需要和普通的描述符有区别以便于区分。所以，它的命名要求是<code>T+泛型名称+;</code>。所以一个命名为<code>T</code>的泛型的描述符是<code>TT;</code>。接下来说回到声明。</p><p>每个泛型在使用之前必须经过声明，声明的位置是类、方法、字段、内部类等的声明部分。如果非静态方法或字段使用的泛型在它们所在的类中被声明过了，那么在它们声明时这个泛型不需要二次声明。</p><p>泛型要求必须继承于一个确切的类，对于没有写<code>extends</code>限定的泛型，它们默认继承于<code>Object</code>。</p><p>在字节码中，泛型的声明要用尖括号包围。每对泛型用冒号隔开，冒号前方是类型参数名称，后方是类型参数的超类或另一个已声明的类型参数。如果类型参数继承于一个接口，那么应该使用双冒号。（可以不用遵守这个约定，冒号数量不影响解析）</p><p>泛型与泛型之间不需要多余的分隔符分割它们的定义，这是因为描述符都以分号结尾从而阻止二义性的解析。（这里也就说明了为什么基本类型不能当类型参数的限制符号，它们的描述符不带分号会造成不可阻止的二义性解析）</p><p>下面是泛型声明的例子：</p><pre><code class="hljs Java">T extends InputStream&lt;T:Ljava/io/InputStream;&gt;T extends Serializable&lt;T::Ljava/io/Serializable;&gt;T, E extends T&lt;T:Ljava/lang/Object;E:TT;&gt;</code></pre><p>但是上面的几条规范不能包括我们使用的所有情况。就比如下面的例子：</p><pre><code class="hljs Java">T extends Enum&lt;T&gt;</code></pre><p>类型参数的超类具有类型参数的使用，这时我们需要写出超类类型参数的位置和限定关系。</p><p>对于一个使用了类型参数的类，它需要在类名之后分号之前用尖括号表示各个类型参数的配置。每个参数都可以是确切的类、声明过的类型参数或通配符。和上面的声明一样，因为描述符以分号结尾，不会产生二义性解析，因此不需要额外分隔符用于分割定义。</p><p>对于上面的例子，它的声明就可以表示成：</p><pre><code class="hljs Java">&lt;T:Ljava/lang/Enum&lt;TT;&gt;;&gt;</code></pre><p>这个T可以代指所有的枚举类型，因为所有的枚举都隐式继承<code>Enum</code>。</p><p>如果超类类型参数使用通配符<code>?</code>代替，就有三种情况：</p><ul><li><p>没有任何限定，需要用<code>*</code>填入</p></li><li><p>有extends限定，需要用<code>+</code>加上超类描述符填入</p></li><li><p>有super限定，需要用<code>-</code>加上子类描述符填入</p></li></ul><p>下面是这三种情况的实例：</p><pre><code class="hljs Java">T extends Set&lt;?&gt;&lt;T::Ljava/util/Set&lt;*&gt;;&gt;T extends List&lt;? extends T&gt;&lt;T::Ljava/util/List&lt;+TT;&gt;;&gt;T extends Map&lt;? <span class="hljs-keyword">super</span> FileInputStream, T&gt;&lt;T::Ljava/util/Map&lt;-Ljava/io/FileInputStream;TT;&gt;;&gt;</code></pre><h2 id="泛型签名"><a href="#泛型签名" class="headerlink" title="泛型签名"></a>泛型签名</h2><p>泛型在声明之后就可以用于描述类、字段、方法等的具体描述符，这部分也叫泛型签名，是另一种描述类、字段、方法类型的方式。</p><p>泛型签名与修饰的结构有关。它不仅包含了类、字段、方法每个具体位置上需要的具体类型，还包含对泛型的声明。如果这个签名中使用的泛型没有被声明过，那么就应该在签名的前方加入它的声明。（也就是说声明是签名的一部分）</p><p>下面对签名的不同作用位置分开说明：</p><ul><li>泛型签名修饰了一个类。类有两个地方需要泛型的信息：超类和实现接口。这些类的具体泛型信息要以超类和实现接口的顺序排列写入，写入规则和上面的类型参数超类写入规则一样。</li></ul><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface2</span>&lt;<span class="hljs-title">T</span>&gt;</span><span class="hljs-class">&lt;<span class="hljs-title">T</span>:<span class="hljs-title">Ljava</span>/<span class="hljs-title">lang</span>/<span class="hljs-title">Object</span></span>;&gt;LSuperClass&lt;TT;&gt;;LInterface1;LInterface2&lt;TT;&gt;;</code></pre><ul><li>泛型签名修饰了一个字段。字段只需要描述字段本身具体的泛型信息，并且字段不能定义泛型，所以泛型签名只包含它的类型的泛型信息。</li></ul><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Set&lt;T&gt; set;Ljava/util/Set&lt;TT;&gt;;</code></pre><ul><li>泛型签名修饰了一个方法。这时这里就是方法描述符的具体泛型信息。格式类似普通的方法描述符，只是泛型信息的写入要遵照上方规则。如果方法带有抛出异常声明并且异常列表含有泛型，那么在描述符之后还要加上异常列表。异常列表的每个类都要用^开头并且需要写出具体的泛型信息。</li></ul><pre><code class="hljs Java"><span class="hljs-keyword">public</span> &lt;E extends Exception&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T obj, List&lt;? <span class="hljs-keyword">super</span> T&gt; list)</span> <span class="hljs-keyword">throws</span> E</span><span class="hljs-function">&lt;E:Ljava/lang/Exception</span>;&gt;(TT;Ljava/util/List&lt;-TT;&gt;;)V^TE;</code></pre><p>下面我们定义一个类作为例子，写出所有成员的泛型签名：</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<span class="hljs-comment">// &lt;T::Ljava/util/List&lt;+Ljava/lang/Number;&gt;;&gt;Ljava/lang/Object;Ljava/lang/Comparable&lt;TT;&gt;</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> &lt;E extends Exception&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(T obj)</span> <span class="hljs-keyword">throws</span> E</span>;<span class="hljs-comment">// &lt;E:Ljava/lang/Exception;&gt;(TT;)V^TE;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// ()TT;</span><span class="hljs-keyword">public</span> Set&lt;T&gt; set;<span class="hljs-comment">// Ljava/lang/Set&lt;TT;&gt;;</span>&#125;</code></pre><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>在阅读完上面的文本后，你可能会有一个疑问：Java已经有方法描述符可以用来描述方法、字段描述符来描述字段等等，为什么还要再加入一个泛型签名用于额外的检查呢？这就有关于Java对泛型的具体实现方式，也就是<strong>泛型擦除</strong>。</p><p>在正式介绍这个机制之前，我们先看看反射对于泛型的处理。定义下面这个类：</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStream</span>&gt; </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T stream)</span> </span>&#123;&#125;&#125;</code></pre><p>接下来我们想要反射调用<code>test</code>这个方法。可是我们看到这个方法的形参列表里面含有一个类型参数T，这个我们没有办法具体表示。所以，我们可以用<code>Class</code>类的<code>getDeclaredMethods</code>获取所有方法检查它的真正形参列表的样子：</p><pre><code class="hljs Java">[<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Test.test(java.io.InputStream)]</code></pre><p>可以看到，类型参数的形参的位置上使用了它的超类<code>InputStream</code>。字节码在所有的含有类型参数的地方都用它们的超类的原始类型代替，这种现象就是<strong>泛型擦除</strong>。</p><p>泛型擦除保证了JVM获取方法时不含有未知量，在本质上其实是保证各个字节码中只存在静态的信息，这样能保证运行的正确性，不会产生方法的二义性调用等。</p><p>对于具体的字节码，所有字节码指令都不能用带有泛型信息的类。具体来说，<code>new/checkcast/instanceof/invokeXXX</code>字节码都不能使用任何泛型信息，它们只能使用原始类型和替换的超类。</p><p>在JVM中，泛型擦除之后泛型的真正实现其实是<code>checkcast</code>等字节码指令的约束和运行时对于对象真实类型推断的方法。在下面的例子中能体现字节码对于泛型的约束。</p><h2 id="实例：泛型方法"><a href="#实例：泛型方法" class="headerlink" title="实例：泛型方法"></a>实例：泛型方法</h2><p>下面，我们要生成这样的代码：</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;? extends T&gt; list, T value)</span> </span>&#123;Comparator&lt;? <span class="hljs-keyword">super</span> Number&gt; comparator = (n1, n2) -&gt; (<span class="hljs-keyword">int</span>) Math.signum(n1.doubleValue() - n2.doubleValue());list.sort(comparator);T num = list.get(<span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> num.intValue() + Collections.binarySearch(list, value, comparator);&#125;</code></pre><p>首先写出它的方法描述符和泛型签名：</p><pre><code class="hljs Java">Desc:(Ljava/util/List;Ljava/lang/Number;)I<span class="hljs-comment">// List擦除类型参数所以回到原始类型，T擦除到父类Number</span>Signature:&lt;T:Ljava/lang/Number;&gt;(Ljava/util/List&lt;+TT;&gt;;TT;)I</code></pre><p>接下来注意到第一行有一个lambda表达式，它实现的是<code>Comparator</code>类的<code>compare</code>方法。根据<code>comparator</code>变量的类型，得知实现方法的参数列表应该是<code>(Number, Number)</code>。所以我们应该生成下面的lambda方法：</p><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-comment">/* synthetic */</span> <span class="hljs-keyword">int</span> lambda$test$<span class="hljs-number">0</span>(Number n1, Number n2) &#123;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.signum(n1.doubleValue() - n2.doubleValue());&#125;</code></pre><p>字节码写入如下：</p><pre><code class="hljs Java"><span class="hljs-comment">// 省略方法声明，mv是MethodVisitor</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// n1</span>mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/Number&quot;</span>, <span class="hljs-string">&quot;doubleValue&quot;</span>, <span class="hljs-string">&quot;()D&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// n2</span>mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/Number&quot;</span>, <span class="hljs-string">&quot;doubleValue&quot;</span>, <span class="hljs-string">&quot;()D&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitInsn(DSUB); <span class="hljs-comment">// 相减</span>mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/Math&quot;</span>, <span class="hljs-string">&quot;signum&quot;</span>, <span class="hljs-string">&quot;(D)D&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitInsn(D2I); <span class="hljs-comment">// 强制类型转换</span>mv.visitInsn(IRETURN);mv.visitMaxs(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);</code></pre><p>这时候就能把comparator给构造出来了。注意我们实现的方法是<code>compare(Object, Object)</code>——类型参数T被擦除到父类型<code>Object</code>（<strong>这和你代码中的使用无关，取决于类和方法的定义</strong>），而我们需要的实现是<code>(Number, Number)</code>，这两个不冲突，但是会损失类型信息（下文会讲）。因此我们inDy的参数第一个是实现的目标的描述符，第三个是我们真正实现目标的描述符。</p><pre><code class="hljs Java">mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;compare&quot;</span>, <span class="hljs-comment">// 实现的方法名</span>                          <span class="hljs-string">&quot;()Ljava/util/Comparator;&quot;</span>, <span class="hljs-comment">// 要求返回Comparator，注意泛型被擦除</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/LambdaMetafactory&quot;</span>, <span class="hljs-string">&quot;metafactory&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM的句柄</span>                          Type.getType(<span class="hljs-string">&quot;(Ljava/lang/Object;Ljava/lang/Object;)I&quot;</span>), <span class="hljs-comment">// compare的方法描述符，泛型擦除到了Object</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;lambda$test$0&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Number;Ljava/lang/Number;)I&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// lambda实现方法的句柄</span>                          Type.getType(<span class="hljs-string">&quot;(Ljava/lang/Number;Ljava/lang/Number;)I&quot;</span>) <span class="hljs-comment">// 真正实现的方法描述符</span>);mv.visitVarInsn(ASTORE, <span class="hljs-number">2</span>);</code></pre><p>剩下的代码就比较简单了，就像下面这样：</p><pre><code class="hljs Java">mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// list</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">2</span>); <span class="hljs-comment">// comparator</span>mv.visitMethodInsn(INVOKEINTERFACE, <span class="hljs-string">&quot;java/util/List&quot;</span>, <span class="hljs-string">&quot;sort&quot;</span>, <span class="hljs-string">&quot;(Ljava/util/Comparator;)V&quot;</span>, <span class="hljs-keyword">true</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// list</span>mv.visitInsn(ICONST_0);mv.visitMethodInsn(INVOKEINTERFACE, <span class="hljs-string">&quot;java/util/List&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;(I)Ljava/lang/Object;&quot;</span>, <span class="hljs-keyword">true</span>); <span class="hljs-comment">// 返回值被擦除到Object，这和List::get定义有关而和使用无关</span>mv.visitTypeInsn(CHECKCAST, <span class="hljs-string">&quot;java/lang/Number&quot;</span>); <span class="hljs-comment">// 强制转换到T的擦除类型Number，这是因为局部变量的类型是T</span>mv.visitVarInsn(ASTORE, <span class="hljs-number">3</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">3</span>); <span class="hljs-comment">// num</span>mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/Number&quot;</span>, <span class="hljs-string">&quot;intValue&quot;</span>, <span class="hljs-string">&quot;()I&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// list</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// value</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">2</span>); <span class="hljs-comment">// comparator</span>mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/util/Collections&quot;</span>, <span class="hljs-string">&quot;binarySearch&quot;</span>, <span class="hljs-string">&quot;(Ljava/util/List;Ljava/lang/Object;Ljava/util/Comparator;)I&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitInsn(IADD);mv.visitInsn(IRETURN);mv.visitMaxs(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);</code></pre><p>这样我们的使用泛型的方法就构建好了。我们可以通过反射传入参数：</p><pre><code class="hljs Java"><span class="hljs-comment">// Loader::defineClassNow是自定义的类加载器加载类的方法</span>Class&lt;?&gt; generated = <span class="hljs-keyword">new</span> Loader().defineClassNow(<span class="hljs-string">&quot;Test&quot;</span>, cw.toByteArray());System.out.println(generated.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, List.class, Number.class).invoke(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)), <span class="hljs-number">3</span>));</code></pre><p>得到的结果是：</p><pre><code class="hljs SH">3</code></pre><p>这就说明了我们的方法写入成功并成功地被JVM执行。</p><h2 id="泛型的安全性"><a href="#泛型的安全性" class="headerlink" title="泛型的安全性"></a>泛型的安全性</h2><p>泛型的加入本质是为了确保代码的简洁和编译时辅助类型检查，也就是说，泛型能阻止类型的错误转换，就比如下面的例子：</p><pre><code class="hljs Java">List list = <span class="hljs-keyword">new</span> ArrayList();list.add(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-keyword">int</span> i = (Integer) list.get(<span class="hljs-number">0</span>);</code></pre><p>这种代码在javac编译时是无法检查出语法和类型错误的：List的封装性造成了它内部数据的类型丢失，在get时只能得知对象是Object子类的对象但是不能得知确切的类型。但是在JVM运行时这就不一样了。JVM能知道任何对象的确切类型，因此在强制转换Integer时JVM能探测到<code>String-&gt;Integer</code>这种不可能的强制类型转换并抛出<code>ClassCastException</code>。</p><p>当泛型加入后，这种情况被改变了：</p><pre><code class="hljs Java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-keyword">int</span> i = (Integer) list.get(<span class="hljs-number">0</span>);</code></pre><p>这样的代码在javac就不能通过编译了：get的返回值是类型参数T（通过字节码中的泛型签名得知），在前面的声明中已经定义为String，因此javac可以探测到这个不可能的类型转换，抛出编译异常阻止编译，保证类型的安全性。</p><p>总而言之，<strong>泛型确保了源码级别上的类型安全性</strong>。</p><p>但是在字节码上看来，这就是另外一回事了。因为“泛型擦除”机制，字节码是不能使用泛型检查的，只能通过类型参数的已知超类约束泛型。但是这种约束不能阻止我们使用错误的类型传入：类验证时是无法检查泛型的。下面使用反射（本质和字节码差不多）举一个例子，使用到了我们刚才写的泛型方法：</p><pre><code class="hljs Java">System.out.println(generated.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, List.class, Number.class).invoke(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(List.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>)), <span class="hljs-number">3</span>));</code></pre><p>这里是不会产生任何警告的（即使在IDE中），但是我们能清楚的看出它不符合我们对于test的定义：test要求传入的是<code>List&lt;? extends T&gt;</code>和<code>T</code>的形参，并且T要求是Number的子类，但是我们实际传入的是<code>List&lt;String&gt;</code>和<code>Number</code>，明显不符合test的形参列表。可是我们是能成功调用的：类型擦除让这些类型回到了原始类型，也就是说test的形参列表变成了<code>List</code>和<code>Number</code>，这时与我们传入的对象相符合，因此反射调用不会产生问题，但是在方法内的具体实现时会使用到checkcast用于类型转换，这里就会被JVM检测到异常并抛出<code>ClassCastException</code>。对于我们的这个调用，它最后的结果是：</p><pre><code class="hljs SH">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.reflect.InvocationTargetExceptionat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)at java.base/java.lang.reflect.Method.invoke(Method.java:568)at io.github.nickid2018.asmtest.ASMMain.main(ASMMain.java:23)Caused by: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are <span class="hljs-keyword">in</span> module java.base of loader <span class="hljs-string">&#x27;bootstrap&#x27;</span>)at java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)at java.base/java.util.TimSort.sort(TimSort.java:220)at java.base/java.util.Arrays.sort(Arrays.java:1307)at java.base/java.util.ArrayList.sort(ArrayList.java:1721)at Test.test(Unknown Source)... 5 more</code></pre><p>这样的结果说明了泛型在字节码中是不能保证安全的，类验证无法通过泛型签名阻止错误调用。因此在写入字节码时，遇到泛型必须严谨的检查，否则就会因为类型信息的丢失造成了类型的不安全行为，并且在写字节码时应尽量避免使用泛型。泛型的便利性仅体现在源码上，字节码中的泛型写入很麻烦。</p><hr><p>有关于泛型的字节码知识就到这里了，有错误可以在评论指出。</p><p>到这里有关于具体方法字节码的写入就结束了，之后主要是有关于类结构的详解和ASM库各种工具的讲解。</p><p>下一篇文章暂定为类的结构（一）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前的字节码学习中，我们都是对有确定类型的数据/类进行操作。可是，Java有着一种“黑”操作用于更好的检查对象类型：在Java 5加入的泛型。&lt;/p&gt;
&lt;h2 id=&quot;泛型的声明&quot;&gt;&lt;a href=&quot;#泛型的声明&quot; class=&quot;headerlink&quot; title=&quot;泛型</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="ASM" scheme="http://nickid2018.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Java ASM详解：MethodVisitor与Opcode（五）invokedynamic、方法句柄、lambda</title>
    <link href="http://nickid2018.github.io/2021/12/02/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%BA%94%EF%BC%89invokedynamic%E3%80%81%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84%E3%80%81lambda/"/>
    <id>http://nickid2018.github.io/2021/12/02/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%BA%94%EF%BC%89invokedynamic%E3%80%81%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84%E3%80%81lambda/</id>
    <published>2021-12-02T00:00:00.000Z</published>
    <updated>2021-12-02T07:54:42.213Z</updated>
    
    <content type="html"><![CDATA[<p>前四篇专栏已经简要的描述了常用的字节码，这篇专栏将讲述Java 7以来最重要的字节码之一：invokedynamic。</p><h2 id="方法句柄（Method-Handle）"><a href="#方法句柄（Method-Handle）" class="headerlink" title="方法句柄（Method Handle）"></a>方法句柄（Method Handle）</h2><p>方法句柄在Java 7时被引入，位于<code>java.lang.invoke</code>包下。它类似于反射，但与反射不同的是，它的检查在创建阶段就已经结束，而反射需要每次运行时检查，所以在理论上方法引用更快。</p><h3 id="方法类型（Method-Type）"><a href="#方法类型（Method-Type）" class="headerlink" title="方法类型（Method Type）"></a>方法类型（Method Type）</h3><p>方法句柄包含了一个方法的信息——所在的类、名称、参数列表与返回值。为了描述参数列表与返回值，Java引入了一个类————即<code>MethodType</code>，来描述它们。</p><p>它类似于反射使用的<code>getMethod</code>方法，但是它不仅需要参数列表，它还需要返回值。创建一个MethodType可以使用下面的方法：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodType <span class="hljs-title">methodType</span><span class="hljs-params">(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodType <span class="hljs-title">methodType</span><span class="hljs-params">(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodType <span class="hljs-title">methodType</span><span class="hljs-params">(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0, Class&lt;?&gt;... ptypes)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodType <span class="hljs-title">methodType</span><span class="hljs-params">(Class&lt;?&gt; rtype)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodType <span class="hljs-title">methodType</span><span class="hljs-params">(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodType <span class="hljs-title">methodType</span><span class="hljs-params">(Class&lt;?&gt; rtype, MethodType ptypes)</span></span></code></pre><p>这些方法中的<code>rtype</code>参数都代表了返回值类型，<code>ptypes</code>代表了参数类型。</p><p>下面是一个例子：使用MethodType描述<code>Arrays::binarySearch(Object[], int, int, Object) -&gt; int</code></p><pre><code class="hljs Java">MethodType mt = MethodType.methodType(<span class="hljs-keyword">int</span>.class, Object[].class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class, Object.class);</code></pre><h3 id="从已有的方法中提取方法句柄"><a href="#从已有的方法中提取方法句柄" class="headerlink" title="从已有的方法中提取方法句柄"></a>从已有的方法中提取方法句柄</h3><p>为了获取一个方法句柄，最简单的途径就是从一个现成的方法中提取。为了从一个现成的类中提取一个方法句柄，我们需要一个<code>MethodHandles.Lookup</code>对象，这个对象有两种获取方法：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Lookup <span class="hljs-title">lookup</span><span class="hljs-params">()</span> <span class="hljs-comment">// 可查找所有方法</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Lookup <span class="hljs-title">publicLookup</span><span class="hljs-params">()</span> <span class="hljs-comment">// 只可以查找公有方法</span></span></code></pre><p><code>Lookup</code>类提供了以下方法用于查找方法句柄对象：</p><pre><code class="hljs Java"><span class="hljs-comment">// 查找静态方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">findStatic</span><span class="hljs-params">(Class&lt;?&gt; refc, String name, MethodType type)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 查找实例方法</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">findVirtual</span><span class="hljs-params">(Class&lt;?&gt; refc, String name, MethodType type)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 查找构造函数</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">findConstructor</span><span class="hljs-params">(Class&lt;?&gt; refc, MethodType type)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 查找特殊执行的方法（需要特殊指定执行类）</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">findSpecial</span><span class="hljs-params">(Class&lt;?&gt; refc, String name, MethodType type, Class&lt;?&gt; specialCaller)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 查找获取字段的方法句柄（不是调用你定义的方法，而是系统内建一个getter的方法句柄）</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">findGetter</span><span class="hljs-params">(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 查找设置字段的方法句柄（同上，系统内建setter）</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">findSetter</span><span class="hljs-params">(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 查找获取静态字段的方法句柄（同上）</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">findStaticGetter</span><span class="hljs-params">(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 查找设置静态字段的方法句柄（同上）</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">findStaticSetter</span><span class="hljs-params">(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException</span></code></pre><p>可以看到，这些find方法都实现了某个字节码的功能：<code>findStatic</code>与<code>invokestatic</code>进行对应、<code>findGetter</code>与<code>getfield</code>对应等。</p><p>除了查找方法，从一个反射对象反反射也能获得方法句柄对象：</p><pre><code class="hljs Java"><span class="hljs-comment">// 从Method反反射到一个方法句柄上</span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">unreflect</span><span class="hljs-params">(Method m)</span> <span class="hljs-keyword">throws</span> IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 从Method反反射到一个方法句柄上，需要指定特殊执行类</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">unreflectSpecial</span><span class="hljs-params">(Method m, Class&lt;?&gt; specialCaller)</span> <span class="hljs-keyword">throws</span> IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 从Constructor反反射到方法句柄上</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">unreflectConstructor</span><span class="hljs-params">(Constructor&lt;?&gt; c)</span> <span class="hljs-keyword">throws</span> IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 从Field反反射到方法句柄上</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">unreflectGetter</span><span class="hljs-params">(Field f)</span> <span class="hljs-keyword">throws</span> IllegalAccessException</span><span class="hljs-function"><span class="hljs-comment">// 从Field反反射到方法句柄上</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">unreflectSetter</span><span class="hljs-params">(Field f)</span> <span class="hljs-keyword">throws</span> IllegalAccessException</span></code></pre><p>下面是使用例：</p><ul><li>获取<code>System::currentTimeMillis() -&gt; long</code>的方法句柄</li></ul><pre><code class="hljs Java">MethodType mt = MethodType.methodType(<span class="hljs-keyword">long</span>.class); <span class="hljs-comment">// ()J</span>MethodHandle handle = MethodHandles.lookup().findStatic(System.class, <span class="hljs-string">&quot;currentTimeMillis&quot;</span>, mt);</code></pre><ul><li>获取获得<code>System.out(java.io.PrintStream)</code>字段的方法句柄</li></ul><pre><code class="hljs Java">MethodHandle handle = MethodHandles.lookup().findStaticGetter(System.class, <span class="hljs-string">&quot;out&quot;</span>, PrintStream.class);</code></pre><ul><li>获取<code>String::&lt;init&gt;()</code>的方法句柄</li></ul><pre><code class="hljs Java">MethodType mt = MethodType.methodType(<span class="hljs-keyword">void</span>.class); <span class="hljs-comment">// ()V</span>MethodHandle handle = MethodHandles.lookup().findConstructor(String.class, mt);</code></pre><ul><li>获取访问<code>sun.misc.Unsafe.theUnsafe(Unsafe)</code>字段的方法句柄</li></ul><pre><code class="hljs Java"><span class="hljs-comment">// 因为Unsafe.theUnsafe是private，所以要用反射先获取Field解除访问限制之后再进行反反射</span>Field field = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);field.setAccessible(<span class="hljs-keyword">true</span>);MethodHandle handle = MethodHandles.lookup().unreflectGetter(field);</code></pre><h3 id="自定义方法句柄"><a href="#自定义方法句柄" class="headerlink" title="自定义方法句柄"></a>自定义方法句柄</h3><p>方法句柄不止可以通过查找获取，还可以通过<code>MethodHandles</code>内置的一些方法获取，下面是一部分内置的方法句柄生成器：</p><pre><code class="hljs Java"><span class="hljs-comment">// 创建数组的方法句柄，需要传入int作为数组长度，返回数组；参数类必须是数组类；对应ANEWARRAY</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">arrayConstructor</span><span class="hljs-params">(Class&lt;?&gt; arrayClass)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span><span class="hljs-function"><span class="hljs-comment">// 获取数组长度的方法句柄，需要一个数组传入，返回长度；参数类必须是数组类；对应ARRAYLENGTH</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">arrayLength</span><span class="hljs-params">(Class&lt;?&gt; arrayClass)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span><span class="hljs-function"><span class="hljs-comment">// 其他数组操作忽略</span></span><span class="hljs-function"><span class="hljs-comment">// 创建返回参数自身的方法句柄</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">identity</span><span class="hljs-params">(Class&lt;?&gt; type)</span></span><span class="hljs-function"><span class="hljs-comment">// 创建返回常量的方法句柄，实际实现是identity(type).bindTo(value)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">constant</span><span class="hljs-params">(Class&lt;?&gt; type, Object value)</span></span><span class="hljs-function"><span class="hljs-comment">// 创建返回null的方法句柄</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">zero</span><span class="hljs-params">(Class&lt;?&gt; type)</span></span><span class="hljs-function"><span class="hljs-comment">// 类似zero，但是可以传入参数</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">empty</span><span class="hljs-params">(MethodType type)</span></span><span class="hljs-function"><span class="hljs-comment">// 创建一个方法句柄，用于在第pos参数后插入values个参数传入target</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">insertArguments</span><span class="hljs-params">(MethodHandle target, <span class="hljs-keyword">int</span> pos, Object... values)</span></span><span class="hljs-function"><span class="hljs-comment">// 创建一个方法句柄，用于取消第pos参数后valueTypes的参数传入target</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">dropArguments</span><span class="hljs-params">(MethodHandle target, <span class="hljs-keyword">int</span> pos, List&lt;Class&lt;?&gt;&gt; valueTypes)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">dropArguments</span><span class="hljs-params">(MethodHandle target, <span class="hljs-keyword">int</span> pos, Class&lt;?&gt;... valueTypes)</span></span><span class="hljs-function"><span class="hljs-comment">// 创建取消target返回的方法句柄</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">dropReturn</span><span class="hljs-params">(MethodHandle target)</span></span><span class="hljs-function"><span class="hljs-comment">// 创建一个方法句柄，用于筛选第pos参数后传入target的方法参数</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">filterArguments</span><span class="hljs-params">(MethodHandle target, <span class="hljs-keyword">int</span> pos, MethodHandle... filters)</span></span></code></pre><p>这些生成器不止包括了基本的创建对象与对象操作，还实现了一部分流程结构，也就是说你可以通过MethodHandles“动态”地创建一个方法片段。</p><h3 id="使用方法句柄"><a href="#使用方法句柄" class="headerlink" title="使用方法句柄"></a>使用方法句柄</h3><p>说了这么多创建方法句柄的方式，我们该怎么使用它呢？MethodHandle提供了两个方法用于执行方法句柄：</p><pre><code class="hljs Java"><span class="hljs-meta">@IntrinsicCandidate</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-meta">@PolymorphicSignature</span> <span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> Throwable</span><span class="hljs-function">@IntrinsicCandidate</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> @PolymorphicSignature Object <span class="hljs-title">invokeExact</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> Throwable</span></code></pre><p>这两种调用方式的区别在于参数的类型转换：<code>invokeExact</code>要求参数必须准确对应MethodType定义的参数，而<code>invoke</code>会进行自动转换来尝试对应。</p><p>如果无法对应参数，这两个方法都会抛出<code>WrongMethodTypeException</code>。</p><p>下面给出一个例子，使用上面2.1创建的MethodHandle：</p><pre><code class="hljs Java"><span class="hljs-keyword">long</span> time = (<span class="hljs-keyword">long</span>) (handle.invokeExact());</code></pre><p>有些情况下，我们不需要第一个参数变化（实例方法的调用对象/静态方法的第一个参数），这时我们可以用<code>bindTo</code>绑定第一个参数：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> MethodHandle <span class="hljs-title">bindTo</span><span class="hljs-params">(Object x)</span></span></code></pre><p>下面是使用例：</p><pre><code class="hljs Java">MethodHandle handle = MethodHandles.lookup().findVirtual(PrintStream.class, <span class="hljs-string">&quot;println&quot;</span>, MethodType.methodType(<span class="hljs-keyword">void</span>.class, String.class)).bindTo(System.out);handle.invokeExact(<span class="hljs-string">&quot;hello&quot;</span>);</code></pre><p>说完了方法句柄，接下来来看看<code>CallSite</code>。</p><h2 id="动态调用点（CallSite）"><a href="#动态调用点（CallSite）" class="headerlink" title="动态调用点（CallSite）"></a>动态调用点（CallSite）</h2><p>CallSite是一个为了引导<code>invokedynamic</code>字节码指向调用方法的类，通过它的<code>dynamicInvoker</code>方法可以获取一个方法句柄，这个句柄就代表了inDy的<strong>目标</strong>。</p><p>非常量动态调用点允许重新指定调用目标，这时inDy会对目标进行重新连接。</p><p>它有三个子类：ConstantCallSite、MutableCallSite和VolatileCallSite。它们的区别如下：</p><ul><li><p><strong>ConstantCallSite</strong>指向的方法句柄不能修改，也就是永久性的。连接到它的inDy指令会永远绑定这个方法句柄。</p></li><li><p><strong>MutableCallSite</strong>允许修改指向的方法句柄目标，指向目标的行为类似普通字段。它的目标改变是不同步的——当调用目标被另一个线程修改，现在的线程不一定能同步到更新的值。为了强制同步，可以使用MutableCallSite::syncAll。连接到它的inDy指令每次调用都会调用它当前的方法句柄目标。</p></li><li><p><strong>VolatileCallSite</strong>类似MutableCallSite，其指向的目标可以修改。它的行为类似volatile字段，另一个线程修改指向目标会立刻反应到现在的线程，因此不需要syncAll之类的方法保持同步。volatile会造成不可避免的性能损失，所以如果不涉及线程问题最好用MutableCallSite。</p></li></ul><p>下面演示了常量动态调用点的使用方法（此处不涉及inDy）：</p><pre><code class="hljs Java">MethodType type = MethodType.methodType(String.class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class);MethodHandle handle = MethodHandles.lookup().findVirtual(String.class, <span class="hljs-string">&quot;substring&quot;</span>, type);ConstantCallSite callSite = <span class="hljs-keyword">new</span> ConstantCallSite(handle); <span class="hljs-comment">// 创建常量调用点</span>MethodHandle invoker = callSite.dynamicInvoker(); <span class="hljs-comment">// 获取动态的方法句柄</span><span class="hljs-keyword">assert</span> handle == invoker; <span class="hljs-comment">// 这两个是一个对象</span>String str = (String) (invoker.invokeExact(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>));</code></pre><h2 id="引导方法（BootStrap-Method，简称BSM）"><a href="#引导方法（BootStrap-Method，简称BSM）" class="headerlink" title="引导方法（BootStrap Method，简称BSM）"></a>引导方法（BootStrap Method，简称BSM）</h2><p>在Java类执行中，少不了<em>动态</em>的东西。这些动态的东西分为两类：一种是动态计算调用点，一种是动态计算常量。引导方法就是为了它们产生的。</p><ol><li><p>动态计算常量，由<strong>ConstantDynamic</strong>表示。它们在JVM使用它们之前被解析，解析时调用的就是它内部的引导方法和它们内置的引导方法参数。</p></li><li><p>动态计算调用点，也就是inDy的实现。inDy的目标在第一次调用它之前解析调用获得CallSite。</p></li></ol><p>引导方法的声明有一定规则，和它们的使用方式有关：</p><ul><li><p>如果引导方法用于动态计算常量，则引导方法的前三个参数分别是<code>MethodHandles.Lookup、String、Class</code>对象，分别代表了调用方、名称和常量类型，后面的参数是其他静态参数，返回值需要与Class对象代表的类型保持一致（或者写为Object，只需要运行时返回值可以被强制转换到指定类型就可以）。</p></li><li><p>如果引导方法用于动态计算调用点，则引导方法的前三个参数分别是<code>MethodHandles.Lookup、String、MethodType</code>对象，分别代表调用方、名称和调用点方法类型，后面的参数是其他静态参数，它的返回值要求是<code>CallSite</code>（通常是ConstantCallSite，当然写成Object也可以，只要保证能被强制类型转换成CallSite就不报错）</p></li></ul><p>下面是一些正确的用于动态计算调用点的引导方法声明：</p><pre><code class="hljs Java"><span class="hljs-function">CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(Lookup caller, String name, MethodType type, Object... args)</span></span><span class="hljs-function">CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(Lookup caller, String name, MethodType type)</span> <span class="hljs-comment">// 没有其他静态参数</span></span><span class="hljs-function">CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(Lookup caller, Object... nameAndType)</span></span><span class="hljs-function">CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(Lookup caller, String name, MethodType type, Object arg)</span> <span class="hljs-comment">// 只有一个静态参数</span></span><span class="hljs-function">CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(Lookup caller, String name, MethodType type, Object... args)</span></span><span class="hljs-function">CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(Lookup caller, String name, MethodType type, String... args)</span> <span class="hljs-comment">// 只允许String静态参数</span></span><span class="hljs-function">CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(Lookup caller, String name, MethodType type, String x, <span class="hljs-keyword">int</span> y)</span> <span class="hljs-comment">// 只允许一个String和一个int作为静态参数传入</span></span><span class="hljs-function">CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(Object... args)</span></span><span class="hljs-function">CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(Object caller, Object... nameAndTypeWithArgs)</span></span></code></pre><blockquote><p>注意：静态参数允许了动态计算常量传入。</p></blockquote><h2 id="invokedynamic字节码"><a href="#invokedynamic字节码" class="headerlink" title="invokedynamic字节码"></a>invokedynamic字节码</h2><p>经过前面一系列的铺垫，终于我们要讲inDy该怎么写入了。</p><p>写入inDy字节码需要使用MethodVisitor的方法，<code>visitInvokeDynamicInsn</code>：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitInvokeDynamicInsn</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String name,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String descriptor,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> Handle bootstrapMethodHandle,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> Object... bootstrapMethodArguments)</span></span></code></pre><p>它的四个参数分别是名称、方法描述符、引导函数的句柄和传入引导方法的静态参数。名称和描述符都分别对应了引导方法的参数：<strong>name</strong>（第二个参数）、<strong>type</strong>（第三个参数）。</p><p>这里面的<code>Handle</code>句柄不等于MethodHandle方法句柄，但是它们也是紧密相关的，它的定义如下：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handle</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tag,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String owner,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String name,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String descriptor,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isInterface)</span></span></code></pre><p>可以看到这里的参数和<code>visitMethodInsn</code>的参数基本一样。第一个参数是调用标签，分为9个，它们与方法句柄差不多：</p><ul><li><p>H_GETFIELD，对应findGetter，字节码getfield，要求isInterface是false</p></li><li><p>H_GETSTATIC，对应findStaticGetter，字节码getstatic，要求isInterface是false</p></li><li><p>H_PUTFIELD，对应findSetter，字节码putfield，要求isInterface是false</p></li><li><p>H_PUTSTATIC，对应findStaticSetter，字节码putstatic，要求isInterface是false</p></li><li><p>H_INVOKEVIRTUAL，对应findVirtual，字节码invokevirtual</p></li><li><p>H_INVOKESTATIC，对应findStatic，字节码invokestatic</p></li><li><p>H_INVOKESPECIAL，对应findSpecial，字节码invokespecial</p></li><li><p>H_NEWINVOKESPECIAL，对应findConstuctor，字节码invokespecial</p></li><li><p>H_INVOKEINTERFACE，对应findVirtual，字节码invokeinterface，isInterface是true</p></li></ul><p>下面是个例子，将<code>Arrays::binarySearch(Object[], int, int, Object) -&gt; int</code>用Handle表述：</p><pre><code class="hljs Java"><span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/util/Arrays&quot;</span>, <span class="hljs-string">&quot;binarySearch&quot;</span>, <span class="hljs-string">&quot;([Ljava/lang/Object;IILjava/lang/Object;)I&quot;</span>, <span class="hljs-keyword">false</span>);</code></pre><p>那么inDy对操作栈做了什么？这就和它的第二个参数，<code>descriptor</code>有关系了。</p><p>之前说过，BSM会传入一个MethodType，而这个MethodType是用于描述返回动态调用点目标句柄的。又由于descriptor在字节码中最终会解释成为MethodType，所以能得出一个结论：descriptor决定了BSM返回CallSite内部方法句柄的类型。</p><p>而inDy在JVM的操作正是通过CallSite获取dynamicInvoker进行调用——也就是说，inDy相当于间接调用了一个类型为descriptor的方法。这样我们就不难理解inDy对操作栈干了什么：<strong>弹出descriptor指定的一部分参数并压回规定的返回值。</strong></p><blockquote><p>JVM调用BSM的逻辑可以在<code>java.lang.invoke.BootstrapMethodInvoker</code>找到。</p></blockquote><p>使用inDy字节码还需要一步操作：你需要让你的类访问<code>MethodHandles.Lookup</code>，因此你需要在类声明时加入一个<code>visitInnerClassInsn</code>（其实不加也不会报错，但是最好加上）：</p><pre><code class="hljs Java">cw.visitInnerClass(<span class="hljs-string">&quot;java/lang/invoke/MethodHandles$Lookup&quot;</span>, <span class="hljs-string">&quot;java/lang/invoke/MethodHandles&quot;</span>, <span class="hljs-string">&quot;Lookup&quot;</span>, ACC_PUBLIC | ACC_FINAL | ACC_STATIC);</code></pre><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>匿名函数表达式，简称lambda表达式，它在Java 8被加入。它简化了一部分的匿名类，让代码更加简洁。</p><p>为了展示它的用法和字节码表示，我们先定义一个接口和一个方法：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(StringSupplier lambda)</span> </span>&#123;System.out.println(lambda.getString());&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StringSupplier</span> </span>&#123;<span class="hljs-function">String <span class="hljs-title">getString</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>接着，我们使用这个方法：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;test(() -&gt; <span class="hljs-string">&quot;hello&quot;</span>);&#125;</code></pre><p>这时，后面的<code>() -&gt; &quot;hello&quot;</code>被解析成了一个<code>StringSupplier</code>的实现类对象。但是，在字节码中无法自动去生成一个这样的类用于适配它。于是，javac在此处写入了inDy字节码要求动态生成。</p><p>动态生成lambda调用点的引导方法位于<code>java.lang.invoke.LambdaMetafactory</code>：</p><pre><code class="hljs Java"><span class="hljs-comment">// 使用了优化协议的标准版本</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title">metafactory</span><span class="hljs-params">(MethodHandles.Lookup caller,</span></span><span class="hljs-params"><span class="hljs-function">                                   String interfaceMethodName,</span></span><span class="hljs-params"><span class="hljs-function">                                   MethodType factoryType,</span></span><span class="hljs-params"><span class="hljs-function">                                   MethodType interfaceMethodType,</span></span><span class="hljs-params"><span class="hljs-function">                                   MethodHandle implementation,</span></span><span class="hljs-params"><span class="hljs-function">                                   MethodType dynamicMethodType)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> LambdaConversionException</span><span class="hljs-function"><span class="hljs-comment">// 备用版本</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title">altMetafactory</span><span class="hljs-params">(MethodHandles.Lookup caller,</span></span><span class="hljs-params"><span class="hljs-function">                                   String interfaceMethodName,</span></span><span class="hljs-params"><span class="hljs-function">                                   MethodType factoryType,</span></span><span class="hljs-params"><span class="hljs-function">                                   Object... args)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> LambdaConversionException</span></code></pre><p>通常情况下，javac生成的lambda都是通过第一个BSM的，这6个参数的意义分别是：</p><ul><li><p><strong>caller</strong>，由JVM提供的查找对象，lambda会使用这个进行动态类创建</p></li><li><p><strong>interfaceMethodName</strong>，lambda实现接口内部需要实现的方法名称</p></li><li><p><strong>factoryType</strong>，要求BSM返回CallSite内部指向方法句柄的方法类型</p></li><li><p><strong>interfaceMethodType</strong>，lambda实现接口内需要实现方法的类型</p></li><li><p><strong>implementation</strong>，实现lambda内部代码功能的方法句柄</p></li><li><p><strong>dynamicMethodType</strong>，实现lambda内部代码功能方法的类型，和interfaceMethodType相同或者是它的更具体的类型</p></li></ul><p>可以看到，为了提供lambda的功能，javac会让inDy字节码连接到另一个方法上去。这种方法不需要我们自己写，它是编译时自动生成的，名称是<code>lambda$方法名$序号</code>。上例中，javac动态生成的lambda方法如下：</p><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-comment">/* synthetic */</span> String lambda$main$<span class="hljs-number">0</span>() &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;&#125;</code></pre><p>这些方法都带有<code>private</code>和<code>synthetic</code>的访问标志，是否拥有<code>static</code>访问标志取决于lambda在的方法是否静态和是否使用this对象。</p><p>接下来，我们使用这个方法连接到LambdaMetafactory：</p><pre><code class="hljs Java"><span class="hljs-comment">// 注意：这只是个演示！真正的字节码不是这样，这只是一种方式用于理解调用流程！</span>test(LambdaMetafactory.metafactory(lookup, <span class="hljs-comment">// JVM提供</span><span class="hljs-string">&quot;getString&quot;</span>, <span class="hljs-comment">// lambda实现方法的名称</span>MethodType.methodType(StringSuppiler.class), <span class="hljs-comment">// 返回CallSite中的方法类型</span>MethodType.methodType(String.class), <span class="hljs-comment">// 需要提供接口方法的类型，描述符()Ljava/lang/String;</span>MethodHandles.lookup().findStatic(Test.class, <span class="hljs-string">&quot;lambda$main$0&quot;</span>, MethodType.methodType(String.class)), <span class="hljs-comment">// lambda的实现</span>MethodType.methodType(String.class)) <span class="hljs-comment">// 指向方法目标的类型，描述符()Ljava/lang/String;</span>.dynamicInvoker().invokeExact());</code></pre><p><code>metafactory</code>通过这些参数可以动态创建一个类实现指定的接口获得实现接口的对象。具体而言，它通过asm库（java内置了asm库）在现在的类中动态的生成了内部类，类的名称是<code>$Lambda$序号</code>（但是在<code>getClass()</code>获取时名称不是这个，因为这个类被“隐藏”定义，会带上另一个编号）。对于这个例子，生成的内部类像下面这样：</p><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-comment">/* synthetic */</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Lambda</span>$14 <span class="hljs-keyword">implements</span> <span class="hljs-title">StringSupplier</span> </span>&#123; <span class="hljs-comment">// 序号不重要</span><span class="hljs-keyword">private</span> $Lambda$<span class="hljs-number">14</span>() &#123;<span class="hljs-keyword">super</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 实现</span><span class="hljs-keyword">return</span> Test.lambda$main$<span class="hljs-number">0</span>(); <span class="hljs-comment">// 注意这里使用的不是方法句柄</span>&#125;&#125;</code></pre><p>对于这种lambda表达式，生成的类对象永远不变，所以JVM对此进行优化——这种lambda只会生成一个实例，返回的CallSite其实只是返回一个常量（详情可见<code>InnerClassLambdaMetafactory</code>）。</p><p>说回到字节码的写入。之前说过visitInvokeDynamicInsn和BSM的参数一一对应，所以我们可以这样写入：</p><pre><code class="hljs Java">mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;getString&quot;</span>, <span class="hljs-comment">// 实现的方法名称</span>                          <span class="hljs-string">&quot;()LStringSupplier;&quot;</span>, <span class="hljs-comment">// 要求返回CallSite的类型</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/LambdaMetafactory&quot;</span>, <span class="hljs-string">&quot;metafactory&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM的句柄</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>), <span class="hljs-comment">// 接口方法的类型</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;lambda$main$0&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// lambda的实现代码</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>) <span class="hljs-comment">// lambda实现方法的类型</span>);mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(LStringSupplier;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 调用test</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 最大操作栈[StringSupplier]，局部变量表[[Ljava/lang/String;]</span></code></pre><p>除了这种lambda外，还有另一种lambda：它们需要局部变量传入内部。这些局部变量有要求——它们无法被修改，或者叫“等效终态”。下面是一个例子：</p><pre><code class="hljs Java"><span class="hljs-comment">// main方法</span><span class="hljs-comment">/* final */</span> String hello = <span class="hljs-string">&quot;hello&quot;</span>;test(() -&gt; hello);</code></pre><p>由于传入了局部变量，lambda的实现方法就需要多加一个参数用于传递这个变量。下面是javac生成的lambda代理实现方法：</p><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-comment">/* synthetic */</span> String lambda$main$<span class="hljs-number">0</span>(String str) &#123;<span class="hljs-keyword">return</span> str;&#125;</code></pre><p>但是这个str要怎么透过inDy字节码进行传入？JVM为了解决这个问题，在动态生成的委托类上做了一些操作：让传入的变量先用构造函数存储在字段里，在调用时取出字段值：</p><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-comment">/* synthetic */</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Lambda</span>$14 <span class="hljs-keyword">implements</span> <span class="hljs-title">StringSupplier</span> </span>&#123; <span class="hljs-comment">// 序号不重要</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String arg$<span class="hljs-number">0</span>; <span class="hljs-comment">// 用于储存传入的局部变量，名称以序号命名</span><span class="hljs-keyword">private</span> $Lambda$<span class="hljs-number">14</span>(String str) &#123;<span class="hljs-keyword">super</span>();arg$<span class="hljs-number">0</span> = str;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 实现</span><span class="hljs-keyword">return</span> Test.lambda$main$<span class="hljs-number">0</span>(arg$<span class="hljs-number">0</span>);&#125;&#125;</code></pre><p>但是，这种lambda的CallSite不能返回一个常量——因为我们不能保证局部变量是同一个值！因此，这个CallSite内部指向了动态生成内部类的构造函数。</p><p>接下来，我们用字节码写入一下：</p><pre><code class="hljs Java">mv.visitLdcInsn(<span class="hljs-string">&quot;hello&quot;</span>);mv.visitVarInsn(ASTORE, <span class="hljs-number">1</span>); <span class="hljs-comment">// 保存变量到1号位</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// 加载1号位</span>mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;getString&quot;</span>, <span class="hljs-comment">// 实现的方法名称</span>                          <span class="hljs-string">&quot;(Ljava/lang/String;)LStringSupplier;&quot;</span>, <span class="hljs-comment">// 要求返回CallSite的类型，注意这里要求传入String局部变量</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/LambdaMetafactory&quot;</span>, <span class="hljs-string">&quot;metafactory&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM的句柄</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>), <span class="hljs-comment">// 接口方法的类型</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;lambda$main$0&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// lambda的实现代码</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>) <span class="hljs-comment">// lambda实现方法的类型（生成内部类实现方法的类型）</span>);mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(LStringSupplier;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 调用test</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 最大操作栈[StringSupplier]，局部变量表[[Ljava/lang/String;Ljava/lang/String;]</span></code></pre><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>当lambda内只有一行方法调用时，在特定条件下可以简写为方法引用。它分为不同的类型：</p><h3 id="静态调用"><a href="#静态调用" class="headerlink" title="静态调用"></a>静态调用</h3><p>当方法引用指向一个类中的静态方法时，就是静态调用，类似于：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;&#125;<span class="hljs-comment">// ...</span>test(Test::hello);</code></pre><p>它的实现类似于lambda，但是不同的是，javac编译时不会生成一个新的方法用于lambda定位，而是选择直接指向这个方法：</p><pre><code class="hljs Java">mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;getString&quot;</span>, <span class="hljs-comment">// 实现的方法名称</span>                          <span class="hljs-string">&quot;()LStringSupplier;&quot;</span>, <span class="hljs-comment">// 要求返回CallSite的类型</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/LambdaMetafactory&quot;</span>, <span class="hljs-string">&quot;metafactory&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM的句柄</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>), <span class="hljs-comment">// 接口方法的类型</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// 方法引用的目标</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>) <span class="hljs-comment">// lambda实现方法的类型（生成内部类实现方法的类型）</span>);mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(LStringSupplier;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 调用test</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 最大操作栈[StringSupplier]，局部变量表[[Ljava/lang/String;]</span></code></pre><h3 id="对象调用"><a href="#对象调用" class="headerlink" title="对象调用"></a>对象调用</h3><p>当方法引用的目标不是静态的，它就需要使用一个对象用于方法的调用，下面是个例子：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;&#125;<span class="hljs-comment">// ...</span>test(<span class="hljs-keyword">new</span> Test()::hello);</code></pre><p>这类似于将局部变量传入了lambda内部，因此这里的inDy字节码是这样写的：</p><pre><code class="hljs Java">mv.visitTypeInsn(NEW, <span class="hljs-string">&quot;Test&quot;</span>); <span class="hljs-comment">// 创建Test类对象</span>mv.visitInsn(DUP); <span class="hljs-comment">// 复制一份</span>mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 构造函数调用</span>mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;getString&quot;</span>, <span class="hljs-comment">// 实现的方法名称</span>                          <span class="hljs-string">&quot;(LTest;)LStringSupplier;&quot;</span>, <span class="hljs-comment">// 要求返回CallSite的类型，注意这里要求传入Test局部变量</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/LambdaMetafactory&quot;</span>, <span class="hljs-string">&quot;metafactory&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM的句柄</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>), <span class="hljs-comment">// 接口方法的类型</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKEVIRTUAL, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// 方法引用的目标</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>) <span class="hljs-comment">// lambda实现方法的类型（生成内部类实现方法的类型）</span>);mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(LStringSupplier;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 调用test</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 最大操作栈[Test,Test]，局部变量表[[Ljava/lang/String;]</span></code></pre><p>对象调用的对象没有特殊要求，只需要能获得这个局部变量就可以。方法引用的目标可以是实例方法，也可以是抽象方法（区别在于Handle的标签）。</p><p>由于JVM不能保证传入的局部变量是非空的（例外就是上面的情况：直接新建对象），所以在传入lambda之前，JVM会进行<code>requireNonNull</code>进行检查。也就是说，下面这两种方式等价：</p><pre><code class="hljs Java">Test obj;<span class="hljs-comment">// ...</span><span class="hljs-comment">// 1</span>test(obj::hello);<span class="hljs-comment">// 2</span>Objects.requireNonNull(obj);test(() -&gt; obj.hello());</code></pre><p>上面的方法引用版本的代码可以写为：</p><pre><code class="hljs Java">mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// 假设位于1号位</span>mv.visitInsn(DUP); <span class="hljs-comment">// 复制一份，使用时可以不进行复制</span>mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/util/Objects&quot;</span>, <span class="hljs-string">&quot;requireNonNull&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitInsn(POP); <span class="hljs-comment">// 弹出栈顶</span>mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;getString&quot;</span>, <span class="hljs-comment">// 实现的方法名称</span>                          <span class="hljs-string">&quot;(LTest;)LStringSupplier;&quot;</span>, <span class="hljs-comment">// 要求返回CallSite的类型，注意这里要求传入Test局部变量</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/LambdaMetafactory&quot;</span>, <span class="hljs-string">&quot;metafactory&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM的句柄</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>), <span class="hljs-comment">// 接口方法的类型</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKEVIRTUAL, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// 方法引用的目标</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>) <span class="hljs-comment">// lambda实现方法的类型（生成内部类实现方法的类型）</span>);mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(LStringSupplier;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 调用test</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 最大操作栈[Test,Test]，局部变量表[[Ljava/lang/String;]</span></code></pre><p>除了这两种方式外，我们还能使用超类的实例方法，现在假设Test继承于<code>SuperTest</code>，有一个superTest方法，<strong>这时javac不会直接引用超类方法，而是生成lambda实现方法在内部调用<code>invokespecial</code></strong>。下面是使用例：</p><pre><code class="hljs Java">test(<span class="hljs-keyword">super</span>::superTest);</code></pre><p>javac生成的lambda实现方法是这样的：</p><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-comment">/* synthetic */</span> String lambda$main$<span class="hljs-number">0</span>() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.superTest();&#125;</code></pre><p>接下来的代码省略（因为和上面一样）。</p><p>最后，还有一种对象调用：lambda内部传入了一个对象，我们可以通过这个对象进行调用。这个调用方式和静态调用差不多，只不过Handle的标签是<code>H_INVOKEVIRTUAL</code>，这个也不举例了。</p><h3 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h3><p>方法引用允许传递构造函数，下面使用了String的无参构造函数传入test内部：</p><pre><code class="hljs Java">test(String::<span class="hljs-keyword">new</span>);</code></pre><p>这时，传入的方法句柄是构造函数，对应了Handle中的<code>H_NEWINVOKESPECIAL</code>：</p><pre><code class="hljs Java">mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;getString&quot;</span>, <span class="hljs-comment">// 实现的方法名称</span>                          <span class="hljs-string">&quot;()LStringSupplier;&quot;</span>, <span class="hljs-comment">// 要求返回CallSite的类型</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/LambdaMetafactory&quot;</span>, <span class="hljs-string">&quot;metafactory&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM的句柄</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>), <span class="hljs-comment">// 接口方法的类型</span>                          <span class="hljs-keyword">new</span> Handle(H_NEWINVOKESPECIAL, <span class="hljs-string">&quot;String&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// 方法引用的目标</span>                          Type.getType(<span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>) <span class="hljs-comment">// lambda实现方法的类型（生成内部类实现方法的类型）</span>);mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;(LStringSupplier;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 调用test</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 最大操作栈[LStringSupplier;]，局部变量表[[Ljava/lang/String;]</span></code></pre><h3 id="数组构造调用"><a href="#数组构造调用" class="headerlink" title="数组构造调用"></a>数组构造调用</h3><p>除了普通的构造函数，数组也可以通过方法引用创建。它只需要一个int作为参数，因此它实现的方法必须只有一个int形参：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(ArrayIntSupplier lambda)</span> </span>&#123;<span class="hljs-comment">// ...</span>&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArrayIntSupplier</span> </span>&#123;Object[] getString(<span class="hljs-keyword">int</span> count);&#125;<span class="hljs-comment">// ...</span>test(Object[]::<span class="hljs-keyword">new</span>);</code></pre><p>这种方法引用也不是直接指向构造函数的，还是javac生成lambda实现方法并引用的：</p><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-comment">/* synthetic */</span> Object[] lambda$main$<span class="hljs-number">0</span>(<span class="hljs-keyword">int</span> cnt) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Object[cnt];&#125;</code></pre><p>到此，所有方法引用的写入方式就都介绍完了。</p><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>在学习Java的时候，我们就知道Java的String允许用<code>+</code>进行连接。但是，Java没有符号重载，那么字符串是怎么打破这个限制的呢？答案就是javac编译时做了一些“操作”。</p><p>接下来，我们使用这个例子：</p><pre><code class="hljs Java"><span class="hljs-string">&quot;hello world at &quot;</span> + System.currentTimeMillis()</code></pre><p>在Java 8，字符串的连接被自动识别为<code>StringBuilder</code>的链式调用，那么上面的这句话在javac编译之后就变成了这样：</p><pre><code class="hljs Java"><span class="hljs-keyword">new</span> StringBuilder().append(<span class="hljs-string">&quot;hello world at &quot;</span>).append(System.currentTimeMillis()).toString()</code></pre><p>字节码写入如下：</p><pre><code class="hljs Java">mv.visitTypeInsn(NEW, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>);mv.visitInsn(DUP);mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 构造函数</span>mv.visitLdcInsn(<span class="hljs-string">&quot;hello world at &quot;</span>); <span class="hljs-comment">// 字符串常量</span>mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;append&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// append</span>mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;currentTimeMillis&quot;</span>, <span class="hljs-string">&quot;()J&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;append&quot;</span>, <span class="hljs-string">&quot;(J)Ljava/lang/StringBuilder;&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/StringBuilder&quot;</span>, <span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-keyword">false</span>);</code></pre><p>但是这种方式有两个缺点：一是会生成大量的字节码片段，使类文件膨胀；二是这种调用每次都会生成StringBuilder对象，性能会损失一部分。</p><p>所以，从Java 9开始，字符串连接使用inDy字节码动态调用。它使用的引导方法位于<code>StringConcatFactory</code>。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title">makeConcat</span><span class="hljs-params">(MethodHandles.Lookup lookup,</span></span><span class="hljs-params"><span class="hljs-function">                                  String name,</span></span><span class="hljs-params"><span class="hljs-function">                                  MethodType concatType)</span> <span class="hljs-keyword">throws</span> StringConcatException</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title">makeConcatWithConstants</span><span class="hljs-params">(MethodHandles.Lookup lookup,</span></span><span class="hljs-params"><span class="hljs-function">                                               String name,</span></span><span class="hljs-params"><span class="hljs-function">                                               MethodType concatType,</span></span><span class="hljs-params"><span class="hljs-function">                                               String recipe,</span></span><span class="hljs-params"><span class="hljs-function">                                               Object... constants)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> StringConcatException</span></code></pre><p><code>makeConcat</code>是<code>makeConcatWithConstants</code>的简化版本，如果没有常量，就用第一个方法，但是javac编译时通常使用第二个方法，所以我们对它进行讲解。</p><p>首先说说方法参数的意义：</p><ul><li><p><strong>lookup</strong>，由JVM提供的查找对象</p></li><li><p><strong>name</strong>，名称，和最后的连接效果没有任何关系，只要不是null都能传入。程序写入常用<code>makeConcatWithConstants</code></p></li><li><p><strong>concatType</strong>，生成CallSite的签名，返回值需要是String，参数列表要和字符串中的变量的数量、类型和位置保持一致</p></li><li><p><strong>recipe</strong>，用于连接字符串的模板，只有两种字符：<code>\u0001</code>代表了这里应该写入变量，<code>\u0002</code>代表这里应该写入常量。\u0001的数量、位置需要和变量保持一致；\u0002的数量、位置要与常量保持一致</p></li><li><p><strong>constants</strong>，字符串中的常量部分，数量和\u0002一致，可以不是String。</p></li></ul><p>它的原理比lambda要简单——它是动态生成了一个MethodHandle存储到CallSite中，因此在执行一次BSM之后它就成为了常量。</p><p>现在我们用它写入字节码：</p><pre><code class="hljs Java">mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;currentTimeMillis&quot;</span>, <span class="hljs-string">&quot;()J&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 先获得字符串中的变量</span>mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;makeConcatWithConstants&quot;</span>, <span class="hljs-comment">// name随意，只要求不是null</span>                          <span class="hljs-string">&quot;(J)Ljava/lang/String;&quot;</span>, <span class="hljs-comment">// 变量只有一个long，要求返回String</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/StringConcatFactory&quot;</span>, <span class="hljs-string">&quot;makeConcatWithConstants&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM句柄，注意不定长参数需要写成数组</span>                          <span class="hljs-string">&quot;hello world at \u0001&quot;</span> <span class="hljs-comment">// 模板</span>);</code></pre><p>但是你可能有一个疑问：如果我字符串里面本身有\u0001或者\u0002不就出错了吗？JVM考虑了这个情况，它的解决方案是——提取这一段字符串为常量放到后面。例如下面这个字符串：</p><pre><code class="hljs Java"><span class="hljs-string">&quot;\u0001 hello&quot;</span> + System.currentTimeMillis()</code></pre><p>它的写入是：</p><pre><code class="hljs Java">mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;currentTimeMillis&quot;</span>, <span class="hljs-string">&quot;()J&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 先获得字符串中的变量</span>mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;makeConcatWithConstants&quot;</span>, <span class="hljs-comment">// name随意，只要求不是null</span>                          <span class="hljs-string">&quot;(J)Ljava/lang/String;&quot;</span>, <span class="hljs-comment">// 变量只有一个long，要求返回String</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/StringConcatFactory&quot;</span>, <span class="hljs-string">&quot;makeConcatWithConstants&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM句柄，注意不定长参数需要写成数组</span>                          <span class="hljs-string">&quot;\u0002\u0001&quot;</span>, <span class="hljs-comment">// 模板，常量+变量</span>                          <span class="hljs-string">&quot;\u0001 hello&quot;</span> <span class="hljs-comment">// 常量的值</span>);</code></pre><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>在Java 17，模式匹配进行了预览。下面就是它的使用例：</p><pre><code class="hljs Java">Object o ...<span class="hljs-keyword">switch</span> (o) &#123;<span class="hljs-keyword">case</span> String s:System.out.println(s.substring(<span class="hljs-number">1</span>));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> Number n:System.out.println(n.longValue());<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:System.out.println(<span class="hljs-string">&quot;Others&quot;</span>);&#125;</code></pre><p>模式匹配之间必须使用<code>break</code>，否则会被提示为非法。</p><p>使用增强型switch可以写成下面形式：</p><pre><code class="hljs Java">Object o ...<span class="hljs-keyword">switch</span> (o) &#123;<span class="hljs-keyword">case</span> String s -&gt; System.out.println(s.substring(<span class="hljs-number">1</span>));<span class="hljs-keyword">case</span> Number n -&gt; System.out.println(n.longValue());<span class="hljs-keyword">default</span> -&gt; System.out.println(<span class="hljs-string">&quot;Others&quot;</span>);&#125;</code></pre><p>它的写入和其他switch不同，它使用了inDy用于获得序号，再用这个序号进行<code>lookupswitch</code>。</p><p>它使用的引导方法位于<code>java.lang.runtime.SwitchBootstraps</code>：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title">typeSwitch</span><span class="hljs-params">(MethodHandles.Lookup lookup,</span></span><span class="hljs-params"><span class="hljs-function">                                  String invocationName,</span></span><span class="hljs-params"><span class="hljs-function">                                  MethodType invocationType,</span></span><span class="hljs-params"><span class="hljs-function">                                  Object... labels)</span></span></code></pre><p>它的参数意义如下：</p><ul><li><p><strong>lookup</strong>，由JVM提供的查找对象</p></li><li><p><strong>invocationName</strong>，名称，和最后的效果没有任何关系，只要不是null都能传入。程序写入常用<code>typeSwitch</code></p></li><li><p><strong>invocationType</strong>，要求第一个参数非基本类型、第二个参数是int、返回值是int的方法类型，也就是说它强制要求传入一个对象和一个int。对象用于检查模式，int用于确定lookupswitch的起始位置（通常是0）。返回值是从第二个参数开始的连续数列中的一个值。</p></li><li><p><strong>labels</strong>，模式匹配目标。可以是Class、Integer或String对象，但是实际上编译时只使用了Class对象。它规定了返回的CallSite的内容：如果输入的对象是这个Class的对象，返回对应的位置。如果输入的对象是null，返回-1。如果输入的对象不存在匹配项，返回labels数组的长度。</p></li></ul><p>通过这个引导方法，上面的代码可以变为：</p><pre><code class="hljs Java">Object o ...Objects.requireNonNull(o); <span class="hljs-comment">// 先检查对象是否为null</span>Object tmp = o; <span class="hljs-comment">// 复制一份，javac是这么做的</span><span class="hljs-keyword">int</span> startIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 传入的起始lookup偏移</span><span class="hljs-comment">// --- 这里有一次栈帧信息写入 --- labelStart</span><span class="hljs-comment">// 这里加载了tmp和startIndex</span><span class="hljs-keyword">switch</span>(#invokedynamic) &#123; <span class="hljs-comment">// inDy的调用部分省略</span><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">/* labelString */</span>String s = (String) o;System.out.println(s.substring(<span class="hljs-number">1</span>));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">/* labelNumber */</span>Number n = (Number) n;System.out.println(n.longValue());<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-comment">/* labelDefault */</span>System.out.println(<span class="hljs-string">&quot;Others&quot;</span>);&#125;<span class="hljs-comment">/* labelEnd */</span></code></pre><p>使用字节码写入：</p><pre><code class="hljs Java">mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// o</span>mv.visitInsn(DUP); <span class="hljs-comment">// 复制一份，同样，不复制也行，这是javac的迷惑操作</span>mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/util/Objects&quot;</span>, <span class="hljs-string">&quot;requireNonNull&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 检查null</span>mv.visitInsn(POP); <span class="hljs-comment">// 弹出栈顶</span>mv.visitVarInsn(ASTORE, <span class="hljs-number">1</span>); <span class="hljs-comment">// 转存到临时变量tmp</span>mv.visitInsn(ICONST_0); <span class="hljs-comment">// 常量0</span>mv.visitVarInsn(ISTORE, <span class="hljs-number">2</span>); <span class="hljs-comment">// 给局部变量startIndex赋值</span>Label labelStart = <span class="hljs-keyword">new</span> Label(); <span class="hljs-comment">// 用于标记switch块的开始（这样tmp和startIndex不能在结束时访问）</span>mv.visitLabel(labelStart);mv.visitFrame(F_APPEND, <span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Object[]&#123; <span class="hljs-string">&quot;java/lang/Object&quot;</span>, INTEGER &#125;, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 写入栈帧信息</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// 加载对象</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">2</span>); <span class="hljs-comment">// 加载偏移</span>mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;typeSwitch&quot;</span>, <span class="hljs-comment">// 无关紧要的名字，只要不是null就行</span>                          <span class="hljs-string">&quot;(Ljava/lang/Object;I)I&quot;</span>, <span class="hljs-comment">// CallSite的方法签名</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/runtime/SwitchBootstraps&quot;</span>, <span class="hljs-string">&quot;typeSwitch&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM句柄</span>                          Type.getType(<span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>), <span class="hljs-comment">// 第一个模式</span>                          Type.getType(<span class="hljs-string">&quot;Ljava/lang/Number;&quot;</span>) <span class="hljs-comment">// 第二个模式</span>);Label labelString = <span class="hljs-keyword">new</span> Label(), labelNumber = <span class="hljs-keyword">new</span> Label(), labelDefault = <span class="hljs-keyword">new</span> Label();mv.visitLookupSwitchInsn(labelDefault, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;, <span class="hljs-keyword">new</span> Label[]&#123; labelString, labelNumber &#125;); <span class="hljs-comment">// 返回值用于lookupSwitch</span>mv.visitLabel(labelString);mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// tmp</span>mv.visitTypeInsn(CHECKCAST, <span class="hljs-string">&quot;java/lang/String&quot;</span>); <span class="hljs-comment">// 强制类型转换</span>mv.visitVarInsn(ASTORE, <span class="hljs-number">3</span>); <span class="hljs-comment">// 存储到s</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">3</span>);mv.visitInsn(ICONST_1);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/String&quot;</span>, <span class="hljs-string">&quot;substring&quot;</span>, <span class="hljs-string">&quot;(I)Ljava/lang/String;&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);Label labelEnd = <span class="hljs-keyword">new</span> Label();mv.visitJumpInsn(GOTO, labelEnd); <span class="hljs-comment">// break</span>mv.visitLabel(labelNumber);mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// tmp</span>mv.visitTypeInsn(CHECKCAST, <span class="hljs-string">&quot;java/lang/Number&quot;</span>); <span class="hljs-comment">// 强制类型转换</span>mv.visitVarInsn(ASTORE, <span class="hljs-number">4</span>); <span class="hljs-comment">// 存储到n</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">4</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/Number&quot;</span>, <span class="hljs-string">&quot;longValue&quot;</span>, <span class="hljs-string">&quot;()J&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(J)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitJumpInsn(GOTO, labelEnd); <span class="hljs-comment">// break</span>mv.visitLabel(labelDefault);mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;Others&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitLabel(labelEnd);mv.visitFrame(F_CHOP, <span class="hljs-number">2</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 清除局部变量</span>mv.visitInsn(RETURN);</code></pre><blockquote><p>通过SwitchBootstrap可以看出switch以后可能将尽可能使用invokedynamic：typeSwitch支持String输入，也许之后会将String的switch语句修改为这种实现；现在的类内部还有一个enumSwitch但是javac并不能编译出这个引导方法。在下个版本也许会进一步增加细节。</p></blockquote><h2 id="自定义引导方法"><a href="#自定义引导方法" class="headerlink" title="自定义引导方法"></a>自定义引导方法</h2><font color = "red" >注意：自定义一个引导方法可能导致你的程序不稳定、出现奇奇怪怪的问题、编译变得极度麻烦。如果不是特殊用途（比如说真正的让一个反编译器完全失效）不要用这个！</font><p>根据上面引导方法的定义和inDy的实现，我们自己也能创造出一个引导方法——只需要满足要求就好。下面就是一个简单的引导方法：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title">bootstrap</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, MethodType type)</span> </span>&#123;<span class="hljs-keyword">if</span> (!type.returnType().equals(String.class) || type.parameterCount() != <span class="hljs-number">0</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unknown&quot;</span>); <span class="hljs-comment">// 我们限定只能输入这种方法类型</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConstantCallSite(MethodHandles.constant(String.class, <span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// 方法句柄：返回常量hello</span>&#125;</code></pre><p>接着，我们在我们的方法里面用字节码指向它：</p><pre><code class="hljs Java">mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>); <span class="hljs-comment">// System.out</span>mv.visitInvokeDynamicInsn(<span class="hljs-string">&quot;testBootstrap&quot;</span>, <span class="hljs-comment">// 名字，我们定义的引导方法没有使用它</span>                          <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-comment">// 方法类型，我们强制规定了使用返回值为String的无参方法</span>                          <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;bootstrap&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="hljs-keyword">false</span>) <span class="hljs-comment">// 引导方法的句柄</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// println</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 最大操作栈是[java/io/PrintStream,java/lang/String] 没有局部变量</span></code></pre><p>接下来就是执行，输出结果是：</p><pre><code class="hljs shell">hello</code></pre><p>这样，我们就成功让字节码指向我们自定义的引导方法。</p><p>全部的代码：<a href="https://paste.ubuntu.com/p/d82FNcP6jS/">https://paste.ubuntu.com/p/d82FNcP6jS/</a></p><h2 id="动态常量（Constant-Dynamic）"><a href="#动态常量（Constant-Dynamic）" class="headerlink" title="动态常量（Constant Dynamic）"></a>动态常量（Constant Dynamic）</h2><p>之前在BSM那里简单提到了动态计算常量，这是JEP 309（Java 11）引入的，在这里我们再进一步深入讲解。</p><p>首先，它的BSM定义和动态调用点的BSM定义方式不同，详情可以看上面。在写入ASM时，它使用的是<code>visitLdcInsn</code>，和普通常量一样。</p><p>创建一个动态常量使用ConstantDynamic，它的构造函数如下：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConstantDynamic</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String name,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String descriptor,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> Handle bootstrapMethod,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> Object... bootstrapMethodArguments)</span></span></code></pre><p>可以看到它和visitInvokeDynamicInsn差不多，唯一的区别是：<code>descriptor</code>是类描述符而不是方法描述符。因此，所有动态常量的BSM都不允许传入变量。</p><p>有关于动态常量的BSM都存储到了一个类中：<code>java.lang.invoke.ConstantBootstraps</code>。</p><pre><code class="hljs Java"><span class="hljs-comment">// null的常量，只与type有关</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">nullConstant</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type)</span></span><span class="hljs-function"><span class="hljs-comment">// 获得类描述符为name的Class对象，type必须是Class.class</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; <span class="hljs-title">primitiveClass</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type)</span></span><span class="hljs-function"><span class="hljs-comment">// 获得名称为name的枚举对象</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E extends Enum&lt;E&gt;&gt; E <span class="hljs-title">enumConstant</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;E&gt; type)</span></span><span class="hljs-function"><span class="hljs-comment">// 获得位于declaringClass内部的静态终态字段name</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getStaticFinal</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type, Class&lt;?&gt; declaringClass)</span></span><span class="hljs-function"><span class="hljs-comment">// 上面的简化版本，令declaringClass与type相同</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getStaticFinal</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type)</span></span><span class="hljs-function"><span class="hljs-comment">// 获得handle使用静态参量args的结果</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type, MethodHandle handle, Object... args)</span></span><span class="hljs-function"><span class="hljs-comment">// 获得字段的VarHandle</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> VarHandle <span class="hljs-title">fieldVarHandle</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;VarHandle&gt; type, Class&lt;?&gt; declaringClass, Class&lt;?&gt; fieldType)</span></span><span class="hljs-function"><span class="hljs-comment">// 获得静态字段的VarHandle</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> VarHandle <span class="hljs-title">staticFieldVarHandle</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;VarHandle&gt; type, Class&lt;?&gt; declaringClass, Class&lt;?&gt; fieldType)</span></span><span class="hljs-function"><span class="hljs-comment">// 获得数组的VarHandle</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> VarHandle <span class="hljs-title">arrayVarHandle</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;VarHandle&gt; type, Class&lt;?&gt; arrayClass)</span></span><span class="hljs-function"><span class="hljs-comment">// 将value显式转换到dstType</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">explicitCast</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; dstType, Object value)</span> <span class="hljs-keyword">throws</span> ClassCastException</span></code></pre><p>使用动态计算常量可以使用其他动态计算常量作为静态参数，这时JVM会倒序一个个计算创建常量。</p><p>下面是个例子：</p><pre><code class="hljs Java">#ldc 动态常量 System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);</code></pre><p>字节码写入如下：</p><pre><code class="hljs Java">mv.visitLdcInsn(<span class="hljs-keyword">new</span> ConstantDynamic(                <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-comment">// 字段的名称</span>                <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>, <span class="hljs-comment">// 字段类型</span>                <span class="hljs-keyword">new</span> Handle(H_INVOKESTATIC, <span class="hljs-string">&quot;java/lang/invoke/ConstantBootstraps&quot;</span>, <span class="hljs-string">&quot;getStaticFinal&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/Object;&quot;</span>, <span class="hljs-keyword">false</span>), <span class="hljs-comment">// BSM句柄</span>                Type.getType(<span class="hljs-string">&quot;Ljava/lang/System;&quot;</span>) <span class="hljs-comment">// 字段声明位置</span>));mv.visitLdcInsn(<span class="hljs-string">&quot;hello&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);</code></pre><p>每个ConstantDynamic都可以复用——你可以使用一个对象传入到不同的LDC里面去。这些对象最终和普通常量一样存储到常量池内部。</p><hr><p>这篇专栏就这些了，只讲了一个字节码，但是内容很多。加上以前的一共191个。</p><p>有错误可以在评论区指出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前四篇专栏已经简要的描述了常用的字节码，这篇专栏将讲述Java 7以来最重要的字节码之一：invokedynamic。&lt;/p&gt;
&lt;h2 id=&quot;方法句柄（Method-Handle）&quot;&gt;&lt;a href=&quot;#方法句柄（Method-Handle）&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="ASM" scheme="http://nickid2018.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Java ASM详解：MethodVisitor与Opcode（四）其他流程结构</title>
    <link href="http://nickid2018.github.io/2021/11/21/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/"/>
    <id>http://nickid2018.github.io/2021/11/21/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/</id>
    <published>2021-11-20T18:02:53.000Z</published>
    <updated>2021-11-20T14:05:07.734Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，我们已经了解了基本的流程结构。这篇专栏将详细描述Java中其他的流程结构。</p><h2 id="异常捕获结构"><a href="#异常捕获结构" class="headerlink" title="异常捕获结构"></a>异常捕获结构</h2><p>在平常我们使用流程结构时，除了选择结构和循环结构外，使用最多的大概就是异常捕获结构了。</p><p>异常捕获结构的写入都使用了<code>visitTryCatchBlock</code>方法（内部的实现是<code>JSR</code>和<code>RET</code>字节码），它需要早于其他所有字节码写入，也就是在方法写入一开始就要定义。它的定义如下：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTryCatchBlock</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Label start, <span class="hljs-keyword">final</span> Label end, <span class="hljs-keyword">final</span> Label handler, <span class="hljs-keyword">final</span> String type)</span></span></code></pre><p>其中，<code>start</code>是try块开始的标签；<code>end</code>是try结束后的标签（try的范围不包括这个标签）；<code>handler</code>是try块内抛出<code>Throwable</code>对象后跳转到的标签，即相应的catch块标签；<code>type</code>是catch接受的异常类型，要求传入异常类的全限定名（例外是finally块）。</p><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p>在讲述完整的<code>try-catch-finally</code>块之前，我们先来看看普通的<code>try-catch</code>块怎么写入。</p><p>普通的try-catch块类似这样：</p><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">// try块</span>&#125; <span class="hljs-keyword">catch</span> (FirstException e) &#123;  <span class="hljs-comment">// 处理FirstException</span>&#125; <span class="hljs-keyword">catch</span> (SecondException e) &#123;  <span class="hljs-comment">// 处理SecondException</span>&#125;</code></pre><p>对于一个指定的try块，可能有多个catch块和它对应。每一个catch块都需要用一次visitTryCatchBlock声明。对于catch块对应的跳转标签目标，它的栈帧信息应该和try块前的局部变量相同，但是操作栈上有一个对应的异常对象。下面给出了使用try-catch块的例子：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseIntSafely</span><span class="hljs-params">(String s)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">/* labelTryStart */</span><span class="hljs-keyword">return</span> Integer.parseInt(s);&#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<span class="hljs-comment">/* labelCatch */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125;</code></pre><p>使用asm写入如下:</p><blockquote><p>javac编译时生成的字节码和这里不太一样——它会把已经在操作栈上的Throwable对象先存入局部变量，这是为了输出文件的行号。而这里我们选择直接忽视栈上的Throwable对象。</p></blockquote><pre><code class="hljs Java"><span class="hljs-comment">// 初始栈帧信息 [java/lang/String]</span>Label labelTryStart = <span class="hljs-keyword">new</span> Label();Label labelCatch = <span class="hljs-keyword">new</span> Label();mv.visitTryCatchBlock(labelTryStart, labelCatch, labelCatch, <span class="hljs-string">&quot;java/lang/NumberFormatException&quot;</span>); <span class="hljs-comment">// try的范围是[labelTryStart, labelCatch)</span>mv.visitLabel(labelTryStart);<span class="hljs-comment">// try块内部</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// 加载s</span>mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/Integer&quot;</span>, <span class="hljs-string">&quot;parseInt&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)I&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// Integer::parseInt</span>mv.visitInsn(IRETURN);<span class="hljs-comment">// try结束</span>mv.visitLabel(labelCatch);<span class="hljs-comment">// catch块开始</span><span class="hljs-comment">// 栈帧信息 [java/lang/String] [java/lang/NumberFormatException]</span>mv.visitFrame(F_SAME1, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Object[] &#123; <span class="hljs-string">&quot;java/lang/NumberFormatException&quot;</span> &#125;);mv.visitInsn(ICONST_0);mv.visitInsn(IRETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 最大栈帧为2 （catch块内），局部变量1</span></code></pre><h3 id="multi-catch"><a href="#multi-catch" class="headerlink" title="multi-catch"></a>multi-catch</h3><p>除了普通的catch外，还有一种<code>multi-catch</code>结构：</p><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// try块</span>&#125; <span class="hljs-keyword">catch</span> (FirstException | SecondException e) &#123;<span class="hljs-comment">// catch块</span>&#125;</code></pre><p>multi-catch可以看做几个catch块被共用，这时栈帧信息上的操作栈压入的是multi-catch中所有异常类的<strong>共有超类</strong>。例如一个multi-catch块能捕获<code>NumberFormatException</code>和<code>NullPointerException</code>，它的字节码写入如下：</p><pre><code class="hljs Java">Label labelTryStart = <span class="hljs-keyword">new</span> Label();Label labelCatch = <span class="hljs-keyword">new</span> Label();mv.visitTryCatchBlock(labelTryStart, labelCatch, labelCatch, <span class="hljs-string">&quot;java/lang/NumberFormatException&quot;</span>); <span class="hljs-comment">// try的范围是[labelTryStart, labelCatch)</span>mv.visitTryCatchBlock(labelTryStart, labelCatch, labelCatch, <span class="hljs-string">&quot;java/lang/NullPointerException&quot;</span>);<span class="hljs-comment">// 代码和try块，略</span>mv.visitLabel(labelCatch);mv.visitFrame(F_XXXX, X, XXX, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Object[] &#123; <span class="hljs-string">&quot;java/lang/RuntimeException&quot;</span> &#125;); <span class="hljs-comment">// 栈帧其他信息忽略，操作栈上是共有超类RuntimeException</span><span class="hljs-comment">// catch块及之后的代码...</span></code></pre><h3 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h3><p>说完了try-catch，我们再看看try-finally语句。</p><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// try块内容</span>&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// finally块内容</span>&#125;</code></pre><p>finally其实类似catch，它们都会在操作栈上压入Throwable对象（如果产生了异常），但是它是<strong>无跳转条件（null）</strong>的，无论是否出现异常都会执行一次finally，即<strong>代码流必须经过finally</strong>。如果try块内包含return，也必须先执行finally的内容之后再执行return。如果finally中含有return，则try内的所有return将被忽略，通常IDE会对这种情况给出警告。</p><p>在finally执行之后，如果是没有发生异常进入finally，则正常向下运行；如果是因为异常进入了finally，那么在finally执行之后必须抛出异常————这就意味着你必须把finally的字节码<strong>重复两遍</strong>，一次没有异常进入finally，一次发生异常进入finally。</p><p>下面是一个例子：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseIntAndHello</span><span class="hljs-params">(String s)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">/* labelTry */</span><span class="hljs-keyword">return</span> Integer.parseInt(s);<span class="hljs-comment">/* labelReturn */</span>&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">/* labelFinally */</span>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;&#125;</code></pre><p>asm写入：</p><blockquote><p>javac编译还是不是这样，但是运行结果是一样的。javac会让一行语句的执行前后操作栈是空，所以在labelReturn前会进行<code>ISTORE</code>，在<code>IRETURN</code>前<code>ILOAD</code></p></blockquote><pre><code class="hljs Java">Label labelTry = <span class="hljs-keyword">new</span> Label();Label labelReturn = <span class="hljs-keyword">new</span> Label();Label labelFinally = <span class="hljs-keyword">new</span> Label();mv.visitTryCatchBlock(labelTry, labelReturn, labelFinally, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// try位于[labelTry, labelReturn)，发生任何异常都会跳转finally</span>mv.visitLabel(labelTry);<span class="hljs-comment">// try开始</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// s</span>mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/Integer&quot;</span>, <span class="hljs-string">&quot;parseInt&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)I&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// Integer::parseInt</span><span class="hljs-comment">// try结束，无异常进入finally</span>mv.visitLabel(labelReturn);mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;hello&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// System.out.println</span>mv.visitInsn(IRETURN);<span class="hljs-comment">// 正常进入finally结束</span>mv.visitLabel(labelFinally);<span class="hljs-comment">// 发生异常进入finally</span>mv.visitFrame(F_SAME1, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Object[] &#123; <span class="hljs-string">&quot;java/lang/Throwable&quot;</span> &#125;);<span class="hljs-comment">// finally接受Throwable对象</span>mv.visitVarInsn(ASTORE, <span class="hljs-number">1</span>);<span class="hljs-comment">// 保存到槽位1用于之后抛出</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;hello&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);<span class="hljs-comment">// 重复finally内容</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>);<span class="hljs-comment">// 取出Throwable对象</span>mv.visitInsn(ATHROW);<span class="hljs-comment">// 抛出</span>mv.visitMaxs(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);</code></pre><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>接下来，我们把<code>try-catch</code>和<code>try-finally</code>整合到一起。</p><p>finally块的意义是无论发生什么异常都要保证执行，所以catch块的异常也会被finally接受。也就是说，一个完整的try-catch-finally语句需要$1+2catch$次visitTryCatchBlock，并且需要重复finally块字节码$1+catch$次。（其中$catch$是catch块的数量）</p><p>下面是个整合的例子：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseIntSafelyHello</span><span class="hljs-params">(String s)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">/* ltry */</span><span class="hljs-keyword">return</span> Integer.parseInt(s);<span class="hljs-comment">/* lreturn */</span>&#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<span class="hljs-comment">/* lcatch */</span><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">/* lcatchRet */</span>&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">/* lfinally */</span>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;&#125;</code></pre><p>asm写入：</p><pre><code class="hljs Java">Label ltry = <span class="hljs-keyword">new</span> Label(), lreturn = <span class="hljs-keyword">new</span> Label(), lcatch = <span class="hljs-keyword">new</span> Label(), lcatchRet = <span class="hljs-keyword">new</span> Label(), lfinally = <span class="hljs-keyword">new</span> Label();mv.visitTryCatchBlock(ltry, lreturn, lcatch, <span class="hljs-string">&quot;java/lang/NumberFormatException&quot;</span>);mv.visitTryCatchBlock(ltry, lreturn, lfinally, <span class="hljs-keyword">null</span>);mv.visitTryCatchBlock(lcatch, lcatchRet, lfinally, <span class="hljs-keyword">null</span>);mv.visitLabel(ltry);<span class="hljs-comment">// try块开始</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// s</span>mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/Integer&quot;</span>, <span class="hljs-string">&quot;parseInt&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)I&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// Integer::parseInt</span><span class="hljs-comment">// try结束，try无异常进入finally</span>mv.visitLabel(lreturn);mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;hello&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// System.out.println</span>mv.visitInsn(IRETURN);<span class="hljs-comment">// try无异常finally结束</span>mv.visitLabel(lcatch);<span class="hljs-comment">// catch块开始</span>mv.visitFrame(F_SAME1, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Object[] &#123; <span class="hljs-string">&quot;java/lang/NumberFormatException&quot;</span> &#125;);<span class="hljs-comment">// 栈帧信息：压入异常对象</span>mv.visitInsn(POP);<span class="hljs-comment">// 我们不需要这个对象,直接弹栈（javac会进行ASTORE，无论是否使用，因为要记录名称）</span>mv.visitLabel(lcatchRet);<span class="hljs-comment">// catch无异常进入finally</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;hello&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 重复一遍finally...</span>mv.visitInsn(ICONST_M1);mv.visitInsn(IRETURN); <span class="hljs-comment">// 返回-1</span>mv.visitLabel(lfinally);<span class="hljs-comment">// 发生异常跳转finally</span>mv.visitFrame(F_SAME1, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Object[] &#123; <span class="hljs-string">&quot;java/lang/Throwable&quot;</span> &#125;);mv.visitVarInsn(ASTORE, <span class="hljs-number">1</span>); <span class="hljs-comment">// 保存到槽位1</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;hello&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 再重复一遍finally...</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>);mv.visitInsn(ATHROW);<span class="hljs-comment">// 抛出</span>mv.visitMaxs(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);</code></pre><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>除了try-catch、multi-catch、try-finally、try-catch-finally结构外，还有一种结构：<code>try-with-resources</code>。这种结构要求一个<code>AutoClosable</code>的对象在try后的语句中初始化：</p><pre><code class="hljs Java"><span class="hljs-keyword">try</span> (AutoClosable res1 = getObject1(), res2 = getObject2(), ...) &#123;<span class="hljs-comment">// try内的语句</span>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<span class="hljs-comment">// catch块</span>&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// finally...</span>&#125;</code></pre><p>它可以转化为普通的try-catch-finally块，类似于这样：</p><blockquote><p>javac编译之后内部不是这样，这里是将执行流程强制转换为可读Java源码</p></blockquote><pre><code class="hljs Java">AutoClosable res = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;res = getObject1();<span class="hljs-comment">// try块内容...</span>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<span class="hljs-comment">// catch块内容...</span><span class="hljs-comment">// 这里res也会被close，但是因为Java代码没法表现就没有写</span>&#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<span class="hljs-keyword">try</span> &#123;res.close(); <span class="hljs-comment">// 这里其实res已经被创建了，但是因为Java代码没法表现就放在这里了</span>&#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;t.addSupressed(t2);&#125;<span class="hljs-keyword">throw</span> t;&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// finally...</span>&#125;</code></pre><p>使用try-with-resources结构写入字节码的时候，只要记住每一个出口都会进行一次带try-catch的<code>close</code>就可以。由于这种结构很复杂且代码量巨大，就不举例子了。</p><h2 id="switch多分支结构"><a href="#switch多分支结构" class="headerlink" title="switch多分支结构"></a>switch多分支结构</h2><p>在一些情况下，<code>if...else if...else</code>结构非常的长，这时我们可以用<code>switch</code>替代。</p><h3 id="可直接表示为int的switch多分支语句"><a href="#可直接表示为int的switch多分支语句" class="headerlink" title="可直接表示为int的switch多分支语句"></a>可直接表示为int的switch多分支语句</h3><p>最简单的switch是键为整形数字常量（可以用int表示的）的，类似于这样：</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span> i = ...;<span class="hljs-keyword">switch</span> (i) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:......<span class="hljs-keyword">default</span>:...&#125;</code></pre><p>在写入switch中，我们有两个方法可以选择：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTableSwitchInsn</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> max, <span class="hljs-keyword">final</span> Label dflt, <span class="hljs-keyword">final</span> Label... labels)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitLookupSwitchInsn</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Label dflt, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] keys, <span class="hljs-keyword">final</span> Label[] labels)</span></span></code></pre><p>它们的相同之处是：它们都需要操作栈顶上有一个int类型的值。它们的不同之处在于它们对于键值的存储方式和使用的字节码：</p><ul><li><p><code>visitTableSwitchInsn</code>写入的键值是一个连续的数组——一个$[min,max]$的一个整形数字数组。如果switch中没有中间的某些键值，那么这些键值会和<code>dflt</code>一致，即default的标签（如果没有default块，则dflt应该指向switch结束后的第一条语句）。它使用<code>TABLESWITCH</code>字节码。</p></li><li><p><code>visitLookupSwitchInsn</code>要求传入一个switch键值的数组，数组内的数字要从小到大排序。<code>labels</code>数组的长度要与<code>keys</code>一致。<code>dflt</code>也是指向default或者switch结束后的第一条语句的标签。它使用<code>LOOKUPSWITCH</code>字节码。</p></li></ul><p>回到最简单的switch上来。我们需要按照键值的特性选择我们的写入方式：</p><ul><li><p>如果switch内的键值差异小，并且键值组成一个连续整数数组的空缺不超过6个，则使用visitTableSwitchInsn</p></li><li><p>如果switch内的键值差异大，则使用visitLookupSwitchInsn</p></li></ul><p>先看个简单的小例子：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-keyword">switch</span> (i) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:        <span class="hljs-comment">/* label1 */</span>System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        <span class="hljs-comment">/* label2 */</span>System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:        <span class="hljs-comment">/* label3 */</span>System.out.println(<span class="hljs-string">&quot;3&quot;</span>);&#125;<span class="hljs-comment">/* labelEnd */</span>&#125;</code></pre><p>可以看到，键值$\{0,1,2,3\}$组成了一个连续的整数数组，所以这里我们应该使用visitTableSwitchInsn。</p><pre><code class="hljs Java">mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// i</span>Label label1 = <span class="hljs-keyword">new</span> Label(), label2 = <span class="hljs-keyword">new</span> Label(), label3 = <span class="hljs-keyword">new</span> Label(), labelEnd = <span class="hljs-keyword">new</span> Label();mv.visitTableSwitchInsn(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, labelEnd, label1, label1, label2, label3);<span class="hljs-comment">// 解释：没有default块所以指向了switch结束的下一条语句，0和1用了一个跳转位置</span>mv.visitLabel(label1);<span class="hljs-comment">// 0和1处理</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;1&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitLabel(label2);<span class="hljs-comment">// 2的处理，注意这里0和1处理之后也会经过这个地方</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;2&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitJumpInsn(GOTO, labelEnd); <span class="hljs-comment">// break的作用，跳出switch</span>mv.visitLabel(label3);<span class="hljs-comment">// 3的处理，这里不会被0、1、2访问了</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;3&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);<span class="hljs-comment">// switch结束</span>mv.visitLabel(labelEnd);mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);</code></pre><p>这是对于switch最简单的一种清况之一。因为<code>byte</code>、<code>short</code>、<code>char</code>在JVM内解释为int，所以这些步骤基本相同。</p><h3 id="使用枚举的switch多分支语句"><a href="#使用枚举的switch多分支语句" class="headerlink" title="使用枚举的switch多分支语句"></a>使用枚举的switch多分支语句</h3><p>switch语句还可以用于枚举类型，下面我们定义了一个枚举，并使用了它：</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestEnum</span> </span>&#123;FIRST, SECOND, THIRD, FOURTH&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(TestEnum i)</span> </span>&#123;<span class="hljs-keyword">switch</span> (i) &#123;<span class="hljs-keyword">case</span> FIRST:<span class="hljs-keyword">case</span> SECOND:System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">case</span> THIRD:System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> FOURTH:System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<span class="hljs-keyword">default</span>:System.out.println(<span class="hljs-string">&quot;4&quot;</span>);&#125;&#125;</code></pre><p>枚举类型不能直接作为两种switch字节码的参数，它必须先变为一个int才能传入字节码。为此，javac在编译的时候会自动创建一个内部类，用于保存这个类里面出现的所有使用枚举对象switch的一个映射表。对于我们定义的TestEnum，它对应的映射类应该像这样（假设我们方法定义的类是<code>Test</code>）：</p><pre><code class="hljs Java"><span class="hljs-comment">// 注意：这个类和字段都要有ACC_SYNTHETIC访问标志</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>$1 </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] $SwitchMap$TestEnum;<span class="hljs-keyword">static</span> &#123;$SwitchMap$TestEnum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[TestEnum.values().length];<span class="hljs-keyword">try</span> &#123;$SwitchMap$TestEnum[TestEnum.FIRST.ordinal()] = <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldError e) &#123;&#125;<span class="hljs-keyword">try</span> &#123;$SwitchMap$TestEnum[TestEnum.SECOND.ordinal()] = <span class="hljs-number">2</span>;&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldError e) &#123;&#125;<span class="hljs-keyword">try</span> &#123;$SwitchMap$TestEnum[TestEnum.THIRD.ordinal()] = <span class="hljs-number">3</span>;&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldError e) &#123;&#125;<span class="hljs-keyword">try</span> &#123;$SwitchMap$TestEnum[TestEnum.FOURTH.ordinal()] = <span class="hljs-number">4</span>;&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldError e) &#123;&#125;&#125;&#125;</code></pre><p>这个内部类中含有所有在这个类中出现的枚举对象，每个枚举类都会创建一个字段，命名为<code>$SwitchMap$+.替换成$的类型名</code>，它们的长度是对应枚举类枚举字段的数量，按照ordinal大小排序将<code>1-n</code>写入数组（n是本类使用了多少个这个类的枚举字段）。</p><p>接下来，switch的传入方式也发生了变化：</p><pre><code class="hljs Java">TestEnum i ...<span class="hljs-keyword">switch</span> (Test$<span class="hljs-number">1.</span>$SwitchMap$TestEnum[i.ordinal()]) &#123;...&#125;</code></pre><p>那么之前给出的例子我们可以用asm写入为：</p><pre><code class="hljs Java">mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;Test$1&quot;</span>, <span class="hljs-string">&quot;$SwitchMap$TestEnum&quot;</span>, <span class="hljs-string">&quot;[I&quot;</span>); <span class="hljs-comment">// 获取常量字段</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// i</span>mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;TestEnum&quot;</span>, <span class="hljs-string">&quot;ordinal&quot;</span>, <span class="hljs-string">&quot;()I&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// Enum::ordinal</span>mv.visitInsn(IALOAD); <span class="hljs-comment">// 取出常量</span>Label label1 = <span class="hljs-keyword">new</span> Label(), label2 = <span class="hljs-keyword">new</span> Label(), label3 = <span class="hljs-keyword">new</span> Label(), labelDefault = <span class="hljs-keyword">new</span> Label(), labelEnd = <span class="hljs-keyword">new</span> Label();mv.visitTableSwitchInsn(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, labelDefault, label1, label1, label2, label3);<span class="hljs-comment">// default标签-labelDefault, 1/2用了同一个跳转目标</span>mv.visitLabel(label1);<span class="hljs-comment">// 1/2 FIRST/SECOND</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;1&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitLabel(label2);<span class="hljs-comment">// 3 THIRD</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;2&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitJumpInsn(GOTO, labelEnd); <span class="hljs-comment">// break</span>mv.visitLabel(label3);<span class="hljs-comment">// 4 FOURTH</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;3&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitLabel(labelDefault);<span class="hljs-comment">// default</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;4&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitLabel(labelEnd);<span class="hljs-comment">// switch结束</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);</code></pre><p>如果是我们自己写入asm，推荐不要用这种方式写入——毕竟太麻烦了。最好的方案是使用<code>Enum::ordinal</code>获取序号对序号进行switch，而不是存一个新的表。</p><h3 id="使用字符串的switch多分支语句"><a href="#使用字符串的switch多分支语句" class="headerlink" title="使用字符串的switch多分支语句"></a>使用字符串的switch多分支语句</h3><p>除了枚举和基本int之外，switch还允许字符串传入。下面就是一个例子：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String s)</span> </span>&#123;<span class="hljs-keyword">switch</span> (s) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;HELLO&quot;</span>:System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BYEBYE&quot;</span>:System.out.println(<span class="hljs-string">&quot;byebye&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:System.out.println(<span class="hljs-string">&quot;ss&quot;</span>);&#125;&#125;</code></pre><p>很明显，String不能直接转换成为int。在String中，<code>hashCode</code>这个方法可以让我们将字符串映射到int上，这样就能把它作为键值。但是还有一个问题需要解决：String和int不能一一对应——不同的字符串可能有相同的hashCode，例如<code>ddnqavbj</code>和<code>166lr735ka3q6</code>的哈希码值都为<code>0</code>。因此，javac在编译时将这个switch块<strong>拆开为两个，并使用一个临时量保存字符串的映射</strong>。这样，上面的例子就变成了下面这样：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String s)</span> </span>&#123;&#123;String tempStr = s;<span class="hljs-keyword">int</span> temp = -<span class="hljs-number">1</span>;<span class="hljs-keyword">switch</span> (tempStr.hashCode()) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">68624562</span>: <span class="hljs-comment">// &quot;HELLO&quot;的哈希码</span><span class="hljs-comment">/* hashHello */</span><span class="hljs-keyword">if</span> (tempStr.equals(<span class="hljs-string">&quot;HELLO&quot;</span>))temp = <span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1973839168</span>: <span class="hljs-comment">// &quot;BYEBYE&quot;的哈希码值</span><span class="hljs-comment">/* hashBye */</span><span class="hljs-keyword">if</span> (tempStr.equals(<span class="hljs-string">&quot;BYEBYE&quot;</span>))temp = <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">/* switch2 */</span><span class="hljs-keyword">switch</span> (temp) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">/* case0 */</span>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">/* case1 */</span>System.out.println(<span class="hljs-string">&quot;byebye&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-comment">/* caseDefault */</span>System.out.println(<span class="hljs-string">&quot;ss&quot;</span>);&#125;&#125;<span class="hljs-comment">/* end */</span>&#125;</code></pre><p>按照上面的Java代码，我们能用asm将它写入：</p><pre><code class="hljs Java"><span class="hljs-comment">// 初始帧 [java/lang/String]</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// s</span>mv.visitVarInsn(ASTORE, <span class="hljs-number">1</span>); <span class="hljs-comment">// 转存到tempStr</span>mv.visitInsn(ICONST_M1); <span class="hljs-comment">// -1</span>mv.visitVarInsn(ISTORE, <span class="hljs-number">2</span>); <span class="hljs-comment">// 存入temp</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// tempStr</span>mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/String&quot;</span>, <span class="hljs-string">&quot;hashCode&quot;</span>, <span class="hljs-string">&quot;()I&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// tempStr.hashCode()</span>Label hashHello = <span class="hljs-keyword">new</span> Label(), hashBye = <span class="hljs-keyword">new</span> Label(), switch2 = <span class="hljs-keyword">new</span> Label();mv.visitLookupSwitchInsn(switch2, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123; <span class="hljs-number">68624562</span>, <span class="hljs-number">1973839168</span> &#125;, <span class="hljs-keyword">new</span> Label[]&#123; hashHello, hashBye &#125;);mv.visitLabel(hashHello);<span class="hljs-comment">// HELLO的哈希码</span><span class="hljs-comment">// 栈帧 [java/lang/String java/lang/String I]</span>mv.visitFrame(F_APPEND, <span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;java/lang/String&quot;</span>, Opcodes.INTEGER&#125;, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// tempStr</span>mv.visitLdcInsn(<span class="hljs-string">&quot;HELLO&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/String&quot;</span>, <span class="hljs-string">&quot;equals&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 判断</span>mv.visitJumpInsn(IFEQ, switch2); <span class="hljs-comment">// 反转判断，失败直接跳转出去</span>mv.visitInsn(ICONST_0); <span class="hljs-comment">// 0</span>mv.visitVarInsn(ISTORE, <span class="hljs-number">2</span>); <span class="hljs-comment">// 赋值给temp</span>mv.visitJumpInsn(GOTO, switch2); <span class="hljs-comment">// 也跳转出去</span>mv.visitLabel(hashBye);<span class="hljs-comment">// BYEBYE的哈希码</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// tempStr</span>mv.visitLdcInsn(<span class="hljs-string">&quot;BYEBYE&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/lang/String&quot;</span>, <span class="hljs-string">&quot;equals&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 判断</span>mv.visitJumpInsn(IFEQ, switch2); <span class="hljs-comment">// 反转判断，失败直接跳转</span>mv.visitInsn(ICONST_1); <span class="hljs-comment">// 1</span>mv.visitVarInsn(ISTORE, <span class="hljs-number">2</span>); <span class="hljs-comment">// 赋值给temp</span>mv.visitLabel(switch2);<span class="hljs-comment">// 第一个switch结束</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">2</span>); <span class="hljs-comment">// 加载temp</span>Label case0 = <span class="hljs-keyword">new</span> Label(), case1 = <span class="hljs-keyword">new</span> Label(), caseDefault = <span class="hljs-keyword">new</span> Label(), end = <span class="hljs-keyword">new</span> Label();mv.visitLookupSwitchInsn(caseDefault, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;, <span class="hljs-keyword">new</span> Label[]&#123; case0, case1 &#125;);<span class="hljs-comment">// 这里可以用tableswitch，但是javac是这样编译出来的</span>mv.visitLabel(case0);<span class="hljs-comment">// HELLO</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;hello&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitJumpInsn(GOTO, end); <span class="hljs-comment">// 跳转结束</span>mv.visitLabel(case1);<span class="hljs-comment">// BYEBYE</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;byebye&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitJumpInsn(GOTO, end); <span class="hljs-comment">// 跳转结束</span>mv.visitLabel(caseDefault);<span class="hljs-comment">// default</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 栈帧无变化</span>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);mv.visitLdcInsn(<span class="hljs-string">&quot;ss&quot;</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitLabel(end);<span class="hljs-comment">// 结束</span><span class="hljs-comment">// 栈帧信息 [java/lang/String]</span>mv.visitFrame(F_CHOP, <span class="hljs-number">2</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></pre><h3 id="增强型switch"><a href="#增强型switch" class="headerlink" title="增强型switch"></a>增强型switch</h3><p>最后来看看Java 14新加的增强型switch。</p><p>首先，增强型switch可以返回一个值赋给变量或者进行操作：</p><pre><code class="hljs Java">System.out.println(<span class="hljs-keyword">switch</span> (s) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;HELLO&quot;</span> -&gt; <span class="hljs-number">3</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BYEBYE&quot;</span> -&gt; <span class="hljs-number">4</span>;<span class="hljs-keyword">default</span> -&gt; <span class="hljs-number">5</span>;&#125;);</code></pre><p>这种操作的本质还是和上面的一样，下面是展开增强型switch但是不展开String转换的结果：</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span> temp;<span class="hljs-keyword">switch</span> (s) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;HELLO&quot;</span>:temp = <span class="hljs-number">3</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BYEBYE&quot;</span>:temp = <span class="hljs-number">4</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:temp = <span class="hljs-number">5</span>;&#125;System.out.println(temp);</code></pre><p>另一种增强型switch使用了<code>yield</code>关键字：</p><pre><code class="hljs Java">System.out.println(<span class="hljs-keyword">switch</span> (s) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;HELLO&quot;</span>:System.out.println(<span class="hljs-string">&quot;case0&quot;</span>);yield <span class="hljs-number">3</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BYEBYE&quot;</span>:System.out.println(<span class="hljs-string">&quot;case1&quot;</span>);yield <span class="hljs-number">4</span>;<span class="hljs-keyword">default</span>:System.out.println(<span class="hljs-string">&quot;default&quot;</span>);yield <span class="hljs-number">5</span>;&#125;);</code></pre><p>它的原理也和上面差不多：</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span> temp;<span class="hljs-keyword">switch</span> (s) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;HELLO&quot;</span>:System.out.println(<span class="hljs-string">&quot;case0&quot;</span>);temp = <span class="hljs-number">3</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BYEBYE&quot;</span>:System.out.println(<span class="hljs-string">&quot;case1&quot;</span>);temp = <span class="hljs-number">4</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:System.out.println(<span class="hljs-string">&quot;default&quot;</span>);temp = <span class="hljs-number">5</span>;&#125;System.out.println(temp);</code></pre><hr><p>这篇文章到这里就结束了（最后不写例子主要是因为这两种结构需要的代码量太大了）。</p><p>这回一共讲了4个字节码，加上以前的一共190个。</p><p>有错误可以在评论区指出~</p><p>下一期 Java ASM详解：MethodVisitor与Opcode（五）invokedynamic、方法引用、BSM</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇文章中，我们已经了解了基本的流程结构。这篇专栏将详细描述Java中其他的流程结构。&lt;/p&gt;
&lt;h2 id=&quot;异常捕获结构&quot;&gt;&lt;a href=&quot;#异常捕获结构&quot; class=&quot;headerlink&quot; title=&quot;异常捕获结构&quot;&gt;&lt;/a&gt;异常捕获结构&lt;/h2&gt;&lt;p&gt;在平</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="ASM" scheme="http://nickid2018.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Java ASM详解：MethodVisitor与Opcode（三）标签，条件结构，循环结构，栈帧</title>
    <link href="http://nickid2018.github.io/2021/11/06/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%B8%89%EF%BC%89%E6%A0%87%E7%AD%BE%EF%BC%8C%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%8C%E6%A0%88%E5%B8%A7/"/>
    <id>http://nickid2018.github.io/2021/11/06/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%B8%89%EF%BC%89%E6%A0%87%E7%AD%BE%EF%BC%8C%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%8C%E6%A0%88%E5%B8%A7/</id>
    <published>2021-11-06T11:09:19.000Z</published>
    <updated>2021-11-06T04:37:32.781Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，我们已经知道了基础的字节码。但是，这些字节码只能构建起一个简单的结构，不能实现循环条件等高级结构。这篇文章将讨论关于程序流程结构的字节码。</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签（Label）是用来划明一部分字节码的标识（通常意义上标签就是一个标记点，但是为了接下来的讲述就用它代表一块字节码）。一个标签下的字节码块，应该从操作栈空开始到操作栈被清空结束——也就是说，一个标签代表的字节码块反编译之后应该是完整的一或多条语句。</p><p>在通常情况下，javac编译器会把每条单独语句都分配一个标签，这么做的目的是为了输出行号和局部变量名称。</p><p>标签也可以在我们使用Java时自己定义，下面的LABEL就是一个标签：</p><pre><code class="hljs Java">LABEL: <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    <span class="hljs-keyword">if</span>(Math.random() &gt; <span class="hljs-number">0.1</span>)      <span class="hljs-keyword">break</span> LABEL;&#125;</code></pre><p>在字节码中，标签代表的字节码块是从这个标签写入开始到下一个标签写入或该方法的字节码读取完毕的一部分字节码。</p><p>在ASM库中，标签用<code>org.objectweb.asm.Label</code>进行表示，构造方法如下：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Label</span><span class="hljs-params">()</span></span></code></pre><p>写入一个Label，需要用到MethodVisitor的方法，方法如下：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitLabel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Label label)</span></span></code></pre><p>正如前面所说，两个标签的写入之间的字节码可以看作这个标签代表的一块字节码块。因此，两个visitLabel之间的语句也可以被看作前一个Label代表的一部分字节码区域。</p><pre><code class="hljs Java">MethodVisitor mv = ...Label l1 = <span class="hljs-keyword">new</span> Label();mv.visitLabel(l1);<span class="hljs-comment">// --- l1代表的字节码块开始</span>mv....mv....<span class="hljs-comment">// --- l1代表的字节码块结束</span>Label l2 = <span class="hljs-keyword">new</span> Label();mv.visitLabel(l2);</code></pre><p>那么标签有什么用呢？</p><p>首先它可以保存代码的行号，这就用到了<code>MethodVisitor::visitLineNumber</code>这个方法了。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitLineNumber</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> line, <span class="hljs-keyword">final</span> Label start)</span></span></code></pre><p>第一个参数代表了这条语句的行号，第二个参数就是这条语句的标签。标签必须先于行号被写入，否则就会抛出<code>IllegalArgumentException</code>。</p><p>其次，它可以保存局部变量的名称。局部变量有作用域，而作用域可以用两个标签指定。在这两个标签之内且在指定局部变量槽位上的变量就是我们要命名的局部变量。写入局部变量的名称使用<code>MethodVisitor::visitLocalVariable</code>。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitLocalVariable</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String name,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String descriptor,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> String signature,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> Label start,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> Label end,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index)</span></span></code></pre><p>参数的意义分别是：名称、描述符、泛型签名、开始的标签、结束的标签、局部变量槽位。在javac编译生成的类文件中，局部变量名称的写入都要在最后写入。</p><p>最后，标签的最重要意义就是它可以用于跳转字节码上。</p><h2 id="跳转字节码"><a href="#跳转字节码" class="headerlink" title="跳转字节码"></a>跳转字节码</h2><p>用于跳转的字节码都使用了<code>visitJumpInsn</code>方法：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitJumpInsn</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> opcode, <span class="hljs-keyword">final</span> Label label)</span></span></code></pre><p>第一个就是字节码，第二个是跳转的目标。字节码决定了是否进行跳转，标签决定了跳转的目的地。</p><p>跳转字节码分为两种——比较跳转和无条件跳转。</p><h3 id="无条件跳转字节码"><a href="#无条件跳转字节码" class="headerlink" title="无条件跳转字节码"></a>无条件跳转字节码</h3><p>无条件跳转，也就是goto字节码：</p><pre><code class="hljs Java">输入：无输出：无方法：visitJumpInsn参数：标签使用范例：mv.visitJumpInsn(GOTO, label1);</code></pre><p>goto字节码是当程序运行到这里时，就直接跳转到对应的标签继续执行，通常都是用在循环内部的。</p><h3 id="比较跳转字节码"><a href="#比较跳转字节码" class="headerlink" title="比较跳转字节码"></a>比较跳转字节码</h3><p>比较跳转是大多数条件结构和循环结构使用的字节码，它有四套字节码，分别对应了int比较、int与0比较、对象比较和对象空检测：</p><h4 id="if-icmp-lt-cond-gt"><a href="#if-icmp-lt-cond-gt" class="headerlink" title="if_icmp&lt;cond&gt;"></a>if_icmp&lt;cond&gt;</h4><p>&lt;cond&gt; = eq/ne/lt/ge/gt/le</p><pre><code class="hljs Java">输入：两个<span class="hljs-keyword">int</span>数据输出：无方法：visitJumpInsn参数：标签使用范例：mv.visitJumpInsn(IF_ICMPEQ, label1);</code></pre><p>这六个字节码分别对应了两个int数据进行相等、不相等、小于、大于等于、大于、小于等于的比较测试。如果比较成功，就跳转到指定的标签处运行。如果比较不成功，就沿着当前的流程继续运行。</p><h4 id="if-lt-cond-gt"><a href="#if-lt-cond-gt" class="headerlink" title="if&lt;cond&gt;"></a>if&lt;cond&gt;</h4><p>&lt;cond&gt; = eq/ne/lt/ge/gt/le</p><pre><code class="hljs Java">输入：一个<span class="hljs-keyword">int</span>数据输出：无方法：visitJumpInsn参数：标签使用范例：mv.visitJumpInsn(IFEQ, label1);</code></pre><p>这六个字节码分别对应了一个int数据进行等于0、不等于0、小于0、大于等于0、大于0、小于等于0的比较测试。测试结果和跳转方式和上文相同。</p><h4 id="if-acmp-lt-cond-gt"><a href="#if-acmp-lt-cond-gt" class="headerlink" title="if_acmp&lt;cond&gt;"></a>if_acmp&lt;cond&gt;</h4><p>&lt;cond&gt; = eq/ne</p><pre><code class="hljs Java">输入：两个对象输出：无方法：visitJumpInsn参数：标签使用范例：mv.visitJumpInsn(IF_ACMPNE, label1);</code></pre><p>这两个字节码分别对应两个对象相等和不相等。这个字节码比较的是对象的引用，而不是内部的值——也就是说，即使两个String对象内部存储字符串一样，也不能保证它们的检测结果为真！（例外是使用了<code>String::intern</code>，它会把字符串放进常量池，并返回一个固定的引用）所以判断字符串相等必须使用<code>equals</code>方法而不是<code>==</code>。</p><h4 id="ifnull-ifnonnull"><a href="#ifnull-ifnonnull" class="headerlink" title="ifnull/ifnonnull"></a>ifnull/ifnonnull</h4><pre><code class="hljs Java">输入：一个对象输出：无方法：visitJumpInsn参数：标签使用范例：mv.visitJumpInsn(IFNULL, label1);</code></pre><p>这两个字节码分别测试对象是空还是非空。执行流程和之前3个一样。</p><p>可以看到，这几个字节码指针对了int和对象引用的情况，而没有考虑long、float、double的情况。于是Java加入了下面几个字节码用于比较它们，获取到值后就可以传递给各个IF字节码判断。</p><h3 id="比较字节码"><a href="#比较字节码" class="headerlink" title="比较字节码"></a>比较字节码</h3><h4 id="lcmp"><a href="#lcmp" class="headerlink" title="lcmp"></a>lcmp</h4><pre><code class="hljs Java">输入：两个<span class="hljs-keyword">long</span>输出：一个<span class="hljs-keyword">int</span>方法：visitInsn参数：无使用范例：mv.visitInsn(LCMP);</code></pre><p>它用于比较两个long的大小：如果第一个数字比第二个小，返回-1；如果第二个数字比第一个小，返回1；如果相等，返回0。</p><h4 id="xcmp-lt-op-gt"><a href="#xcmp-lt-op-gt" class="headerlink" title="xcmp&lt;op&gt;"></a>xcmp&lt;op&gt;</h4><p>x=f/d, &lt;op&gt;=l/g</p><pre><code class="hljs Java">输入：两个浮点数输出：一个<span class="hljs-keyword">int</span>方法：visitInsn参数：无使用范例：mv.visitInsn(FCMPG);</code></pre><p>这套字节码和lcmp的逻辑差不多：如果第一个数小于第二个数，返回-1；如果第二个数小于第一个数，返回1；如果相等，返回0。但是，如果其中一方是<code>NaN</code>，&lt;op&gt;就决定了它们返回的值：l版本返回-1，而g版本返回1。</p><p>接下来，我们将用这22个字节码实现程序的复杂流程结构。</p><h2 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h2><p>在Java中，条件结构类似于下面：</p><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (condition1) &#123;  <span class="hljs-comment">// ...</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2) &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-comment">// N 个else if</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (conditionN) &#123;  <span class="hljs-comment">// ...</span>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// ...</span>&#125;</code></pre><p>在编译期间，这种代码可以被看为：</p><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (condition1) &#123;  <span class="hljs-comment">// ...</span>&#125; <span class="hljs-keyword">else</span>   <span class="hljs-keyword">if</span> (condition2) &#123;  <span class="hljs-comment">// ...</span>  &#125; <span class="hljs-keyword">else</span>  <span class="hljs-comment">// N 个else if..</span>    <span class="hljs-keyword">if</span> (conditionN) &#123;  <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// ...</span>  &#125;</code></pre><p>也就是说，这种结构就是由一个一个的<code>if...else</code>结构组合形成的。一个简单的if…else结构用字节码写入后可以表示为这样的流程：</p><image src="/resources/2021110601/if-else.svg" type="image/svg+xml" width=400 height=400/> <p>if判断条件通常都使用了返回boolean的表达式（除了特殊字节码指定的比较方式外都需要这样传入），而boolean值的true是1，false是0，使用IFEQ字节码相当于被<strong>反向判断</strong>。相类似的，javac在编译时经常将字节码<strong>操作反转来保证if块先于else块写入</strong>。</p><p>返回boolean值传入if中的选择结构类似于这样：</p><pre><code class="hljs Java">...返回一个<span class="hljs-keyword">boolean</span>ifeq label2label1:  <span class="hljs-keyword">if</span>块内内容  goto label3label2:  <span class="hljs-keyword">else</span>块内内容label3:<span class="hljs-keyword">if</span>块外部代码</code></pre><p>在跳转之后，我们的操作栈和局部变量表会和跳转之前相等。同时，visitMaxs的参数变成了<strong>所有分支下最大的局部变量表大小和最大的操作栈深度</strong>。</p><p>下面举一个例子。要生成这样的Java代码：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;  <span class="hljs-keyword">if</span>(a &gt; b)    <span class="hljs-keyword">return</span> a;  <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> b;&#125;</code></pre><p>我们的字节码应该像下面这样写：</p><pre><code class="hljs Java"><span class="hljs-comment">// 省略ClassWriter和MethodVisitor创建和其他内容</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>);mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// 加载a、b</span>Label label1 = <span class="hljs-keyword">new</span> Label(); <span class="hljs-comment">// 创建标签</span>mv.visitJumpInsn(IF_ICMPLE, label1); <span class="hljs-comment">// a &gt; b 的反转判断（小于等于），这样能保证if块在前</span><span class="hljs-comment">// if部分内容</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>);mv.visitInsn(IRETURN); <span class="hljs-comment">// return a 方法结束</span>mv.visitLabel(label1);<span class="hljs-comment">// else部分内容</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>);mv.visitInsn(IRETURN); <span class="hljs-comment">// return b 方法结束</span>mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 两个int变量，操作栈深度最大2</span></code></pre><p>条件结构可以被简化为三元运算符，三元运算符的字节码也类似于if…else。</p><p>下面是一个使用三元运算符的例子：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;  <span class="hljs-keyword">int</span> endVal = val &lt; <span class="hljs-number">0</span> ? -val : val;  <span class="hljs-keyword">return</span> endVal * <span class="hljs-number">2</span>;&#125;</code></pre><p>字节码写入：</p><pre><code class="hljs Java"><span class="hljs-comment">// 省略ClassWriter和MethodVisitor创建和其他内容</span>Label labelElse = <span class="hljs-keyword">new</span> Label(); <span class="hljs-comment">// else 块的标签</span>mv.visitJumpInsn(IFGE, labelElse); <span class="hljs-comment">// 反转判断val</span><span class="hljs-comment">// 三元运算符中前面的表达式</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>); mv.visitInsn(INEG);Label labelIfEnd = <span class="hljs-keyword">new</span> Label(); <span class="hljs-comment">// if...else之后的标签</span>mv.visitJumpInsn(GOTO, labelIfEnd); <span class="hljs-comment">// 结束，跳转</span>mv.visitLabel(labelElse);<span class="hljs-comment">// 三元运算符后面的表达式</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>);mv.visitLabel(labelIfEnd);<span class="hljs-comment">// 保存到endVal中</span>mv.visitVarInsn(ISTORE, <span class="hljs-number">1</span>);<span class="hljs-comment">// 计算 endVal * 2</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>);mv.visitInsn(ICONST_2);mv.visitInsn(IMUL);mv.visitInsn(IRETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);</code></pre><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>循环结构都比较类似，都是流程返回到之前的代码部分。先从最简单的<code>while</code>语句开始：</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环的流程类似与这样：</p><image src="/resources/2021110601/while.svg" type="image/svg+xml" width=400 height=400/> <p>接下来用一段Java代码写一个例子：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(sum &lt; <span class="hljs-number">1000</span>) &#123;sum += ++now;&#125;<span class="hljs-keyword">return</span> now;&#125;</code></pre><p>这是用字节码的方式写入：</p><pre><code class="hljs Java">mv.visitInsn(ICONST_0);mv.visitVarInsn(ISTORE, <span class="hljs-number">0</span>); <span class="hljs-comment">// 存入sum</span>mv.visitInsn(ICONST_0);mv.visitVarInsn(ISTORE, <span class="hljs-number">1</span>); <span class="hljs-comment">// 存入now</span>Label labelCondition = <span class="hljs-keyword">new</span> Label();mv.visitLabel(labelCondition); <span class="hljs-comment">// 循环条件</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// 加载sum</span>mv.visitIntInsn(SIPUSH, <span class="hljs-number">1000</span>);Label labelEnd = <span class="hljs-keyword">new</span> Label();mv.visitJumpInsn(IF_ICMPGE, labelEnd); <span class="hljs-comment">// 反转比较sum &lt; 1000</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>);mv.visitIincInsn(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>);mv.visitInsn(IADD);mv.visitVarInsn(ISTORE, <span class="hljs-number">0</span>);mv.visitJumpInsn(GOTO, labelCondition); <span class="hljs-comment">// 流程跳转回到条件处</span>mv.visitLabel(labelEnd);mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>);mv.visitInsn(IRETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);</code></pre><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><p>类似于while，<code>do...while</code>结构也用了和它基本一致的思路，只不过是循环条件写到了后面，并且循环条件<strong>不用反转</strong>：</p><image src="/resources/2021110601/do-while.svg" type="image/svg+xml" width=400 height=400/><p>do…while循环就不再举例子了，下面来看看for循环。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><code>for</code>循环有两种：普通的for语句和<code>for-each</code>语句。普通的for循环语句在定义时包括了三条语句：一条初始化、一条条件和一条循环结束执行语句。它的流程类似于while多加了一些部分：</p><image src="/resources/2021110601/for.svg" type="image/svg+xml" width=400 height=400/><p>接下来就是一个例子，使用for循环：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)sum += i;<span class="hljs-keyword">return</span> sum;&#125;</code></pre><p>在字节码里面要这样写：</p><pre><code class="hljs Java">mv.visitInsn(ICONST_0);mv.visitVarInsn(ISTORE, <span class="hljs-number">0</span>); <span class="hljs-comment">// 存入sum</span>mv.visitInsn(ICONST_0);mv.visitVarInsn(ISTORE, <span class="hljs-number">1</span>); <span class="hljs-comment">// int i = 0，for循环初始化语句</span>Label labelCondition = <span class="hljs-keyword">new</span> Label();mv.visitLabel(labelCondition);mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// i</span>mv.visitIntInsn(BIPUSH, <span class="hljs-number">100</span>); <span class="hljs-comment">// 100</span>Label labelEnd = <span class="hljs-keyword">new</span> Label();mv.visitJumpInsn(IF_ICMPGE, labelEnd); <span class="hljs-comment">// i &lt; 100的反转</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// sum</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// i</span>mv.visitInsn(IADD);mv.visitVarInsn(ISTORE, <span class="hljs-number">0</span>);mv.visitIincInsn(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// i++， for循环结束语句</span>mv.visitJumpInsn(GOTO, labelCondition); <span class="hljs-comment">// 回到条件</span>mv.visitLabel(labelEnd);mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>);mv.visitInsn(IRETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);</code></pre><p>另一种for循环，即for-each循环，它的实现和for循环很不一样。</p><p>for-each需要一个<code>Iterable</code>的对象才能使用，它的原理就是通过<code>iterator</code>进行迭代。下面这两种形式是等价的：</p><pre><code class="hljs Java"><span class="hljs-comment">// 设 T extends Iterable&lt;E&gt;</span>T set = ...;<span class="hljs-comment">// for-each写法</span><span class="hljs-keyword">for</span>(E element : set) &#123;...&#125;<span class="hljs-comment">// 等价写法</span>Iterator&lt;E&gt; iterator = set.iterator();<span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;E element = iterator.next();...&#125;</code></pre><p>也就是说，<strong>for-each本质是while循环</strong>。由于没有讲泛型，所以就不细讲此处。</p><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>我相信你已经把上面的例子都跑了一遍（没跑也没事，我默认已经跑了），可是这些东西在你尝试运行它们的时候都会报错。它们报的错无一例外都是<code>VerifyError</code>，这是出了什么毛病？这就有关于栈帧了。</p><p>Java中执行方法时，JVM会分配给当前线程一个栈帧，栈帧和方法绑定，它的内部就是现在的局部变量表和操作栈数据（这在第三篇文章说过）。栈帧内的局部变量表大小和操作栈大小来自<code>visitMaxs</code>。栈帧在方法开始执行时创建，在方法返回时（包括抛出异常）销毁。</p><p>但是在类文件中，我们不能保证一个类它的数据是不是异常的——有可能它规定的栈帧局部变量表或者操作栈小于真正运行时的大小。所以Java引入了类的<code>验证阶段</code>，检查类内部数据。其中有一项就是检查方法栈帧——检查方法字节码是否正确排序、变量类型是不是一致等。但是这种验证很耗费时间，所以JVM验证器引入了<code>StackMapTable</code>进行辅助，这样就能在线性的运行下检查。但是每一行都加入<code>栈帧映射（stack map frame）</code>实在是太浪费空间了，所以JVM做了优化，规定每个跳转目标之后都必须有一个映射用于表示栈帧变化。</p><p>栈帧映射中并不是一个真的局部变量表和操作栈类型表，它是以一种和前面的映射<strong>比较</strong>的方式保存——比如这个映射要比前面的映射少两个元素等。第一个映射前面并没有别的映射，所以它和<strong>空的操作栈与参数列表</strong>组成的局部变量表的栈帧比较。</p><p>（可以看看<a href="https://stackoverflow.com/questions/25109942/what-is-a-stack-map-frame">https://stackoverflow.com/questions/25109942/what-is-a-stack-map-frame</a>下面的评论）</p><p>所以引发异常的真正原因我们找到了——看来验证器没有检查到方法内部跳转指令后的栈帧映射，导致了验证失败抛出异常。</p><p>那么怎么写入栈帧映射呢？</p><p><code>MethodVisitor</code>提供了一个方法，叫<code>visitFrame</code>。它就是用于写入当前栈帧数据变化的方法。这个方法需要在<strong>每个跳转目标的visitLabel</strong>后面去写，不是用于跳转的标签不需要visitFrame。</p><p>visitFrame的方法原型如下：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitFrame</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> type,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> numLocal,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> Object[] local,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> numStack,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">final</span> Object[] stack)</span></span></code></pre><p>它有5个参数，指明了这个映射和前面的映射的比较方式和数据。先讲后面的参数，最后再讲第一个参数。</p><p>第三个参数是一个代表局部变量变化的一个数组，长度应该为第二个参数。数组内的取值分为这几种：</p><ol><li><p>如果变量是一个没有初始化的对象，那么这个值是指向这个对象<code>NEW</code>字节码的标签对象。</p></li><li><p>如果变量是this并且在调用父类构造函数之前被调用，这个值是<code>UNINITIALIZED_THIS</code>。</p></li><li><p>如果变量类型不是基本类型，值就应该是它的类的全限定名/描述符字符串。</p></li><li><p>如果是基本类型，那么取值是固定的：int用<code>INTEGER</code>代替，float用<code>FLOAT</code>代替，long用<code>LONG</code>代替，double用<code>DOUBLE</code>代替，空用<code>NULL</code>代替。long和double即使需要占两个槽位也不需要写两遍，byte、short、char、boolean要用<code>INTEGER</code>代替。</p></li><li><p>如果这个局部变量槽位上暂时是空位（注意不是空对象），用<code>TOP</code>代替。</p></li></ol><p>第五个参数类似，是表示操作栈变化的一个数组，长度是第四个参数。</p><p>下面是重点——第一个参数的意义。它的不同取值和意义如下：</p><ol><li><p><code>F_NEW</code>，只能在Java 6使用（或者ClassWriter被指定扩展栈帧映射），它的写入和之后的版本不一样（其实是类似F_FULL，写入和之前的栈帧信息无关）。这篇文章不会介绍Java 6的栈帧映射写入。</p></li><li><p><code>F_SAME</code>，代表这里的局部变量表和之前的栈帧信息相比没有变化，numLocal和numStack为0，两个数组都为null。（即使不是null也不会写入）</p></li><li><p><code>F_SAME1</code>，代表这里的局部变量表和之前的栈帧信息一样，而操作栈上有一个变量。numLocal是0，numStack是1，local是null，stack是一个数组，内部只有一个元素，代表现在栈上对象的类型。</p></li><li><p><code>F_APPEND</code>，代表现在的局部变量表和之前的栈帧信息一样，但是会多出1-3个新的局部变量。numLocal是新增加的局部变量的数量，local是一个长度为numLocal的数组，存储新增加的局部变量的类型。numStack是0，stack为null。</p></li><li><p><code>F_CHOP</code>，代表现在的局部变量表要比之前的栈帧信息少1-3个局部变量。numLocal就是局部变量缺少的数量，numStack是0，local和stack都是null。</p></li><li><p><code>F_FULL</code>，这代表现在的栈帧和之前的栈帧没有关系，相当于复写了栈帧的信息。numLocal是局部变量数量，local是局部变量类型数组，numStack是操作栈深度，stack是操作栈类型数组。当现在的栈帧比之前的栈帧多/少3个以上的局部变量，或者操作栈上有变量（除非局部变量表不变且栈深度为1可以使用F_SAME1对应），都需要用这个标志重新写入。</p></li></ol><p>在编译时，编译器会尽量减少F_FULL的出现次数，保证类文件不会因为额外栈帧信息变得臃肿。在我们自己生成字节码时，也尽量不要用F_FULL。</p><p>接下来，我们来回顾我们报错的代码：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)sum += i;<span class="hljs-keyword">return</span> sum;&#125;</code></pre><p>按照之前的代码，我们要在每个跳转目标上加上栈帧信息：</p><pre><code class="hljs Java"><span class="hljs-comment">// 初始栈帧信息 局部变量表 []</span>mv.visitInsn(ICONST_0);mv.visitVarInsn(ISTORE, <span class="hljs-number">0</span>); <span class="hljs-comment">// 存入sum</span>mv.visitInsn(ICONST_0);mv.visitVarInsn(ISTORE, <span class="hljs-number">1</span>); <span class="hljs-comment">// int i = 0，for循环初始化语句</span>Label labelCondition = <span class="hljs-keyword">new</span> Label();mv.visitLabel(labelCondition);<span class="hljs-comment">// 这个标签是跳转目标，加入visitFrame</span><span class="hljs-comment">// 这里的栈帧信息 局部变量表 [I I] 操作栈 []</span>mv.visitFrame(F_APPEND, <span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Object[] &#123; INTEGER, INTEGER &#125;, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// i</span>mv.visitIntInsn(BIPUSH, <span class="hljs-number">100</span>); <span class="hljs-comment">// 100</span>Label labelEnd = <span class="hljs-keyword">new</span> Label();mv.visitJumpInsn(IF_ICMPGE, labelEnd); <span class="hljs-comment">// i &lt; 100的反转</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// sum</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// i</span>mv.visitInsn(IADD);mv.visitVarInsn(ISTORE, <span class="hljs-number">0</span>);mv.visitIincInsn(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// i++， for循环结束语句</span>mv.visitJumpInsn(GOTO, labelCondition); <span class="hljs-comment">// 回到条件</span>mv.visitLabel(labelEnd);<span class="hljs-comment">// 跳转目标，加入栈帧信息</span><span class="hljs-comment">// 这里的栈帧信息 局部变量表 [I] 操作栈 []</span>mv.visitFrame(F_CHOP, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>);mv.visitInsn(IRETURN);mv.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);</code></pre><p>为了方便用户操作，asm自己加了一个计算栈帧信息的标识：<code>COMPUTE_FRAMES</code>。在ClassWriter构造函数中使用。</p><pre><code class="hljs Java">ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</code></pre><p>使用这个后，所有的visitFrame和visitMaxs都不需要我们自己写。ClassWriter会根据字节码推断栈帧信息等并写入，代价是增加近一倍的运行时间。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>下面，我们将用字节码写出一个简单的阶乘程序，使用for循环计算阶乘并且用if判断是否溢出。对应的Java代码如下：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">secureFactorial</span><span class="hljs-params">(<span class="hljs-keyword">long</span> number)</span> </span>&#123;<span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= number; i++) &#123;result *= i;<span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// Overflow</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Overflow!&quot;</span>);&#125;<span class="hljs-keyword">return</span> result;&#125;</code></pre><p>首先计划一下程序标签的位置：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">secureFactorial</span><span class="hljs-params">(<span class="hljs-keyword">long</span> number)</span> </span>&#123;<span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">/* labelCondition*/</span> i &lt;= number; i++) &#123;result *= i;<span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// Overflow</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Overflow!&quot;</span>);<span class="hljs-comment">/* labelNoError */</span>&#125;<span class="hljs-comment">/* labelEnd */</span><span class="hljs-keyword">return</span> result;&#125;</code></pre><p>下面我们用不开启COMPUTE_FRAMES的ClassWriter进行写入：</p><pre><code class="hljs Java"><span class="hljs-comment">// 初始帧 局部变量 [J]</span>mv.visitInsn(LCONST_1);mv.visitVarInsn(LSTORE, <span class="hljs-number">2</span>); <span class="hljs-comment">// 存入result</span>mv.visitInsn(ICONST_1);mv.visitVarInsn(ISTORE, <span class="hljs-number">4</span>); <span class="hljs-comment">// 存入i</span>Label labelCondition = <span class="hljs-keyword">new</span> Label();mv.visitLabel(labelCondition);<span class="hljs-comment">// 栈帧信息 局部变量 [J J I] 操作栈 []</span>mv.visitFrame(F_APPEND, <span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Object[]&#123; LONG, INTEGER &#125;, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ILOAD, <span class="hljs-number">4</span>); <span class="hljs-comment">// i</span>mv.visitInsn(I2L); <span class="hljs-comment">// 拉长比较</span>mv.visitVarInsn(LLOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// number</span>mv.visitInsn(LCMP);Label labelEnd = <span class="hljs-keyword">new</span> Label();mv.visitJumpInsn(IFGT, labelEnd); <span class="hljs-comment">// 反向比较i &lt;= number</span>mv.visitVarInsn(LLOAD, <span class="hljs-number">2</span>); <span class="hljs-comment">// result</span>mv.visitVarInsn(ILOAD, <span class="hljs-number">4</span>); <span class="hljs-comment">// i</span>mv.visitInsn(I2L); <span class="hljs-comment">// 拉长计算</span>mv.visitInsn(LMUL); <span class="hljs-comment">// 相乘</span>mv.visitVarInsn(LSTORE, <span class="hljs-number">2</span>); <span class="hljs-comment">// 存入result</span>mv.visitVarInsn(LLOAD, <span class="hljs-number">2</span>); <span class="hljs-comment">// result</span>mv.visitInsn(LCONST_0);mv.visitInsn(LCMP);Label labelNoError = <span class="hljs-keyword">new</span> Label();mv.visitJumpInsn(IFGE, labelNoError); <span class="hljs-comment">// 反向比较 result &lt; 0</span><span class="hljs-comment">// 创建异常对象抛出</span>mv.visitTypeInsn(NEW, <span class="hljs-string">&quot;java/lang/IllegalArgumentException&quot;</span>);mv.visitInsn(DUP);mv.visitLdcInsn(<span class="hljs-string">&quot;Overflow!&quot;</span>);mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/IllegalArgumentException&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitInsn(ATHROW);mv.visitLabel(labelNoError);<span class="hljs-comment">// 栈帧信息 局部变量 [J J I] 操作栈 []</span>mv.visitFrame(F_SAME, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);mv.visitIincInsn(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// i++</span>mv.visitJumpInsn(GOTO, labelCondition); <span class="hljs-comment">// 回到判断条件</span>mv.visitLabel(labelEnd);<span class="hljs-comment">// 栈帧信息 局部变量 [J J] 操作栈 []</span>mv.visitFrame(F_CHOP, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(LLOAD, <span class="hljs-number">2</span>); <span class="hljs-comment">// result</span>mv.visitInsn(LRETURN); <span class="hljs-comment">// 返回</span>mv.visitMaxs(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 最大操作栈深度4（两个long比较），局部变量5个槽位</span></code></pre><p>然后我们对生成的类进行测试：</p><pre><code class="hljs Java">Class&lt;?&gt; generated = <span class="hljs-keyword">new</span> Loader().defineClassNow(<span class="hljs-string">&quot;Test&quot;</span>, cw.toByteArray());System.out.println(generated.getMethod(<span class="hljs-string">&quot;secureFactorial&quot;</span>, <span class="hljs-keyword">long</span>.class).invoke(<span class="hljs-keyword">null</span>, <span class="hljs-number">20</span>));System.out.println(generated.getMethod(<span class="hljs-string">&quot;secureFactorial&quot;</span>, <span class="hljs-keyword">long</span>.class).invoke(<span class="hljs-keyword">null</span>, <span class="hljs-number">50</span>));</code></pre><p>得到下面的输出：</p><pre><code class="hljs shell">2432902008176640000Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetExceptionat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)at java.base/java.lang.reflect.Method.invoke(Method.java:568)at io.github.nickid2018.asmtest.ASMMain.main(ASMMain.java:60)Caused by: java.lang.IllegalArgumentException: Overflow!at Test.secureFactorial(Unknown Source)... 5 more</code></pre><p>这就代表成功了！</p><p>全部源代码：<a href="https://paste.ubuntu.com/p/Gyhn3wHMQ3/">https://paste.ubuntu.com/p/Gyhn3wHMQ3/</a></p><hr><p>下一期：Java ASM详解：MethodVisitor与Opcode（四）其他流程结构</p><p>这篇文章一共讲了22个字节码，加上以前讲过的一共186个。</p><p>有错误可以在评论区指出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前的文章中，我们已经知道了基础的字节码。但是，这些字节码只能构建起一个简单的结构，不能实现循环条件等高级结构。这篇文章将讨论关于程序流程结构的字节码。&lt;/p&gt;
&lt;h2 id=&quot;标签&quot;&gt;&lt;a href=&quot;#标签&quot; class=&quot;headerlink&quot; title=&quot;标签&quot;</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="ASM" scheme="http://nickid2018.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步</title>
    <link href="http://nickid2018.github.io/2021/10/05/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E5%92%8COpcode%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E6%AE%B5%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>http://nickid2018.github.io/2021/10/05/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E5%92%8COpcode%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E6%AE%B5%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%90%8C%E6%AD%A5/</id>
    <published>2021-10-05T12:22:46.000Z</published>
    <updated>2021-11-03T15:50:55.454Z</updated>
    
    <content type="html"><![CDATA[<p>上次讲过了操作栈与数值运算操作，这篇专栏主要讲ASM中有关于类型、数组与方法调用的字节码。</p><p><em>P.S.ASM库已经更新到了9.2版本，可以试试解析Java 18的类了。</em></p><h2 id="有关于类型的字节码"><a href="#有关于类型的字节码" class="headerlink" title="有关于类型的字节码"></a>有关于类型的字节码</h2><p>有关于类型的字节码都是用visitTypeInsn进行写入的。这类字节码共有4个：NEW，ANEWARRAY，INSTANCEOF和CHECKCAST。ANEWARRAY在之后的数组字节码里面会仔细去讲。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><pre><code class="hljs Java">输入：无输出：一个指定类型的对象方法：visitTypeInsn参数：类型使用范例：mv.visitTypeInsn(NEW, <span class="hljs-string">&quot;java/lang/Object&quot;</span>);</code></pre><p>NEW只进行创建对象，不负责调用构造函数，所以内部字段的值都为默认值。调用构造函数必须用invokespecial字节码进行调用（下文）。</p><p>在调用这个字节码时，如果指向的类没有初始化，就它的调用静态初始化函数&lt;clinit&gt;。如果在初始化中发生异常就会抛出错误。如果目标类的类格式有误，则抛出异常。如果目标类时抽象的，则抛出<code>InstantiationError</code>。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><pre><code class="hljs Java">输入：一个对象输出：布尔值，代表是否为指定类的对象（栈上表示为一个四字节数据）方法：visitTypeInsn参数：类型（对于数组是描述符）使用范例：  mv.visitTypeInsn(INSTANCEOF, <span class="hljs-string">&quot;java/lang/String&quot;</span>);</code></pre><p>instanceof用于检查对象是否为这个类型的实例，如果是则返回boolean值true，即操作栈上的一个int数据1；如果不是就返回0。</p><p>对于null对象，该字节码永远返回0。</p><h3 id="checkcast"><a href="#checkcast" class="headerlink" title="checkcast"></a>checkcast</h3><pre><code class="hljs Java">输入：一个对象输出：类型检查后的对象方法：visitTypeInsn参数：类型（对于数组是描述符）使用范例：  mv.visitTypeInsn(CHECKCAST, <span class="hljs-string">&quot;java/io/InputStream&quot;</span>);</code></pre><p>checkcast用于检查对象的类型，类似于instanceof。但不同的是，如果无法将对象转换为指定类型，该字节码会抛出ClassCastException。这个字节码经常见于泛型中。</p><p>加入这个字节码通常是为了指定对象是某个类型好让验证器验证，在局部变量无法得知确切类型时必须加入此字节码保证验证通过（运行时报错就是另一回事了）。</p><p>下面是这三个字节码组合的例子：</p><p>要生成的Java代码如下：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">testTypeASM</span><span class="hljs-params">()</span> </span>&#123;  Object object = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-keyword">boolean</span> bool = object <span class="hljs-keyword">instanceof</span> String;  <span class="hljs-keyword">return</span> (String) object;&#125;</code></pre><p>对应的生成这段代码的字节码程序如下：</p><pre><code class="hljs Java"><span class="hljs-comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span><span class="hljs-comment">// ---- 第一行语句 -----</span>mv.visitTypeInsn(NEW, <span class="hljs-string">&quot;java/lang/String&quot;</span>);mv.visitInsn(DUP); <span class="hljs-comment">// 栈上复制一份对象</span>mv.visitLdcInsn(<span class="hljs-string">&quot;Hello&quot;</span>);mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/String&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 执行构造函数</span>mv.visitVarInsn(ASTORE, <span class="hljs-number">0</span>); <span class="hljs-comment">// 存在局部变量表0号位</span><span class="hljs-comment">// ---- 第二行语句 -----</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// 取出局部变量object</span>mv.visitTypeInsn(INSTANCEOF, <span class="hljs-string">&quot;java/lang/String&quot;</span>);mv.visitVarInsn(ISTORE, <span class="hljs-number">1</span>);<span class="hljs-comment">// ---- 第三行语句 -----</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitTypeInsn(CHECKCAST, <span class="hljs-string">&quot;java/lang/String&quot;</span>); <span class="hljs-comment">// 注：此处可以不加这个CHECKCAST，因为局部变量表已知是String。如果局部变量表无法判断是否真的为String且没有加入这个语句，在验证时下方ARETURN字节码会报错</span>mv.visitInsn(ARETURN);<span class="hljs-comment">// ---- 结束 ----</span>mv.visitMaxs(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);mv.visitEnd();</code></pre><h2 id="数组操作的字节码"><a href="#数组操作的字节码" class="headerlink" title="数组操作的字节码"></a>数组操作的字节码</h2><p>数组操作的字节码一共有20个，其中加载指令8个，存储指令8个，三个创建还有一个获取数组长度的字节码。</p><h3 id="newarray"><a href="#newarray" class="headerlink" title="newarray"></a>newarray</h3><pre><code class="hljs Java">输入：<span class="hljs-keyword">int</span>，代表数组长度输出：指定长度的数组方法：visitIntInsn参数：数组的类型，有<span class="hljs-number">8</span>个常量值分别代表了不同的值类型使用范例：  mv.visitIntInsn(NEWARRAY, T_INT);</code></pre><p>和newarray字节码用于创建基本类型的数组，它的参数代表了它的类型，在Opcodes类中一共有8个：T_BOOLEAN（boolean），T_CHAR（char），T_FLOAT（float），T_DOUBLE（double），T_BYTE（byte），T_SHORT（short），T_INT（int）和T_LONG（long）。</p><p>如果数组长度小于0，这个字节码会抛出<code>NegativeArraySizeException</code>。</p><h3 id="anewarray"><a href="#anewarray" class="headerlink" title="anewarray"></a>anewarray</h3><pre><code class="hljs Java">输入：<span class="hljs-keyword">int</span>，代表数组长度输出：指定长度的数组方法：visitTypeInsn参数：类型使用范例：  mv.visitTypeInsn(ANEWARRAY, <span class="hljs-string">&quot;java/lang/String&quot;</span>);</code></pre><p>基本类型的数组由newarray创建，而不是基本类型的数组由anewarray创建。</p><p>和newarray一样，如果数组长度小于0，这个字节码会抛出<code>NegativeArraySizeException</code>。</p><h3 id="multianewarray"><a href="#multianewarray" class="headerlink" title="multianewarray"></a>multianewarray</h3><pre><code class="hljs Java">输入：一系列的<span class="hljs-keyword">int</span>，代表多维数组中每一维的长度输出：多维数组方法：visitMultiANewArrayInsn参数：描述符和维度使用范例：  mv.visitMultiANewArrayInsn(<span class="hljs-string">&quot;[[Ljava/lang/String;&quot;</span>, <span class="hljs-number">2</span>);  mv.visitMultiANewArrayInsn(<span class="hljs-string">&quot;[[[I&quot;</span>, <span class="hljs-number">3</span>);</code></pre><p>创建一个多维数组，多维数组的描述符要与第二个参数维度相匹配。和另两个字节码相同，如果多维数组任意一维的长度小于0，这个字节码就会抛出<code>NegativeArraySizeException</code>。</p><p>下面是使用这三个字节码的例子：</p><p>Java代码：</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] arrayInt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span>[][] multi2Int = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>][<span class="hljs-number">2</span>];String[] strings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">30</span>];String[][] multiStrings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">127</span>][<span class="hljs-number">128</span>];</code></pre><p>生成这些代码的字节码程序：</p><pre><code class="hljs Java"><span class="hljs-comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span><span class="hljs-comment">// new int[10]</span>mv.visitIntInsn(BIPUSH, <span class="hljs-number">10</span>);mv.visitIntInsn(NEWARRAY, T_INT);mv.visitVarInsn(ASTORE, <span class="hljs-number">0</span>);<span class="hljs-comment">// new int[100][2]</span>mv.visitIntInsn(BIPUSH, <span class="hljs-number">100</span>);mv.visitInsn(ICONST_2);mv.visitMultiANewArrayInsn(<span class="hljs-string">&quot;[[I&quot;</span>, <span class="hljs-number">2</span>);mv.visitVarInsn(ASTORE, <span class="hljs-number">1</span>);<span class="hljs-comment">// new String[30]</span>mv.visitIntInsn(BIPUSH, <span class="hljs-number">30</span>);mv.visitTypeInsn(ANEWARRAY, <span class="hljs-string">&quot;java/lang/String&quot;</span>);mv.visitVarInsn(ASTORE, <span class="hljs-number">2</span>);<span class="hljs-comment">// new String[127][128]</span>mv.visitIntInsn(BIPUSH, <span class="hljs-number">127</span>);mv.visitIntInsn(SIPUSH, <span class="hljs-number">128</span>);mv.visitMultiANewArrayInsn(<span class="hljs-string">&quot;[[Ljava/lang/String;&quot;</span>, <span class="hljs-number">2</span>);mv.visitVarInsn(ASTORE, <span class="hljs-number">3</span>);</code></pre><p>在创建数组时，如果是一维数组就用newarray或anewarray。multianewarray也能创建一维数组，但是使用上面的两个更加高效。</p><h3 id="arraylength"><a href="#arraylength" class="headerlink" title="arraylength"></a>arraylength</h3><pre><code class="hljs Java">输入：数组输出：数组长度方法：visitInsn参数：无使用范例：mv.visitInsn(ARRAYLENGTH);</code></pre><p>获取数组的长度，返回int。如果数组输入为null，抛出空指针异常。</p><h3 id="xaload"><a href="#xaload" class="headerlink" title="xaload"></a><em>x</em>aload</h3><p>x=a,b,c,d,f,i,l,s, 其中b同时负责了byte和boolean</p><pre><code class="hljs Java">输入：数组，<span class="hljs-keyword">int</span>类型的下标输出：数组元素方法：visitInsn参数：无使用范例：mv.visitInsn(BALOAD);</code></pre><p>xaload的作用是从数组指定下标取元素。如果下标超过数组长度，抛出<code>ArrayIndexOutOfBoundsException</code>。对于多维数组的提取元素方式类似下面：</p><pre><code class="hljs Java"><span class="hljs-comment">// Java 代码：</span><span class="hljs-comment">// 设int[][] multi = new int[10][20];位于局部变量表0位</span><span class="hljs-keyword">return</span> multi[<span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">// 字节码：</span><span class="hljs-comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitInsn(ICONST_1);mv.visitInsn(AALOAD);mv.visitInsn(ICONST_4);mv.visitInsn(IALOAD);mv.visitInsn(IRETURN);</code></pre><h3 id="xastore"><a href="#xastore" class="headerlink" title="xastore"></a><em>x</em>astore</h3><p>x=a,b,c,d,f,i,l,s, 其中b同时负责了byte和boolean</p><pre><code class="hljs Java">输入：数组，<span class="hljs-keyword">int</span>类型的下标，一个变量输出：无方法：visitInsn参数：无使用范例：mv.visitInsn(BASTORE);</code></pre><p>将对象存入数组指定下标。如果下标超过数组长度，抛出<code>ArrayIndexOutOfBoundsException</code>。对于多维数组，存储对象需要和xaload一起配合。</p><pre><code class="hljs Java"><span class="hljs-comment">// Java 代码：</span><span class="hljs-comment">// 设int[][] multi = new int[10][20];位于局部变量表0位</span>multi[<span class="hljs-number">1</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">20</span>;<span class="hljs-comment">// 字节码：</span><span class="hljs-comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitInsn(ICONST_1);mv.visitInsn(AALOAD);mv.visitInsn(ICONST_4);mv.visitIntInsn(BIPUSH, <span class="hljs-number">20</span>);mv.visitInsn(IASTORE);</code></pre><h2 id="操作字段的字节码"><a href="#操作字段的字节码" class="headerlink" title="操作字段的字节码"></a>操作字段的字节码</h2><p>在代码中我们经常会调用类中的字段，例如<code>System.out</code>。Java提供了四个字节码用于访问和修改字段。</p><h3 id="getfield"><a href="#getfield" class="headerlink" title="getfield"></a>getfield</h3><pre><code class="hljs Java">输入：一个对象输出：对应字段的值方法：visitFieldInsn参数：字段所处的类、字段名、字段描述符使用范例：mv.visitFieldInsn(GETFIELD, <span class="hljs-string">&quot;org/objectweb/asm/MethodVisitor&quot;</span>, <span class="hljs-string">&quot;mv&quot;</span>, <span class="hljs-string">&quot;Lorg/objectweb/asm/MethodVisitor;&quot;</span>);</code></pre><p>getfield用于获取非静态字段的值。如果它作用目标是一个静态字段，则在类连接验证时抛出<code>IncompatibleClassChangeError</code>。</p><p>如果输入的对象是null，这个字节码会在运行时抛出空指针异常。</p><p>这个字节码不能调用数组的length字段，在编译的时候length字段会自行转变成arraylength字节码。</p><h3 id="getstatic"><a href="#getstatic" class="headerlink" title="getstatic"></a>getstatic</h3><pre><code class="hljs Java">输入：无输出：对应字段的值方法：visitFieldInsn参数：字段所处的类、字段名、字段描述符使用范例： mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);</code></pre><p>getstatic用于获取静态字段的值。如果它作用目标是一个非静态字段，则在类连接验证时抛出<code>IncompatibleClassChangeError</code>。</p><h3 id="putfield"><a href="#putfield" class="headerlink" title="putfield"></a>putfield</h3><pre><code class="hljs Java">输入：一个对象、准备修改成的对象输出：无方法：visitFieldInsn参数：字段所处的类、字段名、字段描述符使用范例： mv.visitFieldInsn(PUTFIELD, <span class="hljs-string">&quot;org/objectweb/asm/MethodVisitor&quot;</span>, <span class="hljs-string">&quot;mv&quot;</span>, <span class="hljs-string">&quot;Lorg/objectweb/asm/MethodVisitor;&quot;</span>);</code></pre><p>putfield用于修改非静态字段的值。如果它作用目标是一个静态字段，则在类连接验证时抛出<code>IncompatibleClassChangeError</code>。</p><p>如果输入的对象是null，这个字节码会在运行时抛出空指针异常。</p><p>对于final字段，如果不是在初始化对象时修改（构造函数中），那么就会抛出<code>IllegalAccessError</code>。</p><h3 id="putstatic"><a href="#putstatic" class="headerlink" title="putstatic"></a>putstatic</h3><pre><code class="hljs Java">输入：准备修改成的对象输出：无方法：visitFieldInsn参数：字段所处的类、字段名、字段描述符使用范例： mv.visitFieldInsn(PUTSTATIC, <span class="hljs-string">&quot;io/github/nickid2018/Constants&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>);</code></pre><p>putstatic用于修改静态字段的值。如果它作用目标是一个非静态字段，则在类连接验证时抛出<code>IncompatibleClassChangeError</code>。</p><p>对于final字段，如果不是在类初始化时修改（&lt;clinit&gt;中），那么就会抛出<code>IllegalAccessError</code>。</p><h2 id="调用方法的字节码"><a href="#调用方法的字节码" class="headerlink" title="调用方法的字节码"></a>调用方法的字节码</h2><p>调用方法的字节码共有五个：invokevirtual，invokespecial，invokestatic，invokeinterface和invokedynamic。invokedynamic使用了BSM（BootStrap Method），讲解起来很复杂，所以这个要单独分出来一篇文章去讲。这篇文章主要讨论前四个。</p><h3 id="invokevirtual"><a href="#invokevirtual" class="headerlink" title="invokevirtual"></a>invokevirtual</h3><pre><code class="hljs Java">输入：一个对象，传入参数输出：与方法返回值有关方法：visitMethodInsn参数：方法所在的类，方法名，方法描述符，固定值<span class="hljs-keyword">false</span>使用范例： mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);</code></pre><p>这个字节码用于调用实例方法：如果对象是子类的对象且子类复写了这个方法，则调用子类的方法；如果对象就是该类的直接对象或者对象所属子类没有复写这个方法，就调用现在类的方法。</p><p>在编译时，如果子类调用了父类的方法且子类没有实现此方法，那么方法所在的类要写为父类。如果使用<code>super</code>，要用invokespecial调用（下文）。</p><p>如果方法调用目标是静态的，在连接验证时会抛出<code>IncompatibleClassChangeError</code>。</p><p>如果方法调用目标是抽象的，并且在继承树上没有任何实现此方法的类，在调用时会抛出<code>AbstractMethodError</code>。</p><p>如果方法调用目标是抽象的，而继承树上由多个实现此方法的类，且这些方法都是可被选中成为调用目标的方法（比如一个类继承于一个抽象类，又实现了两个接口，两个接口中都有一个同样的default方法可作为抽象类中抽象方法的实现目标），这时此字节码会抛出<code>IncompatibleClassChangeError</code>。</p><p>如果方法调用目标是native的，且没有任何JNI连接查询到这个方法和哪个C函数相连接，这时这个字节码抛出<code>UnsatisfiedLinkError</code>。</p><h3 id="invokespecial"><a href="#invokespecial" class="headerlink" title="invokespecial"></a>invokespecial</h3><pre><code class="hljs Java">输入：一个对象，传入参数输出：与方法返回值有关方法：visitMethodInsn参数：方法所在的类，方法名，方法描述符，固定值<span class="hljs-keyword">false</span>使用范例： mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-string">&quot;equals&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="hljs-keyword">false</span>);</code></pre><p>invokespecial类似于invokevirtual，但不同的是，它和调用方法的对象的类型无关：它的方法调用对象就是字节码内部标定的方法，如果这个类找不到就寻找直接超类的方法，而不是像invokevirtual要考虑继承树所有的方法。</p><p>这个方法经常在构造函数中看到，因为无论什么类都需要有一个构造函数，而构造函数内部必须自动调用父类构造函数。</p><p>一个默认的构造函数类似于下面：</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>();  &#125;&#125;</code></pre><p>在生成类时，如果没有自定义其他构造函数，就要加上这个默认构造函数：</p><pre><code class="hljs Java">ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(<span class="hljs-number">0</span>);cw.visit(V17, ACC_PUBLIC + ACC_SUPER, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-keyword">null</span>);MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>); <span class="hljs-comment">// 加载自身(this)</span>mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 调用父类构造函数</span>mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);mv.visitEnd();cw.visitEnd();</code></pre><h3 id="invokestatic"><a href="#invokestatic" class="headerlink" title="invokestatic"></a>invokestatic</h3><pre><code class="hljs Java">输入：一个对象，传入参数输出：与方法返回值有关方法：visitMethodInsn参数：方法所在的类，方法名，方法描述符，固定值<span class="hljs-keyword">false</span>使用范例： mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/Math&quot;</span>, <span class="hljs-string">&quot;sin&quot;</span>, <span class="hljs-string">&quot;(D)D&quot;</span>, <span class="hljs-keyword">false</span>);</code></pre><p>invokestatic用于调用静态方法，如果调用目标不是个静态方法，抛出<code>IncompatibleClassChangeError</code>。</p><p>和invokevirtual一样，如果目标是个native方法而JNI找不到连接的C函数，该字节码抛出<code>UnsatisfiedLinkError</code>。</p><h3 id="invokeinterface"><a href="#invokeinterface" class="headerlink" title="invokeinterface"></a>invokeinterface</h3><pre><code class="hljs Java">输入：一个对象，传入参数输出：与方法返回值有关方法：visitMethodInsn参数：方法所在的类，方法名，方法描述符，固定值<span class="hljs-keyword">true</span>使用范例： mv.visitMethodInsn(INVOKEINTERFACE, <span class="hljs-string">&quot;java/util/Set&quot;</span>, <span class="hljs-string">&quot;clear&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">true</span>);</code></pre><p>这个字节码类似于invokevirtual，异常情况的处理也和它类似。它用于调用接口方法，而不是像invokevirtual的实例方法。</p><h2 id="抛出异常的字节码：athrow"><a href="#抛出异常的字节码：athrow" class="headerlink" title="抛出异常的字节码：athrow"></a>抛出异常的字节码：athrow</h2><pre><code class="hljs Java">输入：一个Throwable对象输出：操作栈不变方法：visitInsn参数：无使用范例： mv.visitInsn(ATHROW);</code></pre><p>athrow负责将一个Throwable对象抛出。如果对象是null，那么就不会抛出这个null，而是抛出<code>NullPointerException</code>。</p><p>通常情况下，我们都是直接new一个Throwable对象然后直接抛出，就像这样：</p><pre><code class="hljs Java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;error!&quot;</span>);</code></pre><p>翻译为字节码如下：</p><pre><code class="hljs Java"><span class="hljs-comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span>mv.visitTypeInsn(NEW, <span class="hljs-string">&quot;java/lang/Exception&quot;</span>);mv.visitInsn(DUP);mv.visitLdcInsn(<span class="hljs-string">&quot;error!&quot;</span>);mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/Exception&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitInsn(ATHROW);</code></pre><h2 id="同步字节码"><a href="#同步字节码" class="headerlink" title="同步字节码"></a>同步字节码</h2><p>同步操作共有两个字节码，monitorenter和monitorexit，成套使用。</p><pre><code class="hljs Java">输入：一个对象输出：无方法：visitInsn参数：无使用范例： mv.visitInsn(MONITORENTER); mv.visitInsn(MONITOREXIT);</code></pre><p>输入的对象必须是引用类型对象，不能是基本类型的值。</p><p>使用同步块时，代码类似这样：</p><pre><code class="hljs Java">Object lock = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//设0号位</span><span class="hljs-keyword">synchronized</span>(lock) &#123;  <span class="hljs-comment">//...</span>&#125;</code></pre><p>对应的字节码：</p><pre><code class="hljs Java"><span class="hljs-comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span>mv.visitInsn(ICONST_0);mv.visitIntInsn(NEWARRAY, T_BYTE);mv.visitVarInsn(ASTORE, <span class="hljs-number">0</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitInsn(MONITORENTER);<span class="hljs-comment">//...</span>mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitInsn(MONITOREXIT);</code></pre><p>monitorenter就是尝试加锁的操作。如果这个对象的监视器条目计数为0，此线程会把这个计数设置为1，这时此线程就是这个对象的监视器；如果不为0且线程不是该对象的监视器，线程会阻塞直到计数为0时重新尝试加锁；如果线程已经是这个对象的监视器，计数递增。</p><p>monitorexit就是释放锁的操作。如果线程是这个对象的监视器，计数递减，当计数减为0时该线程就不是这个对象的监视器了。如果线程不是这个对象的监视器，这个字节码会抛出<code>IllegalMonitorStateException</code>。</p><p>monitorenter可以和很多monitorexit一起出现，在一个方法的所有可能流程中的加锁次数和释放次数必须相同，否则在调用时会发生<code>IllegalMonitorStateException</code>。</p><p>对于同步方法（访问标志含有ACC_SYNCHRONIZED），不需要手动对自身对象或类加锁。JVM在调用方法前隐式加锁，在调用之后隐式释放。</p><h2 id="应用：计算两数之积"><a href="#应用：计算两数之积" class="headerlink" title="应用：计算两数之积"></a>应用：计算两数之积</h2><p>学到了这些字节码，接下来我们要试试用纯字节码解决这道简单的问题。</p><pre><code class="hljs plaintext">输入：两个双精度浮点数a,b输出：一个保留5位小数部分的双精度浮点数，代表a*b例：3.22 6.11输出：19.67420</code></pre><p>在Java代码下，我们可以这样写：</p><pre><code class="hljs Java"><span class="hljs-comment">// 这里不写main方法，而是写了一个静态的test方法用于后续调用</span><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);    <span class="hljs-keyword">double</span> a = scanner.nextDouble();    <span class="hljs-keyword">double</span> b = scanner.nextDouble();    System.out.printf(<span class="hljs-string">&quot;%.5f&quot;</span>, a * b);  &#125;&#125;</code></pre><p>下面是用ASM生成的步骤：</p><p>首先还是创建类和方法，不再多说。</p><p>第一行，创建Scanner对象，这里用到的就是new。</p><pre><code class="hljs Java"><span class="hljs-comment">// 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例</span>mv.visitTypeInsn(NEW, <span class="hljs-string">&quot;java/util/Scanner&quot;</span>);mv.visitInsn(DUP);mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-string">&quot;Ljava/io/InputStream;&quot;</span>);mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/util/Scanner&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(Ljava/io/InputStream;)V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitVarInsn(ASTORE, <span class="hljs-number">0</span>);</code></pre><p>第二行和第三行都是读取double，这里是调用了Scanner的<code>nextDouble</code>方法，这里只给第二行的例子：</p><pre><code class="hljs Java">mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/util/Scanner&quot;</span>, <span class="hljs-string">&quot;nextDouble&quot;</span>, <span class="hljs-string">&quot;()D&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitVarInsn(DSTORE, <span class="hljs-number">1</span>);</code></pre><p>接下来是个重头戏。首先来看看<code>PrintStream::printf</code>的定义：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> PrintStream <span class="hljs-title">printf</span><span class="hljs-params">(String format, Object ... args)</span></span></code></pre><p>可以看到，args是个不定长参数，这怎么表示呢？</p><p>在Java中，不定长参数都被解析为数组，也就是说，它在字节码中的表示其实是这样的：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> PrintStream <span class="hljs-title">printf</span><span class="hljs-params">(String format, Object[] args)</span></span></code></pre><p>现在我们需要传递的参数就是一个字符串和一个Object数组。可是double不是引用类型，这又要怎么办呢？</p><p>在Java中，基本类型都有它们的“包装类”。double的包装类是java.lang.Double，通过<code>Double::valueOf</code>方法就可以把double值转变为Double对象，也就是装箱操作。在平常编写时，Java编译器会自动为我们添加装箱操作，也就是自动装箱。</p><p>经过这样的解析，最后这句话的Java代码表示就像这样：</p><pre><code class="hljs Java">System.out.printf(<span class="hljs-string">&quot;%.5f&quot;</span>, <span class="hljs-keyword">new</span> Object[] &#123; Double.valueOf(a * b) &#125;);</code></pre><p>其中Object[]是一个长度为1的数组，也就是先创建它然后将Double对象用aastore字节码放入就行。</p><pre><code class="hljs Java">mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>); <span class="hljs-comment">// System.out</span>mv.visitLdcInsn(<span class="hljs-string">&quot;%.5f&quot;</span>); <span class="hljs-comment">// printf的第一个参数</span>mv.visitInsn(ICONST_1); <span class="hljs-comment">// Object[]的长度</span>mv.visitTypeInsn(ANEWARRAY, <span class="hljs-string">&quot;java/lang/Object&quot;</span>); <span class="hljs-comment">// 创建Object[]</span>mv.visitInsn(DUP); <span class="hljs-comment">// 复制一份数组，一份用于放入对象，一份用于传入方法</span>mv.visitInsn(ICONST_0); <span class="hljs-comment">// 放入数组的位置，0</span>mv.visitVarInsn(DLOAD, <span class="hljs-number">1</span>); <span class="hljs-comment">// 取出a</span>mv.visitVarInsn(DLOAD, <span class="hljs-number">3</span>); <span class="hljs-comment">// 取出b（3是因为double要占两个局部变量槽位！）</span>mv.visitInsn(DMUL); <span class="hljs-comment">// 计算 a * b</span>mv.visitMethodInsn(INVOKESTATIC, <span class="hljs-string">&quot;java/lang/Double&quot;</span>, <span class="hljs-string">&quot;valueOf&quot;</span>, <span class="hljs-string">&quot;(D)Ljava/lang/Double;&quot;</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 装箱</span>mv.visitInsn(AASTORE); <span class="hljs-comment">// 放入数组</span>mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;printf&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;&quot;</span>, <span class="hljs-keyword">false</span>);</code></pre><p>最后写入return和visitMaxs，局部变量一共5个槽位，最大的操作栈大小是9：</p><pre><code class="hljs Java">mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>);</code></pre><p>下面就可以实验了！</p><pre><code class="hljs plaintext">3.22 6.1119.67420</code></pre><p>测试结果和预测一样！</p><p>全部代码：<a href="https://paste.ubuntu.com/p/NXDfFpQ4y6/">https://paste.ubuntu.com/p/NXDfFpQ4y6/</a></p><hr><p>这篇专栏的内容结束了，下一篇：Java ASM详解：MethodVisitor与Opcode（三）标签，选择结构，循环结构，栈帧</p><p>这篇文章一共讲了34个字节码，从开始到现在一共讲了164个。</p><p>有错误在评论中指出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上次讲过了操作栈与数值运算操作，这篇专栏主要讲ASM中有关于类型、数组与方法调用的字节码。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;P.S.ASM库已经更新到了9.2版本，可以试试解析Java 18的类了。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;有关于类型的字节码&quot;&gt;&lt;a href=&quot;#有关于类</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="ASM" scheme="http://nickid2018.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>JEP 412 Foreign Function &amp; Memory (FFM) API 外部函数与内存API</title>
    <link href="http://nickid2018.github.io/2021/08/08/JEP412%20Foreign%20Function%20Memory%20FFM%20API%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E5%AD%98API/"/>
    <id>http://nickid2018.github.io/2021/08/08/JEP412%20Foreign%20Function%20Memory%20FFM%20API%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E5%AD%98API/</id>
    <published>2021-08-08T00:00:00.000Z</published>
    <updated>2021-08-30T11:30:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇专栏翻译自<a href="https://openjdk.java.net/jeps/412">https://openjdk.java.net/jeps/412</a>，”JEP 412: Foreign Function &amp; Memory API (Incubator)”，讲述了有关于Java 17中加入的FFM API。</p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>引入一个可以让Java程序与Java运行时以外的代码和数据进行交换的API。通过高效的调用外部函数（即JVM外部的代码），并且通过安全地访问外部内存（即不是由JVM管理的内存），这套API能让Java程序调用本地库和操作本地数据的同时避免JNI的脆弱性和不安全性。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><p>易用性 - 将Java本地接口（JNI）替换为优越的，纯Java开发的模型</p></li><li><p>性能 - 提供与现有 API（如 JNI 和 sun.misc.Unsafe）相媲美（如果不是更好的话）的性能</p></li><li><p>通用性 - 提供操作不同类型的外部内存（如：本地内存，永久内存和堆内存）的方法，并且随着时间的推移，去适应其他的平台（如：32bit x86）和除C以外的语言（如：C++,Fortran）编写的外部函数</p></li><li><p>安全性 - 在默认情况下禁用不安全的操作，仅在从应用程序开发人员或最终用户明确选择后才能禁用它们</p></li></ul><h2 id="非目标"><a href="#非目标" class="headerlink" title="非目标"></a>非目标</h2><ul><li><p>在此 API 之上重新实现JNI，或以任何方式修改JNI</p></li><li><p>在此 API 之上重新实现传统 Java API，例如：sun.misc.Unsafe类</p></li><li><p>提供从本地代码头文件中自动生成 Java 代码的工具，或者</p></li><li><p>更改与本地库交互的 Java 应用程序的包装和部署方式（例如，通过多平台 JAR 文件）</p></li></ul><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="外部内存"><a href="#外部内存" class="headerlink" title="外部内存"></a>外部内存</h3><p>存储在Java运行时之外的内存的数据被称为<strong>堆外数据</strong>(off-heap data)。”heap”（堆）是Java对象生存（对象生命周期）的地方，也是垃圾回收（Garbage Collector，GC）处理的地方。访问堆外数据对于Tensorflow、Ignite、Lucene和Netty等Java库的性能至关重要，这主要是因为这避免了由垃圾回收引起的成本和不可预测性，并且这也允许程序通过mmap等将文件映射入内存中进行数据结构的序列化和反序列化。但是，Java平台到今天没有为访问堆外数据提供令人满意的解决方案。</p><blockquote><p>ByteBuffer API（java.nio）允许创建直接缓冲区（direct buffer），这些缓冲区在堆外分配，但是它们的最大大小限制为2GB并且不能及时释放。这些和其他的限制都来源于一个事实：ByteBuffer API不仅被用于访问堆外内存，还被用于生产者/消费者之间批量数据的交换，如字符集的编码/解码和部分I/O操作。在这方面，它无法满足多年来提出的许多堆外内存增强请求。</p><p>sun.misc.Unsafe API暴露了堆内内存的访问操作，这对堆外内存也适用。使用它很高效，因为它的内存操作被定义在HotSpot JVM内部并且会被JIT编译器优化。但是，因为它可以访问任何内存位置，使用它是危险的。这意味着一个Java程序可以通过访问一个已经释放的内存位置使JVM崩溃。因为这个和其他的原因，使用Unsafe是强烈不被推荐的。</p><p>使用JNI调用本地库来访问堆外内存是可能的，但是因为它的效率开销（较高）而很少找到适用的地方：从Java到本地代码的速度要比直接访问内存的速度慢几个数量级，因为JNI方法调用并不能从常见的JIT优化（如内联）中获益。</p></blockquote><p>总之，当访问堆外数据时，Java开发者就面临着两难的境地：他们是选择安全但效率不高的方式（ByteBuffer API）还是放弃安全转而选择性能（Unsafe API）？开发者需要的是一个Java支持的API，用于在JIT优化下从头到脚安全地访问堆外数据（即外部内存）。</p><h3 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h3><p>从Java 1.1开始，JNI就已经支持本地代码的调用（即外部函数），但是因为很多原因它并不适合。</p><blockquote><p>JNI涉及几个乏味的构件:Java API（本地方法）、源自Java API的C头文件（译注：即javah.exe的工作，当Java 10移除javah.exe后，这项工作由javac -h完成），以及调用感兴趣的本地库的C实现。Java开发人员必须跨多个工具链工作，以保持与平台相关的构件同步，当本地库快速发展时，这尤其繁重。</p><p>JNI只能与以一些语言（通常为C/C++）进行交互，这些库使用了JVM在构建中使用的操作系统和CPU的约定。本地方法不能被用于去调用一个由不同约定的语言编写的函数。</p><p>JNI没有协调Java类型系统和C类型系统。Java中的聚合数据是用对象表示的，但C中的聚合数据是用结构体表示的，因此传递给本地方法的任何Java对象都必须费力地由本地代码解包。例如，考虑一个Java中的记录（<code>record</code>，Java 16加入）类Person：将Person对象传递给本地方法将要求本地代码使用JNI的C API从对象中提取字段（例如，firstName和lastName）（译注：提取字段就是使用JNIEnv*的函数）。结果是，Java开发者们有些时候会把他们的数据转变成一个单独的对象（如：一个字节数组或一个direct ByteBuffer），但更常见的是，因为通过JNI传递Java对象很慢，他们就使用Unsafe API去分配堆外内存并且以long的形式将内存地址传递给本地方法（译注：比如LWJGL）——可悲的是这使得Java代码变得不安全！</p></blockquote><p>多年来，有许多框架填补JNI留下的空白，这其中包括<code>JNA</code>、<code>JNR</code>和<code>JavaCPP</code>。虽然这些框架通常被视为JNI的改进，但是情况依旧不理想，尤其是当与提供一流的本地代码交互的语言相比。比如，Python的ctypes包可以动态地将函数包装在本地库中而不用生成任何的粘合代码。其他语言，例如Rust，提供了可以从C/C++头文件中自动派生本地代码包装的工具。</p><p>总之，Java开发者应该有一个让他们能直接使用任何被认为对特定任务有用的本机库并且避免使用JNI带来的繁琐与沉闷的API。对于此的一个绝佳的抽象是方法句柄（<code>Method Handle</code>），它在Java 7被引入，用于支持在JVM上的快速动态语言（<code>invokedynamic</code>，inDy）。通过方法句柄公开本机代码将从根本上简化编写、构建和分发依赖于本机库的Java库的任务。此外，能够建模外部函数（即本机代码）和外部内存（即堆外数据）的API将为第三方本机交互框架提供坚实的基础。</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>外部函数与内存API（Foreign Function &amp; Memory API，下文简称为”FFM API”）定义了一系列类与接口以便于在库与应用程序中的客户端代码：</p><blockquote><p>分配外部内存（MemorySegment，MemoryAddress和SegmentAllocator）,<br>操作和访问结构化外部内存（MemoryLayout，MemoryHandles和MemoryAccess），<br>管理外部资源的生命周期（ResourceScope）和<br>调用外部函数（SymbolLookup和CLinker）</p></blockquote><p>FFM API定义在<code>jdk.incubator.foreign</code>模块下的<code>jdk.incubator.foreign</code>包内。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面是一个简单的使用<code>FFM API</code>的例子，Java代码获得了一个C库函数<code>radixsort</code>的方法句柄，然后用它来对Java数组中的四个字符串进行排序（一些细节被省略了）：</p><pre><code class="hljs Java"><span class="hljs-comment">// 1. 在C库路径下寻找外部函数</span>MethodHandle radixSort = CLinker.getInstance().downcallHandle(                             CLinker.systemLookup().lookup(<span class="hljs-string">&quot;radixsort&quot;</span>), ...);<span class="hljs-comment">// 2. 分配堆内内存储存4个字符串</span>String[] javaStrings   = &#123; <span class="hljs-string">&quot;mouse&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;car&quot;</span> &#125;;<span class="hljs-comment">// 3. 分配堆外内存储存4个指针</span>MemorySegment offHeap  = MemorySegment.allocateNative(                             MemoryLayout.ofSequence(javaStrings.length,                                                     CLinker.C_POINTER), ...);<span class="hljs-comment">// 4. 将字符串从堆内复制到堆外</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; javaStrings.length; i++) &#123;    <span class="hljs-comment">// 分配一个堆外的字符串， 然后储存一个指向它的指针</span>    MemorySegment cString = CLinker.toCString(javaStrings[i], newImplicitScope());    MemoryAccess.setAddressAtIndex(offHeap, i, cString.address());&#125;<span class="hljs-comment">// 5. 通过调用外部函数将堆外数据排序</span>radixSort.invoke(offHeap.address(), javaStrings.length, MemoryAddress.NULL, <span class="hljs-string">&#x27;\0&#x27;</span>);<span class="hljs-comment">// 6. 将（已经排序后）的字符串数组从堆外复制到堆内</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; javaStrings.length; i++) &#123;    MemoryAddress cStringPtr = MemoryAccess.getAddressAtIndex(offHeap, i);    javaStrings[i] = CLinker.toJavaStringRestricted(cStringPtr);&#125;<span class="hljs-keyword">assert</span> Arrays.equals(javaStrings, <span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">&quot;car&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;mouse&quot;</span>&#125;);  <span class="hljs-comment">// true</span></code></pre><p>这段代码比任何使用JNI的解决方案都清晰得多，因为原本隐藏在本机方法调用后面的隐式转换和内存解引用现在直接用Java表示了。也可以使用现代Java语言特性；例如，流可以允许多个线程并行地在堆内和堆外内存之间复制数据。</p><h3 id="内存段（Memory-Segments）"><a href="#内存段（Memory-Segments）" class="headerlink" title="内存段（Memory Segments）"></a>内存段（Memory Segments）</h3><p>内存段是对位于堆外或堆内的连续内存区域进行建模的抽象。内存段可以为</p><blockquote><p>本地段，在本地内存内从头开始分配（例如通过<code>malloc</code>），<br>映射段，将映射包装在本地内存区域中（例如通过<code>mmap</code>），或者<br>数组或缓冲区段，将现有的Java数组或字节缓冲区相关的内存分别包装</p></blockquote><p>所有的内存段都提供了空间、时间和线程限制的保证，为了使内存解引用操作安全，这些保证都是强制的。例如，下面的代码在堆外分配了100个字节：</p><pre><code class="hljs Java">MemorySegment segment = MemorySegment.allocateNative(<span class="hljs-number">100</span>, newImplicitScope());</code></pre><p>段的<em>空间边界</em>决定了与段相关联的内存地址的范围。上面代码中段的边界由表示为<code>MemoryAddress</code>实例的<em>基础地址</em>b和以字节为单位的大小（100）定义，结果是地址范围从b到b + 99（包括b + 99）。</p><p>段的<em>时间边界</em>决定了段的生存期，也就是这个段什么时候会被释放。段的生存期和线程限制状态是通过<code>ResourceScope</code>抽象建模的，下面将对此进行讨论。上面代码中的资源作用域是一个新的<em>隐式</em>作用域，它确保当垃圾回收器认为<code>MemorySegment</code>对象不可达时才释放与此段相关的内存。隐式作用域还确保可以从多个线程访问内存段。</p><p>换句话说，上面的代码创建了一个行为与<code>allocateDirect</code>工厂分配的ByteBuffer的行为紧密匹配的段。FFM API还支持还支持确定性内存释放和其他线程限制选项，将在下面讨论。</p><h3 id="解引用内存段"><a href="#解引用内存段" class="headerlink" title="解引用内存段"></a>解引用内存段</h3><p>与段关联的内存解引用是通过获取变量句柄来实现的，它是Java 9中引入的数据访问抽象模型。特别地，段是用<strong>内存访问变量句柄</strong>来解引用的。这种类型的变量句柄使用一对访问坐标：</p><blockquote><p>以MemorySegment对象表示的坐标——也就是控制的内存要被解引用的段，和<br>以long表示的坐标——也就是偏移量（offset），从段的基础地址到解引用开始的偏移量</p></blockquote><p>内存访问变量句柄可以通过在<code>MemoryHandles</code>类中的工厂方法获取。例如，这段代码获取了可以将int写入本地内存段的内存访问变量句柄，并且使用它在连续的偏移下写入25个4字节的值（译注：指int为4字节）：</p><pre><code class="hljs Java">MemorySegment segment = MemorySegment.allocateNative(<span class="hljs-number">100</span>, newImplicitScope());VarHandle intHandle = MemoryHandles.varHandle(<span class="hljs-keyword">int</span>.class, ByteOrder.nativeOrder());<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;    intHandle.set(segment, <span class="hljs-comment">/* 偏移 */</span> i * <span class="hljs-number">4</span>, <span class="hljs-comment">/* 要写入的数据 */</span> i);&#125;</code></pre><p>更高级的访问用法可以通过使用MemoryHandles类提供的一个或多个组合子方法来组合内存访问变量句柄来表达。使用这些客户端可以，例如，对给定的内存访问变量句柄进行重排序，删除一个或多个坐标，或插入新的坐标。这允许创建接受一个或多个逻辑索引到一个在堆外内存区域的多维数组中的内存访问变量句柄。</p><p>为了使FFM API更容易访问，<code>MemoryAccess</code>类提供了静态访问器来解引用内存段，而不需要构造内存访问变量句柄。例如，有一个访问器可以在给定偏移量的段中设置一个int值，允许上面的代码简化为：</p><pre><code class="hljs Java">MemorySegment segment = MemorySegment.allocateNative(<span class="hljs-number">100</span>, newImplicitScope());<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;    MemoryAccess.setIntAtOffset(segment, i * <span class="hljs-number">4</span>, i);&#125;</code></pre><h3 id="内存布局（Memory-Layouts）"><a href="#内存布局（Memory-Layouts）" class="headerlink" title="内存布局（Memory Layouts）"></a>内存布局（Memory Layouts）</h3><p>为了减少对内存布局的繁琐计算(例如，上面例子中的i * 4)， <code>MemoryLayout</code>可以用更声明式的方式来描述内存段的内容。例如，上面例子中需要的本地内存段的布局可以用以下方式描述：</p><pre><code class="hljs Java">SequenceLayout intArrayLayout    = MemoryLayout.sequenceLayout(<span class="hljs-number">25</span>,        MemoryLayout.valueLayout(<span class="hljs-number">32</span>, ByteOrder.nativeOrder()));</code></pre><p>这将创建一个<em>序列内存布局</em>（<code>sequence memory layout</code>），内部由重复了25次的32比特<em>值布局</em>（一个描述了单一32字节值的布局）构成。给定一个内存布局，我们可以避免在代码中计算偏移量，并简化内存分配和创建内存访问变量句柄：</p><pre><code class="hljs Java">MemorySegment segment = MemorySegment.allocateNative(intArrayLayout, newImplicitScope());VarHandle indexedElementHandle =    intArrayLayout.varHandle(<span class="hljs-keyword">int</span>.class, PathElement.sequenceElement());<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intArrayLayout.elementCount().getAsLong(); i++) &#123;    indexedElementHandle.set(segment, (<span class="hljs-keyword">long</span>) i, i);&#125;</code></pre><p><code>intArrayLayout</code>对象通过创建布局路径来驱动内存访问变量句柄的创建，该路径用于从复杂布局表达式中选择嵌套布局。intArrayLayout对象也驱动了本地内存段的分配，这个内存段基于来自于布局的大小和对齐信息。在之前的例子中的循环常数，也就是25，已经被序列布局的元素数量所替代。</p><h3 id="资源作用域（Resource-Scopes）"><a href="#资源作用域（Resource-Scopes）" class="headerlink" title="资源作用域（Resource Scopes）"></a>资源作用域（Resource Scopes）</h3><p>在前面的例子中看到的所有内存段都使用了非确定性的释放：一旦内存段实例变得不可达，垃圾收集器就会释放与这些段相关的内存。我们说这样的段是<strong>隐式释放</strong>的。</p><p>在某些情况下，客户端可能希望控制何时发生内存释放。试想，例如，使用<code>MemorySegment::map</code>从一个文件中映射出一个很大的内存段。客户端可能更喜欢在段不再需要时释放（即取消映射）与段相关的内存，而不是等待垃圾收集器这样做，因为等待可能会对应用程序的性能产生不利影响。</p><p>内存段支持通过资源作用域的确定性释放。资源作用域对与一个或多个资源（如内存段）相关联的生命周期进行建模。新创建的资源作用域处于<em>活动</em>状态，这意味着可以安全地访问它管理的所有资源。在客户端请求时，可以<em>关闭</em>资源作用域，这意味着不再允许访问由该作用域管理的资源。因为ResourceScope类实现了<code>AutoClosable</code>接口，所以它可以使用<code>try-with-resource</code>语句：</p><pre><code class="hljs Java"><span class="hljs-keyword">try</span> (ResourceScope scope = ResourceScope.newConfinedScope()) &#123;    MemorySegment s1 = MemorySegment.map(Path.of(<span class="hljs-string">&quot;someFile&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-number">100000</span>,                                         MapMode.READ_WRITE, scope);    MemorySegment s2 = MemorySegment.allocateNative(<span class="hljs-number">100</span>, scope);    ...&#125; <span class="hljs-comment">// 这两个内存段到这里被释放</span></code></pre><p>这段代码创建了一个受限（<code>confined</code>）的资源作用域，并将其用于创建两个段：映射段（s1）和本地段（s2）。这两个段的生命周期与资源作用域的生命周期相关联，因此在try-with-resources语句完成后访问段（例如，使用内存访问变量句柄对它们进行解引用）将导致抛出一个运行时异常。</p><p>除了管理内存段的生命周期外，资源作用域还可以作为一种方法来控制哪些线程可以访问内存段。受限资源作用域只允许创建作用域的线程的访问，而共享资源作用域允许从任何线程访问。</p><p>资源作用域，无论是受限的还是共享的，都可能与<code>java.lang.ref.Cleaner</code>对象相关联，该对象负责执行隐式释放，以防在客户端调用<code>close</code>方法之前，资源作用域对象变得不可达。</p><p>一些称为隐式资源作用域的资源作用域不支持显式释放——调用close将失败。隐式资源作用域总是使用Cleaner来管理它们的资源。隐式作用域可以使用<code>ResourceScope::newImplicitScope</code>工厂创建，如前面的示例所示。</p><h3 id="段分配器（Segment-Allocators）"><a href="#段分配器（Segment-Allocators）" class="headerlink" title="段分配器（Segment Allocators）"></a>段分配器（Segment Allocators）</h3><p>当客户端使用堆外内存时，内存分配通常是一个瓶颈。FFM API包括一个<code>SegmentAllocator</code>抽象模型，它定义了分配和初始化内存段的操作。段分配器是通过SegmentAllocator接口中的工厂获得的。例如，下面的代码创建了一个<em>基于区域</em>（<code>arena-based</code>）的分配器，并使用它来分配一个内容是从Java int数组初始化的段：</p><pre><code class="hljs Java"><span class="hljs-keyword">try</span> (ResourceScope scope = ResourceScope.newConfinedScope()) &#123;    SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++) &#123;        MemorySegment s = allocator.allocateArray(C_INT, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;);        ...    &#125;    ...&#125; <span class="hljs-comment">// 所有分配的内存在此处被释放</span></code></pre><p>这段代码创建一个受限的资源范围，然后创建与该范围相关联的<em>无边界区域分配器</em>（<code>unbounded arena allocator</code>）。这个分配器将分配特定大小的内存块，并通过返回预先分配的内存块的不同片（译注：也就是分配器先分配一定大小的块后，用户要求内存时按用户需求在内存块中取出相当长度的内存切片）来响应分配请求。如果一个内存块没有足够的空间来容纳一个新的分配请求，那么就分配一个新的内存块。如果与区域分配器相关联的资源作用域被关闭，所有与分配器创建的段相关联的内存（例如，在for循环体中）都会被以原子方式释放。这种用法结合了ResourceScope抽象提供的确定性释放的优点，以及更灵活和可伸缩的分配方案。在编写管理大量堆外内存段的代码时，它非常有用。</p><h3 id="不安全的内存段"><a href="#不安全的内存段" class="headerlink" title="不安全的内存段"></a>不安全的内存段</h3><p>到目前为止，我们已经看到了内存段、内存地址和内存布局。解引用操作只能在内存段上进行。由于内存段具有空间和时间边界，Java运行时总是可以确保与给定段相关联的内存被安全解引用。然而，在某些情况下，客户端可能只有MemoryAddress实例，这在与本机代码交互时经常发生。由于Java运行时无法知道与内存地址相关的空间和时间边界，因此FFM API禁止直接解引用内存地址。</p><p>为了解引用内存地址，客户端有两种选择：</p><blockquote><p>如果已知地址位于一个内存段，客户端可以通过<code>MemoryAddress::segmentOffset</code>进行<strong>重新基准</strong>（<code>rebase</code>）操作。重新基准操作会重新定义地址相对于段的基本地址的偏移量，以产生一个新的可以应用于现有段上的偏移量——然后可以安全地对该段解引用。</p><p>或者，如果没有这样的段存在，那么客户端可以使用<code>MemoryAddress::asSegment</code>工厂不安全地创建一个。这个工厂有效地将新的空间和时间边界附加到一个原始的内存地址，以便允许解引用操作。该工厂返回的内存段是不安全的：一个原始内存地址可能与一个10字节长的内存区域相关联，但客户端可能意外地高估了该区域的大小，并创建了一个100字节长的不安全内存段。这可能会导致稍后试图对与不安全段关联的内存区域边界之外的内存的解引用，这可能会导致JVM崩溃，或者更糟的是，导致在无形中的内存损坏。因此，创建不安全的段被视为<strong>受限操作</strong>，默认情况下是禁用的（参见下面的详细内容）。</p></blockquote><h3 id="寻找外部函数"><a href="#寻找外部函数" class="headerlink" title="寻找外部函数"></a>寻找外部函数</h3><p>任何对外部函数的支持的第一个组成部分都是加载本地库的机制。在JNI中，这是通过<code>System::loadLibrary</code>和<code>System::load</code>方法完成的，它们在内部映射到对<code>dlopen</code>或其等效函数的调用。使用这些方法加载的库总是与类加载器（即调用<code>System</code>方法的类加载器）相关联。库和类加载器之间的关联是至关重要的，因为它管理装入的库的生命周期：只有当类加载器不再可访问时，它的所有库才能被安全卸载。</p><p>FFM API没有提供加载本地库的新方法。开发者使用System::loadLibrary和System::load方法来加载将通过FFM API调用的本地库。库和类加载器之间的关联被保留，因此库将以与JNI相同的可预测方式卸载。</p><p>与JNI不同，FFM API提供了在加载的库中查找给定标识地址的功能。这种由<code>SymbolLookup</code>对象表示的功能对于将Java代码链接到外部函数至关重要（参见下面）。有两种方法可以获得SymbolLookup对象：</p><ul><li><p><code>SymbolLookup::loaderLookup</code>返回一个包括本加载器内加载的所有库内部的标识的查找器</p></li><li><p><code>CLinker::systemLookup</code>返回一个特定于平台的标识查找器，它能查找标准C库内的标识</p></li></ul><p>给定一个标识查找器，客户端可以使用<code>SymbolLookup::lookup(String)</code>方法找到一个外部函数。如果指定的函数出现在标识查找器所包括的标识中，则该方法返回指向函数入口点的MemoryAddress。例如，下面的代码加载OpenGL库（使它与当前类加载器相关联），并找到它的<code>glGetString</code>函数的地址：</p><pre><code class="hljs Java">System.loadLibrary(<span class="hljs-string">&quot;GL&quot;</span>);SymbolLookup loaderLookup = SymbolLookup.loaderLookup();MemoryAddress clangVersion = loaderLookup.lookup(<span class="hljs-string">&quot;glGetString&quot;</span>).get();</code></pre><h3 id="将Java代码链接到外部函数"><a href="#将Java代码链接到外部函数" class="headerlink" title="将Java代码链接到外部函数"></a>将Java代码链接到外部函数</h3><p><code>CLinker</code>接口是Java代码与本地代码交互的核心。虽然CLinker专注于提供Java和C库之间的互操作，但接口中的概念已经足够通用，可以在未来支持其他非Java语言。该接口支持向下调用（<code>downcall</code>，从Java代码调用本地代码）和向上调用（<code>upcall</code>，从本地代码调用回Java代码）。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CLinker</span> </span>&#123;    <span class="hljs-function">MethodHandle <span class="hljs-title">downcallHandle</span><span class="hljs-params">(MemoryAddress func,</span></span><span class="hljs-params"><span class="hljs-function">                                MethodType type,</span></span><span class="hljs-params"><span class="hljs-function">                                FunctionDescriptor function)</span></span>;    <span class="hljs-function">MemoryAddress <span class="hljs-title">upcallStub</span><span class="hljs-params">(MethodHandle target,</span></span><span class="hljs-params"><span class="hljs-function">                             FunctionDescriptor function,</span></span><span class="hljs-params"><span class="hljs-function">                             ResourceScope scope)</span></span>;&#125;</code></pre><p>对于向下调用，<code>downcallHandle</code>方法接受外部函数的地址——通常是从库查找中获得的MemoryAddress——并将外部函数作为向下调用方法句柄公开。稍后，Java代码通过调用<code>invokeExact</code>方法调用downcall方法句柄，然后运行外部函数。传递给方法句柄的invokeExact方法的任何参数都会传递给外部函数。</p><p>对于上行调用，<code>upcallStub</code>方法接受一个方法句柄——通常是指一个Java方法句柄，而不是下行调用方法句柄——并将其转换为内存地址。稍后，当Java代码调用downcall方法句柄时，将内存地址作为参数传递。实际上，内存地址充当函数指针。（欲了解更多关于upcall的信息，请参阅下面）</p><p>假设我们想从Java向下调用定义在C标准库中的<code>strlen</code>函数：</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)</span></span>;</code></pre><p>一个暴露strlen的向下调用方法句柄可以像下面这样获取（关于<code>MethodType</code>和<code>FunctionDescriptor</code>的细节将会简短介绍）：</p><pre><code class="hljs Java">MethodHandle strlen = CLinker.getInstance().downcallHandle(    CLinker.systemLookup().lookup(<span class="hljs-string">&quot;strlen&quot;</span>).get(),    MethodType.methodType(<span class="hljs-keyword">long</span>.class, MemoryAddress.class),    FunctionDescriptor.of(C_LONG, C_POINTER));</code></pre><p>调用向下调用方法句柄会执行strlen并且让结果在Java端可见。对于strlen的参数，我们使用一个helper方法将Java的字符串转变为堆外内存段并且传递这个段的地址：</p><pre><code class="hljs Java">MemorySegment str = CLinker.toCString(<span class="hljs-string">&quot;Hello&quot;</span>, newImplicitScope());<span class="hljs-keyword">long</span> len          = strlen.invokeExact(str.address());  <span class="hljs-comment">// 5</span></code></pre><p>方法句柄在公开外部函数时工作得很好，因为JVM已经优化了方法句柄的调用，一直优化到本地代码。当方法句柄引用类文件中的方法时，调用方法句柄通常会导致目标方法被JIT编译；随后，JVM通过将控制转移到为目标方法生成的汇编代码来解释调用MethodHandle::invokeExact的Java字节码。因此，调用传统方法句柄已经几乎是外部调用；以C库中的函数为目标的downcall方法句柄只是一种更外部的方法句柄形式。方法句柄还具有一个名为签名多态性的属性，该属性允许基本类型参数的非装箱传入（译注：就是直接传int而不是Integer避免装箱/拆箱操作）。总之，方法句柄让CLinker以一种自然、有效和可扩展的方式公开外部函数。</p><h3 id="在Java中描述C类型"><a href="#在Java中描述C类型" class="headerlink" title="在Java中描述C类型"></a>在Java中描述C类型</h3><p>为了创建向下调用方法句柄，FFM API需要客户端提供对于目标C函数的两种签名：使用<em>非透明</em>的Java对象（MemoryAccess和MemorySegment）的高级别签名和使用<em>透明</em>的Java对象（MemoryLayout）的低级别签名。依次取每个签名：</p><blockquote><p>高级别签名，即MethodType，用作向下调用方法句柄的类型。每个方法句柄都是强类型的，这意味着可以传递给它的invokeExact方法的参数的数量和类型是严格的。例如，为接受一个MemoryAddress参数而创建的方法句柄不能通过invokeExact(MemoryAddress, MemoryAddress)或通过invokeExact(“Hello”)调用。因此，MethodType描述了客户端在调用向下调用方法句柄时必须使用的Java签名。实际上，它是C函数的Java视图。</p><p>低级别签名，即FunctionDescriptor，包含MemoryLayout对象。这使CLinker能够精确地理解C函数的参数，以便它能够正确地安排它们，如下所述。客户端通常有MemoryLayout对象，以便解引用外部内存中的数据，这样的对象可以在这里作为外部函数签名重用。</p></blockquote><p>例如，为接受int值并返回long值的C函数获取向下调用方法句柄时，downcallHandle方法需要以下MethodType和FunctionDescriptor参数：</p><pre><code class="hljs Java">MethodType mtype         = MethodType.methodType(<span class="hljs-keyword">long</span>.class, <span class="hljs-keyword">int</span>.class);FunctionDescriptor fdesc = FunctionDescriptor.of(C_LONG, C_INT);</code></pre><blockquote><p>这个例子的目标系统是Linux/x64和macOS/x64，其中Java类型long和int分别与预定义的CLinker布局C_LONG和C_INT关联。Java类型与内存布局的关联因平台而异：例如，在Windows/x64上，Java long与C_LONG_LONG布局相关联</p><p>译注：这里的原因是C中long的位数取决于系统，而long long为确定64位；在Java中，int确定32位而long为64位，为了确保数据的对齐需要调整布局</p></blockquote><p>另一个例子，获取一个带有指针的void C函数的向下调用方法句柄需要以下MethodType和FunctionDescriptor：</p><pre><code class="hljs Java">MethodType mtype         = MethodType.methodType(<span class="hljs-keyword">void</span>.class, MemoryAddress.class);FunctionDescriptor fdesc = FunctionDescriptor.ofVoid(C_POINTER);</code></pre><blockquote><p>C语言中的所有指针类型在Java中都表示为MemoryAddress对象，对应的布局是C_POINTER，其大小取决于当前平台。客户端不会区分int*和char**，因为传递给CLinker的Java类型和内存布局包含足够的信息来正确地将Java参数传递给C函数</p></blockquote><p>最后，与JNI不同的是，CLinker支持将结构化数据传递给外部函数。获取一个接受struct的无返回值C函数的向下调用方法句柄需要以下MethodType和FunctionDescriptor：</p><pre><code class="hljs Java">MethodType mtype         = MethodType.methodType(<span class="hljs-keyword">void</span>.class, MemorySegment.class);MemoryLayout SYSTEMTIME  = MemoryLayout.ofStruct(  C_SHORT.withName(<span class="hljs-string">&quot;wYear&quot;</span>),      C_SHORT.withName(<span class="hljs-string">&quot;wMonth&quot;</span>),  C_SHORT.withName(<span class="hljs-string">&quot;wDayOfWeek&quot;</span>), C_SHORT.withName(<span class="hljs-string">&quot;wDay&quot;</span>),  C_SHORT.withName(<span class="hljs-string">&quot;wHour&quot;</span>),      C_SHORT.withName(<span class="hljs-string">&quot;wMinute&quot;</span>),  C_SHORT.withName(<span class="hljs-string">&quot;wSecond&quot;</span>),    C_SHORT.withName(<span class="hljs-string">&quot;wMilliseconds&quot;</span>));FunctionDescriptor fdesc = FunctionDescriptor.ofVoid(SYSTEMTIME);</code></pre><blockquote><p>对于高级别的MethodType签名，Java客户端总是使用不透明的类型MemorySegment，其中C函数需要一个按值传递的struct。对于低级别的FunctionDescriptor签名，与C结构类型相关联的内存布局必须是一个复合布局，它定义了C的struct中所有字段的子布局，包括可能由本地编译器插入的填充</p></blockquote><p>如果C函数返回由低级别签名表示的按值struct，则必须在堆外分配一个新的内存段并返回给Java客户端。为了实现这一点，downcallHandle返回的方法句柄需要一个额外的SegmentAllocator参数，FFM API使用该参数分配内存段来保存C函数返回的struct。</p><h3 id="为C函数打包Java参数"><a href="#为C函数打包Java参数" class="headerlink" title="为C函数打包Java参数"></a>为C函数打包Java参数</h3><p>不同语言之间的交互操作需要一个调用约定来指定一种语言中的代码如何调用另一种语言中的函数、如何传递参数以及如何接收任何结果。CLinker实现具有一些”开箱即用”的调用约定的知识：Linux/x64、Linux/AArch64、macOS/x64和Windows/x64。CLinker是用Java编写的，维护和扩展起来要比JNI容易得多，JNI的调用约定是硬连接到HotSpot的C++代码中的（译注：JNI的调用约定即JNIEnv*）。</p><p>考虑上面显示的SYSTEMTIME结构和布局的函数描述符（FunctionDescriptor）。根据运行JVM的操作系统和CPU的调用约定，当使用MemorySegment参数调用向下调用方法句柄时，CLinker使用函数描述符来推断结构体的字段应该如何传递给C函数。对于一个调用约定，CLinker可以安排分解传入的内存段，使用通用CPU寄存器传递前四个字段，并在C堆栈上传递其余字段。对于不同的调用约定，CLinker可以安排FFM API通过分配一个内存区域来间接传递结构体，将传入内存段的内容批量复制到该区域，并将指向该内存区域的指针传递给C函数。这种最低层次的参数打包是在幕后进行的，不需要任何客户端代码的监督。</p><h3 id="向上调用"><a href="#向上调用" class="headerlink" title="向上调用"></a>向上调用</h3><p>有时，将Java代码作为函数指针传递给某个外部函数是很有用的。我们可以通过使用对上行调用的CLinker支持来实现这一点。在本节中，我们将逐块构建一个更复杂的示例，该示例演示了CLinker的全部功能，以及代码和数据跨Java/本地边界的完全双向互操作。</p><p>考虑标准C库中定义的以下函数：</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *base, <span class="hljs-keyword">size_t</span> nmemb, <span class="hljs-keyword">size_t</span> size,</span></span><span class="hljs-params"><span class="hljs-function">           <span class="hljs-keyword">int</span> (*compar)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *))</span></span>;</code></pre><p>为了从Java端调用<code>qsort</code>，我们首先需要创建向下调用方法句柄：</p><pre><code class="hljs Java">MethodHandle qsort = CLinker.getInstance().downcallHandle(    CLinker.systemLookup().lookup(<span class="hljs-string">&quot;qsort&quot;</span>).get(),    MethodType.methodType(<span class="hljs-keyword">void</span>.class, MemoryAddress.class, <span class="hljs-keyword">long</span>.class,                          <span class="hljs-keyword">long</span>.class, MemoryAddress.class),    FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER));</code></pre><p>和前面一样，我们使用C_LONG和long.class来映射C size_t类型，并且在第一个指针形式参数（数组指针）和最后一个形式参数（函数指针）上使用MemoryAddress.class。</p><p>qsort使用作为函数指针传递的自定义比较器函数<code>compar</code>对数组的内容进行排序。因此，要调用向下调用方法句柄，我们需要一个函数指针作为最后一个参数传递给方法句柄的invokeExact方法。CLinker::upcallStub通过使用现有的方法句柄帮助我们创建函数指针，如下所示。</p><p>首先，我们在Java中编写一个静态方法来比较两个long值，间接表示为MemoryAddress对象：</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Qsort</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">qsortCompare</span><span class="hljs-params">(MemoryAddress addr1, MemoryAddress addr2)</span> </span>&#123;        <span class="hljs-keyword">return</span> MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(),                                           addr1.toRawLongValue()) -               MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(),                                           addr2.toRawLongValue());    &#125;&#125;</code></pre><p>接着，我们创建一个指向Java比较方法的MethodHandle：</p><pre><code class="hljs Java">MethodHandle comparHandle    = MethodHandles.lookup()                   .findStatic(Qsort.class, <span class="hljs-string">&quot;qsortCompare&quot;</span>,                               MethodType.methodType(<span class="hljs-keyword">int</span>.class,                                                     MemoryAddress.class,                                                     MemoryAddress.class));</code></pre><p>之后，现在我们有了Java比较器的方法句柄，我们可以使用CLinker::upcallStub创建函数指针。就像向下调用一样，我们使用CLinker类中的布局来描述函数指针的签名：</p><pre><code class="hljs Java">MemoryAddress comparFunc =  CLinker.getInstance().upcallStub(comparHandle,                                   FunctionDescriptor.of(C_INT,                                                         C_POINTER,                                                         C_POINTER),                                   newImplicitScope()););</code></pre><p>我们终于有了一个内存地址，<code>comparFunc</code>，它指向一个方法存根，可以用来调用我们的Java比较方法，所以现在我们有了调用qsort向下调用句柄所需的所有东西：</p><pre><code class="hljs Java">MemorySegment array = MemorySegment.allocateNative(<span class="hljs-number">4</span> * <span class="hljs-number">10</span>, newImplicitScope());array.copyFrom(MemorySegment.ofArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span> &#125;));qsort.invokeExact(array.address(), <span class="hljs-number">10L</span>, <span class="hljs-number">4L</span>, comparFunc);<span class="hljs-keyword">int</span>[] sorted = array.toIntArray(); <span class="hljs-comment">// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span></code></pre><p>这段代码创建了一个堆外数组，将Java数组的内容复制到其中，然后将数组连同我们从CLinker获得的比较器函数（指针）传递给qsort句柄。调用之后，堆外数组的内容将根据我们用Java编写的比较器函数进行排序。然后从段中提取一个新的Java数组，其中包含已排序的元素。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>基本上，Java代码和本机代码之间的任何交互都可能危及Java平台的完整性。链接到预编译库中的C函数本质上是不可靠的，因为Java运行时不能保证函数的签名符合Java代码的期望，甚至不能保证C库中的标识是真正的函数。此外，如果链接了一个合适的函数，实际上调用该函数可能会导致如分段错误的底层故障，最终导致VM崩溃。Java运行时无法阻止此类故障，Java代码也无法捕获此类故障。</p><p>使用JNI函数的本地代码尤其危险。这样的代码可以在没有命令行标志（例如<code>--add-open</code>）的情况下，通过使用<code>getStaticField</code>和<code>callVirtualMethod</code>等函数访问JDK内部。它还可以在final字段初始化很久之后更改它们的值。它允许本地代码绕过应用于Java代码的检查，这会破坏JDK中的每个边界和假设。换句话说，JNI本质上就是不安全的。</p><p>JNI不能被禁用，因此无法确保Java代码不会调用使用危险的JNI函数的本地代码。这是对平台完整性的一种风险，应用程序开发人员和最终用户几乎看不到这种风险，因为这些函数99%的使用通常来自夹在应用程序和JDK之间的第三、第四和第五方库。</p><p>大多数FFM API的设计是安全的。过去需要使用JNI和本地代码的许多场景都可以通过调用不会危及Java平台的FFM API中的方法来实现。例如，JNI的一个主要用例——灵活的内存分配——是由一个简单的方法MemorySegment::allocateNative支持的，该方法不涉及本机代码，并且总是返回由Java运行时管理的内存。一般来说，使用FFM API的Java代码不会使JVM崩溃。</p><p>然而，FFM API的一部分本身就是不安全的。当与CLinker交互时，Java代码可以通过指定与底层C函数不兼容的参数类型来请求向下调用方法句柄。在Java中调用向下调用方法句柄会导致与在JNI中调用本机方法时相同的结果——VM崩溃或未定义的行为。FFM API也可以产生不安全的段，即内存段的空间和时间边界是用户提供的，这种段不能由Java运行时验证（参见上文的MemoryAddress::asSegment）。</p><p>FFM API中的不安全方法不会带来与JNI函数相同的风险：例如，它们不能更改Java对象中的final字段的值。另一方面，FFM API中的不安全方法很容易从Java代码中调用。由于这个原因，FFM API中不安全方法的使用受到限制：默认情况下，不安全方法的访问是禁用的，调用这些方法会抛出一个IllegalAccessException异常。要使某些模块M中的代码能够访问不安全的方法，请在命令行中指定<code>java --enable-native-access=M</code>。（在以逗号分隔的列表中指定多个模块；指定<code>ALL-UNNAMED</code>以允许类路径上的所有代码访问不安全方法）FFM API的大多数方法都是安全的，Java代码可以使用这些方法，不管是否给出了—enable-native-access。</p><p>我们在这里不建议限制JNI的任何方面。在Java中仍然可以调用本地方法，本地代码也可以调用不安全的JNI函数。然而，在未来的版本中，我们可能会以某种方式限制JNI。例如，不安全的JNI函数（如<code>newDirectByteBuffer</code>）可能会在默认情况下被禁用，就像FFM API中的不安全方法一样。更广泛地说，JNI机制是如此的危险，以至于我们希望库在安全和不安全的操作中偏向于纯Java的FFM API，这样我们就可以在默认情况下禁用所有JNI。这与使平台成为“开箱即用”的安全平台的更广泛的Java路线图一致，要求终端用户选择不安全的行为，如破坏强封装或链接到未知代码。</p><p>我们不建议以任何方式去修改<code>sun.misc.Unsafe</code>。FFM API对堆外内存的支持是对sun.misc.Unsafe中的<code>malloc</code>和<code>free</code>，即<code>allocateMemory</code>, <code>setMemory</code>, <code>copyMemory</code>，和<code>freeMemory</code>的一个很好的替代方案。我们希望需要非堆存储的库和应用程序采用FFM API，以便及时地弃用并最终删除这些sun.misc.Unsafe方法。</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>继续使用java.nio.ByteBuffer，sun.misc.Unsafe，JNI和其他第三方框架。</p><h3 id="风险和假设"><a href="#风险和假设" class="headerlink" title="风险和假设"></a>风险和假设</h3><p>创建一个API以既安全又高效的方式访问外部内存是一项艰巨的任务。由于前几节中描述的空间和时间检查需要在每次访问时执行，因此JIT编译器能够优化这些检查是至关重要的，例如，将它们提升到热循环之外。JIT实现可能需要做一些工作，以确保API的使用与ByteBuffer和Unsafe等现有API的使用一样有效和可优化。JIT实现还需要确保从API中检索到的本地方法句柄的使用至少与使用现有JNI本地方法一样有效和可优化。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><blockquote><p>外部函数和内存API可以用来访问非易失性内存，已经可以通过JEP 352（非易失性映射字节缓冲区，Non-Volatile Mapped Byte Buffers，Java 14引入）用一种更通用和更有效的方式访问</p><p>这里描述的工作可能会使后续工作能够提供一个工具，jextract，它从给定本地库的头文件开始，机械地生成与该库交互操作所需的本机方法句柄。这将进一步减少使用Java本地库的开销</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇专栏翻译自&lt;a href=&quot;https://openjdk.java.net/jeps/412&quot;&gt;https://openjdk.java.net/jeps/412&lt;/a&gt;，”JEP 412: Foreign Function &amp;amp; Memory API (Inc</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="JEP" scheme="http://nickid2018.github.io/tags/JEP/"/>
    
  </entry>
  
  <entry>
    <title>Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算</title>
    <link href="http://nickid2018.github.io/2021/04/07/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BF%90%E7%AE%97/"/>
    <id>http://nickid2018.github.io/2021/04/07/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BF%90%E7%AE%97/</id>
    <published>2021-04-07T00:00:00.000Z</published>
    <updated>2021-08-29T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前文我们说到了很多Visitor，它们用于给类中定义类型，添加字段，附上注释。但是对于一个语言来说，最重要的那一部分我们还没有说到——那就是：方法。</p><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>在ClassVisitor中，我们看到了有一个方法名为visitMethod，参数是(int，String，String，String，String[])，按照参数列表的顺序，它们分别指<strong>访问标志，方法名，方法描述符，泛型签名和抛出异常列表</strong>，返回一个MethodVisitor。（关于方法描述符，请看此系列的第一篇；关于访问标志，请看第二篇）</p><p>对于方法名，有下面的规则：</p><font color=blue>1.方法名不能是关键字或保留字（goto）2.方法名不能以数字开头3.可以为&lt;init&gt;和&lt;clinit&gt;</font><p>其中，<code>&lt;init&gt;</code>是构造函数，一个类可以有不止一个构造函数。而<code>&lt;clinit&gt;</code>每个类最多有一个，并且方法描述符必须为<code>()V</code>，它在类初始化阶段被JVM调用。（包括调用这个类的成员和Class.forName，但不包括Class.forName的initialize参数为false时的调用）</p><p>若方法名不正确，在尝试加载这个类的时候会抛出<code>java.lang.ClassFormatError: Illegal method name</code>。</p><p>抛出异常列表中，所有的类名称都为<strong>全限定名</strong>。</p><h2 id="操作栈（Operand-Stack）"><a href="#操作栈（Operand-Stack）" class="headerlink" title="操作栈（Operand Stack）"></a>操作栈（Operand Stack）</h2><p>操作栈是一个方法被调用时JVM分配出来的一个栈空间，它用于存储方法内加载的数据和进行字节码指令操作。当JVM接收到一个字节码指令（例如iadd），就会取出栈顶的几项元素（对于iadd来说，就是栈顶的两项），在进行操作之后，将计算或获得的数据放回栈顶（比如iadd计算栈顶两个int的加和之后会放回加和数字）。</p><p>对于普通的对象，只会占用一个栈元素。但对于long或double这种对象，会占用两个栈元素。这有关于之后要介绍的visitMaxs。</p><p>如果一个字节码需要超过了现在操作栈内的元素数量的元素，那么在调用生成的方法时会抛出<code>java.lang.VerifyError: Unable to pop operand off an empty stack</code>。</p><p>如果一个字节码需要的类型与现在操作栈中元素类型不同，那么在调用生成的方法时抛出<code>java.lang.VerifyError: Register &lt;slot&gt; contains wrong type</code>或<code>java.lang.VerifyError: Bad type on operand stack</code>。</p><p>在之后的讲解中，我们会大量的使用这个名词，在接下来的编写中，操作栈的变化将会像下面这样写：</p><pre><code class="hljs plaintext">输入：XXX YYY输出：ZZZ</code></pre><h2 id="局部变量表（Local-Variable-Table）"><a href="#局部变量表（Local-Variable-Table）" class="headerlink" title="局部变量表（Local Variable Table）"></a>局部变量表（Local Variable Table）</h2><p>局部变量表在方法调用中分配的另一个空间，用于存储现在方法内所有的局部变量，表中的数据可以被编号为0-n，叫Slot。普通的元素只会占用一个Slot，但long和double这种数据会占用两个。关于这个的详细使用，请看下面的xload和xstore的字节码介绍。</p><p>当这个方法为静态方法时，局部变量表会将参数列表中的变量按顺序放入局部变量表中。</p><p>当这个方法不是静态方法，局部变量表的0位是this，之后才会将参数列表变量依次放入表中。</p><p>如果局部变量表大小超过了256，那么字节码将会发生变化，xload、xstore等都会受到影响（需要以wide字节码辅助才能进行正常的局部变量读取写入）。但是ASM9中不提供wide字节码，因为MethodWriter中有ASM库自己的处理，所以在用户层编写ASM是无影响的。</p><h2 id="MethodVisitor的方法"><a href="#MethodVisitor的方法" class="headerlink" title="MethodVisitor的方法"></a>MethodVisitor的方法</h2><p>在说完操作栈的概念之后，我们来看看MethodVisitor中都定义了哪些有关于字节码和执行的方法。</p><p>下面这些方法第一个参数都为字节码。</p><p><code>visitInsn(int)</code>：访问一个零参数要求的字节码指令，如ACONST_NULL</p><p><code>visitIntInsn(int, int)</code>：访问一个需要零操作栈要求但需要有一个int参数的字节码指令，如BIPUSH</p><p><code>visitVarInsn(int, int)</code>：访问一个有关于局部变量的字节码指令，如ALOAD</p><p><code>visitTypeInsn(int, String)</code>：访问一个有关于类型的字节码指令，如CHECKCAST</p><p><code>visitFieldInsn(int, String, String, String)</code>：访问一个有关于字段的字节码，如PUTFIELD</p><p><code>visitMethodInsn(int, String, String, String, boolean)</code>：访问一个有关于方法调用的字节码，如INVOKESPECIAL</p><p><code>visitJumpInsn(int, Label)</code>：访问跳转字节码，如IFEQ</p><p>之后，是一些被包装好的字节码访问方法，这些方法都基于最基本的字节码指令，但是不需要我们自己用上面提到的那些方法直接调用字节码。</p><p><code>visitInvokeDynamicInsn(String, String, Handle, Object...)</code>：基于INVOKEDYNAMIC，动态方法调用，会在lambda表达式和方法引用里面说到</p><p><code>visitLdcInsn(Object)</code>：基于LDC、LDC_W和LDC2_W，将一个常量加载到操作栈用（详细见下文）</p><p><code>visitIincInsn(int, int)</code>：基于IINC、IINC_W，自增/减表达式</p><p><code>visitTableSwitchInsn(int, int, Label, Label...)</code>：基于TABLESWITCH，用于进行table-switch操作</p><p><code>visitLookupSwitchInsn(Label, int[], Label[])</code>：基于LOOKUPSWITCH，用于进行lookup-switch操作</p><p><code>visitMultiANewArrayInsn(String, int)</code>：基于MULTIANEWARRAY，用于创建多重维度数组，如int[][]</p><p>在下文说到它们时，会以下面的方式表达：</p><pre><code class="hljs plaintext">方法：visitXXXInsn参数：XXX YYY ZZZ</code></pre><p>到这里，所有有关于字节码指令的方法就结束了。块级结构的方法会在下一篇说。</p><p>最后，说一下每个方法都要在最后调用的方法：visitMaxs(int, int)。它第一个参数是操作栈的最大大小，第二个是局部变量的个数。如果你调用这个方法时局部变量数量写小了，就会在生成方法调用时抛出<code>java.lang.ClassFormatError: Arguments can&#39;t fit into locals</code>，如果操作栈大小写小了，在生成方法调用时会抛出<code>java.lang.VerifyError: Stack size too large</code></p><p>那么下面，我们将逐系列逐条讲解所有的字节码。这篇专栏先讲基本的操作栈加载存储等操作、常量获取和运算操作。</p><font color=blue>注意：接下来的x可以为a（针对对象）、i（针对int）、l（针对long）、f（针对float）、d（针对double）、b（针对byte）、c（针对char）、s（针对short），它代表了操作对象的类型。有些时候没有针对于byte和short的专用字节码，这是因为在JVM中，byte和short在被计算时会被强制拉长为int，所以它们使用的和int一样。char和int能互相转换。boolean类似，它们也需要使用int的字节码，而且boolean值的false就是int值0，而true就是int值1。</font><h2 id="字节码介绍"><a href="#字节码介绍" class="headerlink" title="字节码介绍"></a>字节码介绍</h2><h3 id="啥事都不干的字节码：nop"><a href="#啥事都不干的字节码：nop" class="headerlink" title="啥事都不干的字节码：nop"></a>啥事都不干的字节码：nop</h3><pre><code class="hljs Java">输入：无输出：无方法：visitInsn参数：无使用范例：mv.visitInsn(NOP);</code></pre><p>这个字节码啥都不干，在实际开发中可以当做代码插入点使用。</p><h3 id="加载字节码：xload与xload-n"><a href="#加载字节码：xload与xload-n" class="headerlink" title="加载字节码：xload与xload_n"></a>加载字节码：<i>x</i>load与<i>x</i>load_<i>n</i></h3><p>x=a/i/l/f/d</p><pre><code class="hljs Java">输入：无输出：某一对象或基本数据类型数据方法：visitVarInsn参数：加载对象的位置使用范例：mv.visitVarInsn(ALOAD, <span class="hljs-number">5</span>);mv.visitVarInsn(FLOAD, <span class="hljs-number">3</span>); <span class="hljs-comment">// 在javap反汇编中，此处变为fload_3</span></code></pre><p>如果在调用此字节码时对应位置没有初始化变量（原先为参数或已经用xstore进行值的放入被视为该位置被初始化），在生成方法调用时会抛出<code>java.lang.VerifyError: Accessing value from uninitialized register &lt;slot&gt;</code>。</p><p>如果要进行加载的对象位置小于等于3，可以用对应的xload_n版本代替（注意，ASM9的Opcodes中已经不存在xload_n版本的字节码常量，但是在javap反汇编时可以看到此条），例如aload_2。</p><h3 id="存储字节码：xstore与xstore-n"><a href="#存储字节码：xstore与xstore-n" class="headerlink" title="存储字节码：xstore与xstore_n"></a>存储字节码：<i>x</i>store与<i>x</i>store_<i>n</i></h3><p>x=a/i/l/f/d;n=0,1,2,3</p><pre><code class="hljs Java">输入：某一对象或基本类型数据输出：无方法：visitVarInsn参数：存储对象的位置使用范例：mv.visitVarInsn(ASTORE, <span class="hljs-number">4</span>);mv.visitVarInsn(ISTORE, <span class="hljs-number">1</span>); <span class="hljs-comment">// 在javap反汇编中，此处变为istore_1</span></code></pre><p>存储对象的位置规则与加载相同。与加载规则不同的是，xstore可以指定到一个未初始化的位置，并将这个位置初始化。有意思的一点是，你可以不遵循初始化位置的连续性，也就是说，假如2、3位置都未初始化，你可以通过xstore将对象放入3中并初始化它，这时位置2变为了未定义的状态，它在被xload加载时都会抛出<code>java.lang.VerifyError: Register &lt;slot&gt; contains wrong type</code>，即使你用的加载指令与放入指令类型相同。这时你只能通过另一次xstore将对象放入位置2，才能使这个位置类型固定。</p><p>和xload一样，xstore也有xstore_n版本，但ASM9已经不支持直接写入它们了。</p><h3 id="返回字节码：-x-return"><a href="#返回字节码：-x-return" class="headerlink" title="返回字节码：(x)return"></a>返回字节码：<i>(x)</i>return</h3><p>x=a/i/l/f/d</p><pre><code class="hljs Java">输入：某一对象或基本类型数据输出：清空操作栈并返回方法：visitInsn参数：无使用范例：mv.visitInsn(ARETURN);mv.visitInsn(RETURN); <span class="hljs-comment">// 无返回，用于void方法</span></code></pre><p>返回字节码是每个方法必有的，包括void无返回值方法。如果一个方法没有写任何的返回字节码指令，在调用这个生成的方法时就会抛出<code>java.lang.VerifyError: Falling off the end of the code</code>。</p><p>返回字节码无视操作栈内剩余的所有值，只会将栈顶元素返回，并清除操作栈。</p><p>在这个方法为同步方法的前提下，所在线程不是已经锁定的监视器对象所有者时，这条指令会抛出<code>IllegalMonitorStateException</code>。这种情况在普通状况下根本无法发生，只有当这个同步方法上在其同步对象上使用了monitorexit却没有使用monitorenter时可能发生。</p><h3 id="复制栈顶字节码：dup家族"><a href="#复制栈顶字节码：dup家族" class="headerlink" title="复制栈顶字节码：dup家族"></a>复制栈顶字节码：dup家族</h3><pre><code class="hljs Java">方法：visitInsn参数：无使用范例：mv.visitInsn(DUP);每种字节码的解析：<span class="hljs-number">1.</span> DUP输入：...v1输出：...v1 v1<span class="hljs-number">2.</span> DUP_X1输入：...v2 v1输出：...v1 v2 v1<span class="hljs-number">3.</span> DUP_X2输入：...v3 v2 v1输出：...v1 v3 v2 v1<span class="hljs-number">4.</span> DUP2输入：...v2 v1输出：...v2 v1 v2 v1<span class="hljs-number">5.</span> DUP2_X1输入：...v3 v2 v1输出：...v2 v1 v3 v2 v1<span class="hljs-number">6.</span> DUP2_X2输入：...v4 v3 v2 v1输出：...v2 v1 v4 v3 v2 v1</code></pre><p>这个字节码是用于复制栈顶元素并插入到栈中的字节码，可以节省xload和xstore的使用量。在这里，…指栈顶下的其他元素。</p><p>DUP家族的名称规律是：DUP后紧接着的数字代表了复制数量，Xn代表插入到栈顶下第几层。</p><h3 id="弹出栈顶字节码：pop，pop2"><a href="#弹出栈顶字节码：pop，pop2" class="headerlink" title="弹出栈顶字节码：pop，pop2"></a>弹出栈顶字节码：pop，pop2</h3><pre><code class="hljs Java">输入：一（pop）或两（pop2）个元素输出：弹出栈顶一（pop）或两（pop2）个元素方法：visitInsn参数：无使用范例：mv.visitInsn(POP);mv.visitInsn(POP2);</code></pre><p>这个字节码也是用于操作操作栈的。它的使用情况举一个例子：调用了一个有返回值的方法但返回值我们不需要，就可以采用POP。</p><h3 id="交换元素字节码：swap"><a href="#交换元素字节码：swap" class="headerlink" title="交换元素字节码：swap"></a>交换元素字节码：swap</h3><pre><code class="hljs Java">输入：两个元素输出：交换栈顶两个元素方法：visitInsn参数：无使用范例：mv.visitInsn(SWAP);</code></pre><p>这个字节码可以交换栈顶的两个操作数。</p><h3 id="常量池常量读取字节码：ldc（ldc-w-ldc2-w）"><a href="#常量池常量读取字节码：ldc（ldc-w-ldc2-w）" class="headerlink" title="常量池常量读取字节码：ldc（ldc_w, ldc2_w）"></a>常量池常量读取字节码：ldc（ldc_w, ldc2_w）</h3><pre><code class="hljs Java">输入：无输出：从常量池读取出的数据方法：visitLdcInsn参数：常量值（见下文） [在JVM中，此处是常量池中对应常量的序号，长度分为三种，由三种LDC指令决定]使用范例：mv.visitLdcInsn(<span class="hljs-string">&quot;helloworld&quot;</span>);mv.visitLdcInsn(<span class="hljs-number">20.0f</span>); <span class="hljs-comment">// 注意，此处自动装箱成为Float</span>mv.visitLdcInsn(Type.getType(<span class="hljs-string">&quot;I&quot;</span>)); <span class="hljs-comment">// 类型</span></code></pre><p>常量池（Constant Pool）中，含有以下几种数据：整数Integer、浮点数Float、字符串字面值常量String、类的引用Type、句柄Handle或动态常量值ConstantDynamic，所以LDC值可能有这些。</p><p>在JVM中，如果常量值是Integer或Float，就会直接将它们放到操作栈顶；如果为String，将String类的引用放到操作栈顶；若为Type，将对应的类型初始化，并将其Class实例引用放到操作栈顶；对于Handle，将java.lang.invoke.MethodHandle/MethodType的引用至于操作栈顶。</p><p>在解析类型的引用期间（Type），这条指令可能会抛出有关于类加载的异常；同样的，解析有关于句柄（Handle）的时候也有可能抛出和句柄有关的异常。</p><h3 id="空值常量字节码：aconst-null"><a href="#空值常量字节码：aconst-null" class="headerlink" title="空值常量字节码：aconst_null"></a>空值常量字节码：aconst_null</h3><pre><code class="hljs Java">输入：无输出：常量值<span class="hljs-keyword">null</span>方法：visitInsn参数：无使用范例：mv.visitInsn(ACONST_NULL);</code></pre><p>当程序中使用了null，就可以用这个字节码。</p><h3 id="普通数字常量字节码：xconst-n"><a href="#普通数字常量字节码：xconst-n" class="headerlink" title="普通数字常量字节码：xconst_n"></a>普通数字常量字节码：<i>x</i>const_<i>n</i></h3><p>x=i/l/f/d;对于iconst，n=m1,0,1,2,3,4,5;对于lconst、dconst，n=0,1;对于fconst，n=0,1,2</p><pre><code class="hljs Java">输入：无输出：数字常量值，类型与字节码有关方法：visitInsn参数：无使用范例：mv.visitInsn(ICONST_M1); <span class="hljs-comment">// -1</span>mv.visitInsn(FCONST_0); <span class="hljs-comment">// +0.0f</span>mv.visitInsn(LCONST_1); <span class="hljs-comment">// 1L</span></code></pre><p>当数字较小时，获得数字常量可以不使用LDC，可以直接用这些字节码代替（节省常量池空间）。</p><h3 id="整数常量字节码：bipush和sipush"><a href="#整数常量字节码：bipush和sipush" class="headerlink" title="整数常量字节码：bipush和sipush"></a>整数常量字节码：bipush和sipush</h3><pre><code class="hljs Java">输入：无输出：数字常量值方法：visitIntInsn参数：某一具体整数对于bipush，数字属于<span class="hljs-keyword">byte</span>范围（-<span class="hljs-number">128</span>~<span class="hljs-number">127</span>）对于sipush，数字属于<span class="hljs-keyword">short</span>范围（-<span class="hljs-number">32768</span>~<span class="hljs-number">32767</span>）使用范例：mv.visitIntInsn(BIPUSH, <span class="hljs-number">27</span>); <span class="hljs-comment">// 27</span>mv.visitIntInsn(SIPUSH, -<span class="hljs-number">2700</span>); <span class="hljs-comment">// -2700</span></code></pre><p>当一个数字没有超过这两个字节码规定的范围，我们都可以使用这两个字节码获取整数常量。在编译中，属于这个范围的数字都是用它们进行获取整数（除非是-1~5），而更大/小的整数都是用LDC。</p><p>说完了基本的加载存储常量指令，下面来看看程序的最基本功能：计算。</p><h3 id="取反运算字节码：xneg"><a href="#取反运算字节码：xneg" class="headerlink" title="取反运算字节码：xneg"></a>取反运算字节码：<i>x</i>neg</h3><p>x=i/l/f/d</p><pre><code class="hljs Java">输入：数字输出：数字的相反数方法：visitInsn参数：无使用范例：mv.visitInsn(INEG);mv.visitInsn(DNEG);</code></pre><p>这个字节码用于计算取反（-x）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。</p><p>对于整数（int和long），计算规则就是(~x)+1，当它们处于MIN_VALUE时，取反结果仍为MIN_VALUE。</p><p>对于浮点数（double和float），这个字节码运算为：</p><ol><li><p>取反与从零减去不等价，若x为+0.0，0.0-x结果为+0.0，而-x为-0.0</p></li><li><p>若数字为NaN（Not A Number，float的0x7fc00000或double的0x7ff8000000000000L），结果也为NaN</p></li><li><p>若数字为无穷大（float正0x7f800000负0xff800000，double正0x7ff0000000000000L负0xfff0000000000000L），结果为相反符号的无穷大</p></li><li><p>若数字为0，结果为相反符号的0</p></li></ol><h3 id="加法运算字节码：xadd"><a href="#加法运算字节码：xadd" class="headerlink" title="加法运算字节码：xadd"></a>加法运算字节码：<i>x</i>add</h3><p>x=i/l/f/d</p><pre><code class="hljs Java">输入：加数<span class="hljs-number">1</span> 加数<span class="hljs-number">2</span>输出：数字的和方法：visitInsn参数：无使用范例：mv.visitInsn(IADD);mv.visitInsn(DADD);</code></pre><p>这个字节码用于计算加法（a+b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。</p><p>对于浮点数（double和float），这个字节码运算为：</p><ol><li><p>如果两个数都为NaN，结果是NaN。</p></li><li><p>如果两个数为相反符号的无穷大，和为NaN</p></li><li><p>同一符号的无穷大结果是该符号的无穷大</p></li><li><p>有限值与无穷大的和还是无穷大</p></li><li><p>相反符号的两个0（+0.0和-0.0）结果为+0.0</p></li><li><p>相同符号的两个0和为该符号的0</p></li><li><p>0与非零值的和为非零值</p></li><li><p>符号相反，绝对值相等的有限值和为+0.0</p></li><li><p>若不属于上面的情况，结果将以IEEE 754舍入到最近可表示的浮点值。如果结果太大无法表示为浮点数（超过最大表示范围“溢出”，也就是绝对值超过float的3.4028235e+38f或double的1.7976931348623157e+308），结果为对应符号的无穷大；如果结果太小无法表示为浮点数（超过最小表示范围“下溢”，也就是绝对值小于float的1.4e-45f或double的4.9e-324），结果是对应符号的0。</p></li></ol><h3 id="减法运算字节码：xsub"><a href="#减法运算字节码：xsub" class="headerlink" title="减法运算字节码：xsub"></a>减法运算字节码：<i>x</i>sub</h3><p>x=i/l/f/d</p><pre><code class="hljs Java">输入：被减数 减数输出：两数字之差方法：visitInsn参数：无使用范例：mv.visitInsn(ISUB);mv.visitInsn(DSUB);</code></pre><p>这个字节码用于计算减法（a-b），等价于a+(-b)。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。</p><p>浮点数运算法则请同时参照xadd与xneg。</p><h3 id="乘法运算字节码：xmul"><a href="#乘法运算字节码：xmul" class="headerlink" title="乘法运算字节码：xmul"></a>乘法运算字节码：<i>x</i>mul</h3><p>x=i/l/f/d</p><pre><code class="hljs Java">输入：乘数<span class="hljs-number">1</span> 乘数<span class="hljs-number">2</span>输出：两数字之积方法：visitInsn参数：无使用范例：mv.visitInsn(IMUL);mv.visitInsn(DMUL);</code></pre><p>这个字节码用于计算乘法（a*b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。</p><p>对于浮点数（double和float），这个字节码运算为：</p><ol><li><p>两个数字中有一个是NaN，结果为NaN</p></li><li><p>无穷大乘以一个0，结果为NaN</p></li><li><p>无穷大与有限值相乘，结果为无穷大，符号取决于两个数字的符号是否相同，相同为正，相反为负</p></li><li><p>其余情况为IEEE 754规定，在xadd那里有完整说明</p></li></ol><h3 id="除法运算字节码：xdiv"><a href="#除法运算字节码：xdiv" class="headerlink" title="除法运算字节码：xdiv"></a>除法运算字节码：<i>x</i>div</h3><p>x=i/l/f/d</p><pre><code class="hljs Java">输入：被除数 除数输出：两数字之商方法：visitInsn参数：无使用范例：mv.visitInsn(IDIV);mv.visitInsn(DDIV);</code></pre><p>这个字节码用于计算除法（a/b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。</p><p>对于整数（int和long），这个字节码只会保留商的整数部分。如果除数为0，这个字节码会抛出<code>java.lang.ArithmeticException: / by zero</code></p><p>对于浮点数（double和float），这个字节码运算为：</p><ol><li><p>两个数字中有一个是NaN，结果为NaN</p></li><li><p>无穷大除以无穷大，结果为NaN</p></li><li><p>无穷大除以有限值，结果为无穷大，符号取决于两个数字的符号（规则见xmul）</p></li><li><p>有限值除以无穷大，结果为0，符号同上</p></li><li><p>0除以0为NaN</p></li><li><p>0除以有限值为0，符号同上</p></li><li><p>有限值除以0为无穷大，符号同上</p></li><li><p>其余情况为IEEE 754规定，在xadd那里有完整说明</p></li></ol><h3 id="取余运算字节码：xrem"><a href="#取余运算字节码：xrem" class="headerlink" title="取余运算字节码：xrem"></a>取余运算字节码：<i>x</i>rem</h3><p>x=i/l/f/d</p><pre><code class="hljs Java">输入：被除数 除数输出：余数方法：visitInsn参数：无使用范例：mv.visitInsn(IREM);mv.visitInsn(DREM);</code></pre><p>这个字节码用于计算取余操作（a%b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。</p><p>对于浮点数（double和float），这个字节码运算为：</p><ol><li><p>两个数字中有一个是NaN，结果为NaN</p></li><li><p>符号取决于被除数</p></li><li><p>被除数为无穷大或除数为0，结果为NaN</p></li><li><p>被除数为有限值而除数为无穷大，结果为被除数</p></li><li><p>被除数为0，结果为0</p></li><li><p>其余情况为IEEE 754规定，在xadd那里有完整说明</p></li></ol><h3 id="自增字节码：iinc（iinc-w）"><a href="#自增字节码：iinc（iinc-w）" class="headerlink" title="自增字节码：iinc（iinc_w）"></a>自增字节码：iinc（iinc_w）</h3><pre><code class="hljs Java">输入：无输出：无方法：visitIincInsn参数：对象位置，自增大小（<span class="hljs-keyword">int</span>范围）使用范例：mv.visitIincInsn(<span class="hljs-number">0</span>, <span class="hljs-number">200</span>);mv.visitIincInsn(<span class="hljs-number">1</span>, -<span class="hljs-number">40</span>);</code></pre><p>自增字节码是适用于int的字节码，在以下情境中会用到:</p><ol><li><p>i++或i—或++i或—i</p></li><li><p>i+=x或i-=x</p></li></ol><p>自增字节码可以使用负数。</p><h3 id="按位且运算字节码：xand"><a href="#按位且运算字节码：xand" class="headerlink" title="按位且运算字节码：xand"></a>按位且运算字节码：<i>x</i>and</h3><p>x=i/l</p><pre><code class="hljs Java">输入：整数<span class="hljs-number">1</span> 整数<span class="hljs-number">2</span>输出：按位且的整数方法：visitInsn参数：无使用范例：mv.visitInsn(IAND);</code></pre><p>这个字节码用于计算按位且操作（a&amp;b）。</p><h3 id="按位或运算字节码：xor"><a href="#按位或运算字节码：xor" class="headerlink" title="按位或运算字节码：xor"></a>按位或运算字节码：<i>x</i>or</h3><p>x=i/l</p><pre><code class="hljs Java">输入：整数<span class="hljs-number">1</span> 整数<span class="hljs-number">2</span>输出：按位或的整数方法：visitInsn参数：无使用范例：mv.visitInsn(LOR);</code></pre><p>这个字节码用于计算按位或操作（a|b）。</p><h3 id="按位异或运算字节码：xxor"><a href="#按位异或运算字节码：xxor" class="headerlink" title="按位异或运算字节码：xxor"></a>按位异或运算字节码：<i>x</i>xor</h3><p>x=i/l</p><pre><code class="hljs Java">输入：整数<span class="hljs-number">1</span> 整数<span class="hljs-number">2</span>输出：按位异或的整数方法：visitInsn参数：无使用范例：mv.visitInsn(LXOR);</code></pre><p>这个字节码用于计算按位或操作（a^b）。</p><p>同时，这个字节码还可以用于计算按位取反（这也是JVM的实现）：~x=x^(-1)。</p><pre><code class="hljs Java">mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>);mv.visitInsn(ICONST_M1);mv.visitInsn(IXOR);</code></pre><h3 id="按位左移运算字节码：xshl"><a href="#按位左移运算字节码：xshl" class="headerlink" title="按位左移运算字节码：xshl"></a>按位左移运算字节码：<i>x</i>shl</h3><p>x=i/l</p><pre><code class="hljs Java">输入：整数 左移位数输出：按位左移的整数方法：visitInsn参数：无使用范例：mv.visitInsn(LSHL);</code></pre><p>这个字节码用于计算按位左移操作（a&lt;&lt;b）。如果左移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行左移操作。</p><h3 id="按位右移运算字节码：xshr"><a href="#按位右移运算字节码：xshr" class="headerlink" title="按位右移运算字节码：xshr"></a>按位右移运算字节码：<i>x</i>shr</h3><p>x=i/l</p><pre><code class="hljs Java">输入：整数 右移位数输出：按位右移的整数方法：visitInsn参数：无使用范例：mv.visitInsn(ISHR);</code></pre><p>这个字节码用于计算按位右移操作（a&gt;&gt;b）。如果右移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行右移操作。</p><h3 id="按位无符号右移运算字节码：xushr"><a href="#按位无符号右移运算字节码：xushr" class="headerlink" title="按位无符号右移运算字节码：xushr"></a>按位无符号右移运算字节码：<i>x</i>ushr</h3><p>x=i/l</p><pre><code class="hljs Java">输入：整数 右移位数输出：按位无符号右移的整数方法：visitInsn参数：无使用范例：mv.visitInsn(LUSHR);</code></pre><p>这个字节码用于计算按位无符号右移操作（a&gt;&gt;&gt;b）。如果右移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行无符号右移操作。</p><p>运算字节码说完之后，最后，来看看数字转换的字节码。</p><h3 id="转换为float的字节码：x2f"><a href="#转换为float的字节码：x2f" class="headerlink" title="转换为float的字节码：x2f"></a>转换为float的字节码：<i>x</i>2f</h3><p>x=i/l/d</p><pre><code class="hljs Java">输入：数字输出：转换为<span class="hljs-keyword">float</span>的数字方法：visitInsn参数：无使用范例：mv.visitInsn(I2F);</code></pre><p>转换为float采取了IEEE 754的取值规律，详见xadd。虽然对于int，float转换是由低级拓宽范围，但是由于float值不能取到所有int可表示的数字（float仅有24位精确数字，其他为指数和符号位），所以此转换仍然不精确。</p><h3 id="转换为double的字节码：x2d"><a href="#转换为double的字节码：x2d" class="headerlink" title="转换为double的字节码：x2d"></a>转换为double的字节码：<i>x</i>2d</h3><p>x=i/l/f</p><pre><code class="hljs Java">输入：数字输出：转换为<span class="hljs-keyword">double</span>的数字方法：visitInsn参数：无使用范例：mv.visitInsn(F2D);</code></pre><p>转换为double采取了IEEE 754的取值规律，详见xadd。对于int，这种转换是完全精确的。对于float，如果这个方法是FP-Strict，也就是采取了ACC_STRICT修饰（Java中的strictfp），这个计算就是精确的；如果不是，这个计算可能进行舍入。对于long，由于double值不能取到long表示的所有数字（double仅有53位精确数字，其他为指数和符号位），所以计算不精确。</p><h3 id="转换为int的字节码：x2i"><a href="#转换为int的字节码：x2i" class="headerlink" title="转换为int的字节码：x2i"></a>转换为int的字节码：<i>x</i>2i</h3><p>x=d/l/f</p><pre><code class="hljs Java">输入：数字输出：转换为<span class="hljs-keyword">int</span>的数字方法：visitInsn参数：无使用范例：mv.visitInsn(F2I);</code></pre><p>由于int在四种数字中级别最低，long转换为它时都有可能丢失精度（甚至符号位），float和double会使用IEEE 754“向零舍入”。特殊情况下，如果浮点数的NaN转换为int，值为0；如果浮点数超出int最大范围，则为相应符号下的最大值。</p><h3 id="转换为long的字节码：x2l"><a href="#转换为long的字节码：x2l" class="headerlink" title="转换为long的字节码：x2l"></a>转换为long的字节码：<i>x</i>2l</h3><p>x=i/f/d</p><pre><code class="hljs Java">输入：数字输出：转换为<span class="hljs-keyword">long</span>的数字方法：visitInsn参数：无使用范例：mv.visitInsn(D2L);</code></pre><p>由于long级别大于int，int转换为long不丢失精度。在浮点数下，long与int的转换规则类似。</p><h3 id="int转换为其他基本类型的字节码：i2x"><a href="#int转换为其他基本类型的字节码：i2x" class="headerlink" title="int转换为其他基本类型的字节码：i2x"></a>int转换为其他基本类型的字节码：i2<i>x</i></h3><p>x=b/c/s</p><pre><code class="hljs Java">输入：数字输出：转换为<span class="hljs-keyword">byte</span>/<span class="hljs-keyword">char</span>/<span class="hljs-keyword">short</span>的数字方法：visitInsn参数：无使用范例：mv.visitInsn(I2B);</code></pre><p>这三个字节码能分别将int缩小转换为byte（-128~127）、short（-32768~32767）和char（0~65535）。由于是缩小变换，可能丢失精度甚至符号位。</p><h3 id="下面是使用例子：计算平方和"><a href="#下面是使用例子：计算平方和" class="headerlink" title="下面是使用例子：计算平方和"></a>下面是使用例子：计算平方和</h3><p>Java代码如下：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">computeSquare2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span></span>&#123;<span class="hljs-keyword">return</span> x1 * x1 + x2 * x2;&#125;</code></pre><p>使用ASM写入，如下：</p><pre><code class="hljs Java">ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(ASM9);cw.visit(V1_8, ACC_PUBLIC, <span class="hljs-string">&quot;TestClass&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-keyword">null</span>);MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="hljs-string">&quot;computeSquare2&quot;</span>, <span class="hljs-string">&quot;(II)D&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ILOAD, <span class="hljs-number">0</span>);mv.visitInsn(DUP);mv.visitInsn(IMUL);mv.visitVarInsn(ILOAD, <span class="hljs-number">1</span>);mv.visitInsn(DUP);mv.visitInsn(IMUL);mv.visitInsn(IADD);mv.visitInsn(I2D);mv.visitInsn(DRETURN);mv.visitMaxs(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);mv.visitEnd();cw.visitEnd();</code></pre><p>将生成的类加载并调用，以参数100和21传入，结果为10441.0。</p><p>这篇博客到这里就结束了，下一期：Java ASM详解：MethodVisitor与Opcode（二）类、数组与调用</p><p>这篇文章一共讲了130个字节码呢~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前文我们说到了很多Visitor，它们用于给类中定义类型，添加字段，附上注释。但是对于一个语言来说，最重要的那一部分我们还没有说到——那就是：方法。&lt;/p&gt;
&lt;h2 id=&quot;方法定义&quot;&gt;&lt;a href=&quot;#方法定义&quot; class=&quot;headerlink&quot; title=&quot;方法</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="ASM" scheme="http://nickid2018.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Java ASM详解：ASM库使用</title>
    <link href="http://nickid2018.github.io/2021/02/13/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AASM%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
    <id>http://nickid2018.github.io/2021/02/13/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AASM%E5%BA%93%E4%BD%BF%E7%94%A8/</id>
    <published>2021-02-13T00:00:00.000Z</published>
    <updated>2021-08-30T12:23:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>几个月之后，终于来到了ASM的第二篇专栏（指直接咕了半年）</p><p>这篇专栏主要说一说ASM库怎么用，电脑端观看更佳。</p><h2 id="读取的起源：ClassReader"><a href="#读取的起源：ClassReader" class="headerlink" title="读取的起源：ClassReader"></a>读取的起源：ClassReader</h2><p>ClassReader位于<code>org.objectweb.asm</code>包下（基础类都在这个包），它是读取字节码的开始，通过它我们才能进行字节码解析。</p><p>首先是构造函数：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassReader</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] classFile)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassReader</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] classFileBuffer, <span class="hljs-keyword">int</span> classFileOffset, <span class="hljs-keyword">int</span> classFileLength)</span></span><span class="hljs-function"><span class="hljs-title">ClassReader</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] classFileBuffer, <span class="hljs-keyword">int</span> classFileOffset, <span class="hljs-keyword">boolean</span> checkClassVersion)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassReader</span><span class="hljs-params">(InputStream inputStream)</span> <span class="hljs-keyword">throws</span> IOException</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassReader</span><span class="hljs-params">(String className)</span> <span class="hljs-keyword">throws</span> IOException</span></code></pre><p>这几种构造函数都是以传入数据为目标的：前两个，根据传入的byte数组（第二个指定了偏移量和长度）解析类；倒数第二个，通过<code>InputStream</code>传入；倒数第一个，根据类的全限定名获得对象；中间的则是不开放的API，可以忽略。下面是使用的例子：</p><pre><code class="hljs Java">ClassReader reader = <span class="hljs-keyword">new</span> ClassReader(<span class="hljs-string">&quot;com/github/nickid2018/asm/TestClass&quot;</span>);ClassReader reader2 = <span class="hljs-keyword">new</span> ClassReader(classBytes, <span class="hljs-number">0</span>, <span class="hljs-number">3370</span>);ClassReader reader3 = <span class="hljs-keyword">new</span> ClassReader(inputStreamClassFile);</code></pre><p>说完了对象的构建，下面是它的用法。它最重要的方法是<code>accept</code>，其余的方法基本用不上（都内部自己用的）</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(ClassVisitor classVisitor, <span class="hljs-keyword">int</span> parsingOptions)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(ClassVisitor classVisitor, Attribute[] attributePrototypes, <span class="hljs-keyword">int</span> parsingOptions)</span></span></code></pre><p>先抛开<code>Attribute[]</code>这个参数，这个以后可能会说。第一个参数ClassVisitor是你要传入的访问器：ASM整体是<strong>Visitor设计模式</strong>。最后一个参数int是代表读取模式，它有4个基本取值，这些值可以被or（|）连接：</p><div class="table-container"><table><thead><tr><th style="text-align:center">常量值</th><th style="text-align:left">读取方式</th></tr></thead><tbody><tr><td style="text-align:center">SKIP_CODE</td><td style="text-align:left">跳过代码属性</td></tr><tr><td style="text-align:center">SKIP_DEBUG</td><td style="text-align:left">跳过源文件、局部变量表、局部变量类型表、方法参数列表、行号</td></tr><tr><td style="text-align:center">SKIP_FRAME</td><td style="text-align:left">跳过帧（visitFrame），帧是JVM验证类阶段使用的数据</td></tr><tr><td style="text-align:center">EXPANDS_FRAMES</td><td style="text-align:left">扩展堆栈映射帧</td></tr></tbody></table></div><p>下面是例子：</p><pre><code class="hljs Java">ClassVisitor cv = ...;classReader.accept(cv, <span class="hljs-number">0</span>);classReader.accept(cv, ClassWriter.SKIP_CODE);</code></pre><p>关于ClassReader的使用到这里差不多结束了，下面先讲一下访问标志，然后再说ClassVisitor等类。</p><h2 id="访问标志（Access-Flag）"><a href="#访问标志（Access-Flag）" class="headerlink" title="访问标志（Access Flag）"></a>访问标志（Access Flag）</h2><p>访问标志是用于JVM访问类、字段、方法检查和调用的一个int。这些标志既包含了我们常见的public这种访问限定符，还包含了static、final这种修饰符，除此之外还有声明类为接口的interface，为枚举的enum。</p><p>完整的访问标志如下表（省略了前缀ACC_）：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Access Flag</th><th style="text-align:center">常量值</th><th style="text-align:center">修饰目标</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:center">PUBLIC</td><td style="text-align:center">0x0001</td><td style="text-align:center">class, field, method</td><td style="text-align:left">访问限定，公开</td></tr><tr><td style="text-align:center">PRIVATE</td><td style="text-align:center">0x0002</td><td style="text-align:center">class, field, method</td><td style="text-align:left">访问限定，私密</td></tr><tr><td style="text-align:center">PROTECTED</td><td style="text-align:center">0x0004</td><td style="text-align:center">class, field, method</td><td style="text-align:left">访问限定，受保护</td></tr><tr><td style="text-align:center">STATIC</td><td style="text-align:center">0x0008</td><td style="text-align:center">field, method</td><td style="text-align:left">静态</td></tr><tr><td style="text-align:center">FINAL</td><td style="text-align:center">0x0010</td><td style="text-align:center">class, field, method, parameter</td><td style="text-align:left">对于类为不可继承，对于其他为不可修改</td></tr><tr><td style="text-align:center">SUPER</td><td style="text-align:center">0x0020</td><td style="text-align:center">class</td><td style="text-align:left">调用invokespecial时会特殊处理超类方法</td></tr><tr><td style="text-align:center">SYNCHRONIZED</td><td style="text-align:center">0x0020</td><td style="text-align:center">method</td><td style="text-align:left">同步方法</td></tr><tr><td style="text-align:center">OPEN</td><td style="text-align:center">0x0020</td><td style="text-align:center">module</td><td style="text-align:left">指示模块为开放的</td></tr><tr><td style="text-align:center">TRANSITIVE</td><td style="text-align:center">0x0020</td><td style="text-align:center">module requires</td><td style="text-align:left">指示依赖于此模块的所有模块都隐式依赖此模块</td></tr><tr><td style="text-align:center">VOLATILE</td><td style="text-align:center">0x0040</td><td style="text-align:center">field</td><td style="text-align:left">volatile字段，在内存中不会缓存</td></tr><tr><td style="text-align:center">BRIDGE</td><td style="text-align:center">0x0040</td><td style="text-align:center">method</td><td style="text-align:left">“桥”方法，由编译器生成</td></tr><tr><td style="text-align:center">STATIC_PHASE</td><td style="text-align:center">0x0040</td><td style="text-align:center">module requires</td><td style="text-align:left">指示模块在编译时必须但运行时可选</td></tr><tr><td style="text-align:center">VARARGS</td><td style="text-align:center">0x0080</td><td style="text-align:center">method</td><td style="text-align:left">方法使用@SafeVarargs注解，与static或final连用</td></tr><tr><td style="text-align:center">TRANSIENT</td><td style="text-align:center">0x0080</td><td style="text-align:center">field</td><td style="text-align:left">被默认序列化忽略</td></tr><tr><td style="text-align:center">NATIVE</td><td style="text-align:center">0x0100</td><td style="text-align:center">method</td><td style="text-align:left">本地方法（JNI）</td></tr><tr><td style="text-align:center">INTERFACE</td><td style="text-align:center">0x0200</td><td style="text-align:center">class</td><td style="text-align:left">声明类为接口，与abstract连用</td></tr><tr><td style="text-align:center">ABSTRACT</td><td style="text-align:center">0x0400</td><td style="text-align:center">class, method</td><td style="text-align:left">定义抽象类或抽象方法</td></tr><tr><td style="text-align:center">STRICT</td><td style="text-align:center">0x0800</td><td style="text-align:center">method</td><td style="text-align:left">严格浮点数定义（strictfp），可能在Java 17失效（？）</td></tr><tr><td style="text-align:center">SYNTHETIC</td><td style="text-align:center">0x1000</td><td style="text-align:center">class, field, method, parameter, module *</td><td style="text-align:left">既不属于显性声明也不属于隐式声明，通常是编译器优化生成</td></tr><tr><td style="text-align:center">ANNOTATION</td><td style="text-align:center">0x2000</td><td style="text-align:center">class</td><td style="text-align:left">注解类型，与interface、abstract连用</td></tr><tr><td style="text-align:center">ENUM</td><td style="text-align:center">0x4000</td><td style="text-align:center">class(?) field inner</td><td style="text-align:left">枚举类或枚举字段</td></tr><tr><td style="text-align:center">MANDATED</td><td style="text-align:center">0x8000</td><td style="text-align:center">field, method, parameter, module, module *</td><td style="text-align:left">隐式声明的数据</td></tr><tr><td style="text-align:center">MODULE</td><td style="text-align:center">0x8000</td><td style="text-align:center">class</td><td style="text-align:left">声明这个类是模块定义类</td></tr></tbody></table></div><p>JVM定义的Access Flags，真正我们能用到的不多，详见<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25">https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25</a></p><p>ASM自己也有定义Access Flag，由于JVM定义的有效位只有16位，所以这两个标志不会与JVM的访问标志冲突，但是这些标志在写入类之前必须清除（用&amp;操作即可）</p><div class="table-container"><table><thead><tr><th style="text-align:center">Access Flag</th><th style="text-align:center">常量值</th><th style="text-align:center">修饰目标</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:center">RECORD</td><td style="text-align:center">0x10000</td><td style="text-align:center">class</td><td style="text-align:left">记录类型（record）</td></tr><tr><td style="text-align:center">DEPRECATED</td><td style="text-align:center">0x20000</td><td style="text-align:center">class, field, method</td><td style="text-align:left">弃用，要和@Deprecated连用</td></tr></tbody></table></div><p>这些常量可以用or叠加修饰，如果访问标志不合法（比如吧ACC_PUBLIC和ACC_PRIVATE用or联系起来当了访问标志），在ASM写入时是不会报错的，但是在JVM试图加载这个类的时候可能会抛出<code>ClassFormatError</code>。</p><h2 id="解析类的信息：ClassVisitor"><a href="#解析类的信息：ClassVisitor" class="headerlink" title="解析类的信息：ClassVisitor"></a>解析类的信息：ClassVisitor</h2><p>ClassVisitor是一个抽象类，它的构造函数仅需要ASM API版本（在<code>Opcodes</code>中可以找到，1-9），或者再加上另一个ClassVisitor用于一起解析，下面是一个模板：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassParser</span><span class="hljs-params">(<span class="hljs-keyword">int</span> api)</span> </span>&#123;<span class="hljs-keyword">super</span>(api);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassParser</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>(ASM9);&#125;</code></pre><p>当这个Visitor被传入accept之后，ClassReader会以下面的顺序调用：</p><pre><code class="hljs plaintext">visit [ visitSource ] [ visitModule ][ visitNestHost ][ visitPermittedSubclass ][ visitOuterClass ] ( visitAnnotation | visitTypeAnnotation | visitAttribute )* ( visitNestMember | visitInnerClass | visitRecordComponent | visitField | visitMethod )* visitEnd</code></pre><p>不够清晰？那么下面简单说一下流程：</p><p>首先访问<strong>类的信息</strong>（<code>visit</code>），传入的是<strong>类文件的版本</strong>（version，从V1_1到V16）、<strong>访问标志</strong>（access），<strong>类的全限定名</strong>（name），<strong>泛型签名</strong>（signature，可能为空），<strong>父类全限定名</strong>（无指定为java/lang/Object），<strong>实现接口列表</strong>（全限定名，可为空）</p><p>之后访问<strong>注解信息</strong>（<code>visitAnnotation</code>），传入的是<strong>注解描述符</strong>（descriptor，这里可能包含有@Repeatable的注解类型，所以这里不是全限定名）和<strong>可见性</strong>（visible，@Retention定义的作用范围，为CLASS传入false，为RUNTIME传入true，为SOURCE不会写入类文件），该方法返回<code>AnnotationVisitor</code>。</p><p>同时，访问<strong>泛型注解信息</strong>（<code>visitTypeAnnotation</code>），传入的是<strong>注解引用类型</strong>（typeRef，可能为TypeReference定义的几个值：CLASS_TYPE_PARAMETER \&lt;以泛型类的类型参数为目标的类型引用的类型，常量值0>，CLASS_EXTENDS \&lt;以泛型类的超类或它实现的接口之一为目标的类型引用的类型，常量值16>，CLASS_TYPE_PARAMETER_BOUND \&lt;以泛型类的类型参数的绑定为目标的类型引用的类型，常量值17>），<strong>泛型类引用路径</strong>（可为空），<strong>注解描述符</strong>和<strong>可见性</strong>，返回AnnotationVisitor。</p><p>接着，访问字段、方法和内部类。</p><p>字段调用<code>visitField</code>方法，传入<strong>访问标志，字段名，描述符，泛型签名和默认值</strong>，返回<code>FieldVisitor</code>。</p><p>方法调用<code>visitMethod</code>方法，传入<strong>访问标志，方法名，描述符，泛型签名和异常列表（全限定名）</strong>，返回<code>MethodVisitor</code>。</p><p>内部类调用<code>visitInnerClass</code>方法，传入<strong>内部类全限定名，外部类全限定名，内部类名称</strong>（不带包路径，也就是没有“.”的名称，如果这个写错了IDE无法识别到这个类，但是不影响调用）<strong>，和访问标志</strong>（这个和类声明定义的标志不同，可以有static，这样类里面就不会带有this$0）。内部类调用指的不只是类中定义了内部类，还包括引用到了其他类的内部类。</p><p>当所有信息都访问结束，调用<code>visitEnd</code>。</p><p>这里的内容只是简单介绍了一下，具体的下文和接下来几篇专栏会写。</p><h2 id="解析注解信息：AnnotationVisitor"><a href="#解析注解信息：AnnotationVisitor" class="headerlink" title="解析注解信息：AnnotationVisitor"></a>解析注解信息：AnnotationVisitor</h2><p>AnnotationVisitor用于解析注解信息，除了最后会调用的<code>visitEnd</code>外，其他都与注解类型本身定义的方法返回值有关。下面是不同的类型：</p><p><code>visit</code>方法：传入注解方法名称和值，值必须是基本类型（基本数字、char及其数组，String和类）</p><p><code>visitArray</code>方法：传入注解方法名称，返回另一个AnnotationVisitor。这个新的Visitor会被传入数组内的值，所有的name传入都为null。注意：visit一个基本数字或char数组等价于使用visitArray，但是在ClassReader解析中不会调用visitArray而是直接调用visit。</p><p><code>visitAnnotation</code>方法：传入注解方法名称和值的描述符，返回的是值的AnnotationVisitor。</p><p><code>visitEnum</code>方法：传入注解方法名、值的描述符和枚举名称。</p><p>对于带有<code>@Repeatable</code>注解的注解类型，在Java使用反射时会返回容器注解，也就是在普通编写时有两种等价的编写方式。在ASM中，这两种方式也等价，写入按照第一种处理：</p><pre><code class="hljs Java"><span class="hljs-meta">@T</span>.Ts(value = &#123; <span class="hljs-meta">@T(value = &quot;ss&quot;)</span>, <span class="hljs-meta">@T(value = &quot;dd&quot;)</span> &#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; ... &#125;<span class="hljs-meta">@T(value = &quot;ss&quot;)</span><span class="hljs-meta">@T(value = &quot;dd&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; ... &#125;</code></pre><blockquote><p>对于带有@Repeatable注解的注解类型，这两种使用方式在反射和ASM中完全等价（T.Ts是T的注解容器）</p></blockquote><h2 id="解析字段：FieldVisitor"><a href="#解析字段：FieldVisitor" class="headerlink" title="解析字段：FieldVisitor"></a>解析字段：FieldVisitor</h2><p>FieldVisitor的构成比较简单，除了<code>visitEnd</code>在最后调用外，比较常用的就是<code>visitAnnotation</code>和<code>visitTypeAnnotation</code>。这些方法的使用都和ClassVisitor的使用差不多，唯一的不同是visitTypeAnnotation的注解引用类型必为<code>FIELD</code>（常量值19）</p><p>到此简单的解析就讲完了。什么？还差一个MethodVisitor？这是我们之后要说的重要内容，所以这里不会提到它。接下来，是应用ASM的例子。</p><h2 id="使用范例：解析一个类"><a href="#使用范例：解析一个类" class="headerlink" title="使用范例：解析一个类"></a>使用范例：解析一个类</h2><p>解析一个类需要从文章最开始说的ClassReader写起，它能将一个类的字节码解析并且进行Visitor模式调用。在下面的范例中，我们将尝试读取一个类的名称、字段和注解。</p><p>首先是一个测试类的编写，之后用javac编译。</p><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.github.nickid2018.asm;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span> </span>&#123;<span class="hljs-meta">@Deprecated</span><span class="hljs-keyword">public</span> String string;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> integer;&#125;</code></pre><p>接着，我们尝试读取这个类的信息，因为测试类和运行ASM的类在同一个项目之下，可以用它的全限定名初始化ClassReader。</p><pre><code class="hljs Java">ClassReader reader = <span class="hljs-keyword">new</span> ClassReader(<span class="hljs-string">&quot;com/github/nickid2018/asm/TestClass&quot;</span>);</code></pre><p>之后我们需要继承三个Visitor：ClassVisitor、FieldVisitor和AnnotationVisitor。我们只需要一些信息，所以不需要将它们的所有方法进行覆盖。</p><p>创建一个ClassParser继承ClassVisitor，选择要覆盖的方法。在访问类的时候，我们只需要类名，所以需要覆盖visit；又因为需要解析字段，我们还需要覆盖visitField，并且将我们的字段访问器作为返回值。</p><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;<span class="hljs-keyword">super</span>(version, access, name, signature, superName, interfaces);System.out.println(<span class="hljs-string">&quot;类名: &quot;</span> + name);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> FieldVisitor <span class="hljs-title">visitField</span><span class="hljs-params">(<span class="hljs-keyword">int</span> access, String name, String descriptor, String signature, Object value)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;字段: &quot;</span> + name + <span class="hljs-string">&quot; 描述符: &quot;</span> + descriptor);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FieldParser();&#125;</code></pre><p>创建FieldParser继承FieldVisitor解析字段。在读取字段时，我们还需要读取字段中的注解，所以需要覆盖visitAnnotation，返回我们自己的AnnotationVisitor。</p><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title">visitAnnotation</span><span class="hljs-params">(String descriptor, <span class="hljs-keyword">boolean</span> visible)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;注解: &quot;</span> + descriptor + <span class="hljs-string">&quot; 可见性: &quot;</span> + visible);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationParser();&#125;</code></pre><p>由于@Deprecated不具有任何的注解方法，我们创建的AnnotationParser可以不覆盖任何方法。</p><p>这些访问器写完之后，就要递呈给ClassReader开始解析，代码如下：</p><pre><code class="hljs Java">ClassParser cv = <span class="hljs-keyword">new</span> ClassParser();reader.accept(cv, <span class="hljs-number">0</span>);</code></pre><p>现在，我们的解析程序就完成了。运行结果如下：</p><pre><code class="hljs plaintext">类名: com/github/nickid2018/asm/TestClass字段: string 描述符: Ljava/lang/String;注解: Ljava/lang/Deprecated; 可见性: true字段: integer 描述符: I</code></pre><p>代码样例：<a href="https://paste.ubuntu.com/p/8d6jN8jVzr/">https://paste.ubuntu.com/p/8d6jN8jVzr/</a></p><h2 id="使用范例：生成一个类"><a href="#使用范例：生成一个类" class="headerlink" title="使用范例：生成一个类"></a>使用范例：生成一个类</h2><p>生成类我们用到的是ClassWriter，它本质上就是ClassVisitor，我们只要用可以构建类的数据按照刚才的格式传给它就能生成对应的类。</p><p>它的构造函数有两个，一个只传入一个int，它的值可为三个数：0、COMPUTE_MAXS和COMPUTE_FRAMES。那两个常量值是自动计算方法visitMaxs和visitFrame的，对于现在来说还用不到。另一个构造函数还需要传入ClassReader，这是下一部分可能用到的。</p><p>首先确定我们要构建产生的类：</p><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.github.nickid2018.asm;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WillGenerate</span> </span>&#123;<span class="hljs-meta">@Deprecated</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HELLO = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> String hi;&#125;</code></pre><p>首先创建ClassWriter实例：</p><pre><code class="hljs Java">ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(<span class="hljs-number">0</span>);</code></pre><p>接着，创建类，用到的正是visit方法。由于没有指定父类，这个类的父类将被强行指定为java/lang/Object，接口、抽象类、注解类型也如此。这个类没有实现任何接口，所以interfaces可以传null。同理，它没有泛型，所以泛型的signature为null。访问标志是public，再加上super，整体下来就是这句：</p><pre><code class="hljs Java">cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, <span class="hljs-string">&quot;com/github/nickid2018/asm/WillGenerate&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>,<span class="hljs-keyword">null</span>);</code></pre><p>接下来我们需要创建默认构造函数。javac编译时会把没有定义构造函数的普通类加入默认的构造函数。这种构造函数里面包括了父类构造函数调用和本身的非基本类型字段赋值。如果没有非基本类型字段赋值，那么它的代码就像这样：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WillGenerate</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>();&#125;</code></pre><p>由于这篇专栏主要是有关于类、字段、注解的解析，方法的解析暂时先不讲，所以这里只给出它的写入代码，不做讲解。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeDefaultInit</span><span class="hljs-params">(ClassWriter cw)</span> </span>&#123;MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);mv.visitVarInsn(ALOAD, <span class="hljs-number">0</span>);mv.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">false</span>);mv.visitInsn(RETURN);mv.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);mv.visitEnd();&#125;</code></pre><p>接下来写入HELLO这个字段。它的访问标志是public+static+final，由于它是弃用的，它也可以加上deprecated这个ASM自己定义的Access Flag。它的类型是int，所以描述符是I。没有泛型，所以signature为null。有默认值，为0。所以它的写入像这样：</p><pre><code class="hljs Java">FieldVisitor fv = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC + ACC_DEPRECATED, <span class="hljs-string">&quot;HELLO&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-keyword">null</span>, (Integer) <span class="hljs-number">0</span>);</code></pre><p>保留这个FieldVisitor，因为它还具有一个注解@Deprecated。注解类型的描述符为Ljava/lang/Deprecated;。又因为@Deprecated的作用范围是RUNTIME，所以可见性为true，代码如下：</p><pre><code class="hljs Java">AnnotationVisitor av = fv.visitAnnotation(<span class="hljs-string">&quot;Ljava/lang/Deprecated;&quot;</span>, <span class="hljs-keyword">true</span>);</code></pre><p>这时，这个字段就写入信息就完成了，调用visitEnd。</p><pre><code class="hljs Java">av.visitEnd();fv.visitEnd();</code></pre><p>下面写hi这个字段，和上面的差不多，直接给代码：</p><pre><code class="hljs Java">fv = cw.visitField(ACC_PRIVATE, <span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);fv.visitEnd();</code></pre><p>这时候类的所有信息都已经写完了，调用ClassWriter的visitEnd。</p><pre><code class="hljs Java">cw.visitEnd();</code></pre><p>接下来调用ClassWriter的toByteArray获得字节码信息，写入到文件中就能得到类。</p><p>运行之后调用反编译器的结果：</p><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.github.nickid2018.asm;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WillGenerate</span></span><span class="hljs-class"></span>&#123;<span class="hljs-meta">@Deprecated</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HELLO = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> String hi;&#125;</code></pre><p>代码样例：<a href="https://paste.ubuntu.com/p/cqfDPVZbsH/">https://paste.ubuntu.com/p/cqfDPVZbsH/</a></p><h2 id="使用范例：修改一个类"><a href="#使用范例：修改一个类" class="headerlink" title="使用范例：修改一个类"></a>使用范例：修改一个类</h2><p>修改类需要ClassReader和ClassWriter互相配合。利用ClassVisitor等进行数据的转移和修改。</p><p>接下来用ASM改一下我们的TestClass。</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span> </span>&#123;<span class="hljs-comment">// 改为抽象类</span><span class="hljs-meta">@Deprecated</span><span class="hljs-keyword">public</span> String string;               <span class="hljs-comment">// 重命名为str</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> integer;<span class="hljs-comment">// 加上final和默认值10</span>&#125;</code></pre><p>首先，创建ClassReader和ClassWriter。</p><pre><code class="hljs Java">ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(<span class="hljs-number">0</span>);ClassReader cr  = <span class="hljs-keyword">new</span> ClassReader(<span class="hljs-string">&quot;com/github/nickid2018/asm/TestClass&quot;</span>);</code></pre><p>之后在我们的ClassParser里面改一下，传入一个ClassWriter，使用父类的第二个构造函数：以int，ClassVisitor为参数的构造函数。这样，ClassReader传入的信息可以直接写到ClassWriter里面，我们只需要修改我们所需要的方法就可以达到修改的效果，而不用将所有ClassVisitor的方法实现。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassParser</span><span class="hljs-params">(ClassWriter cw)</span> </span>&#123;<span class="hljs-keyword">super</span>(ASM9, cw);&#125;</code></pre><p>接下来解决第一个修改：改为抽象类。这个我们可以在visit里面修改，将原先的访问标志加一个abstract就好。</p><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;<span class="hljs-keyword">super</span>.visit(version, access + ACC_ABSTRACT, name, signature, superName, interfaces);&#125;</code></pre><p>第二个修改是重命名字段。这个在visitField里面判断就行，像下面一样：</p><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;string&quot;</span>))<span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.visitField(access, <span class="hljs-string">&quot;str&quot;</span>, descriptor, signature, value);</code></pre><p>第三个就是修改为final和加默认值，也是在visitField里面改动：</p><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;integer&quot;</span>))<span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.visitField(access + ACC_FINAL, name, descriptor, signature, (Integer) <span class="hljs-number">10</span>);</code></pre><p>最后用accept传入ClassParser，输出文件就是改好的类文件。</p><pre><code class="hljs Java">cr.accept(<span class="hljs-keyword">new</span> ClassParser(cw), <span class="hljs-number">0</span>);</code></pre><p>生成之后，用反编译器看一下结果。</p><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.github.nickid2018.asm;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span><span class="hljs-class"></span>&#123;<span class="hljs-meta">@Deprecated</span><span class="hljs-keyword">public</span> String str;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> integer = <span class="hljs-number">10</span>;&#125;</code></pre><p>代码样例：<a href="https://paste.ubuntu.com/p/yXVvdJs3WH/">https://paste.ubuntu.com/p/yXVvdJs3WH/</a></p><hr><p>这篇专栏到这里就结束了，下一期专栏：MethodVisitor和Opcode（一）</p><p>如果文章中有任何错误，可以在评论区留言，我将会修正错误。</p><p>如果使用ASM中有问题，可以在下面评论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;几个月之后，终于来到了ASM的第二篇专栏（指直接咕了半年）&lt;/p&gt;
&lt;p&gt;这篇专栏主要说一说ASM库怎么用，电脑端观看更佳。&lt;/p&gt;
&lt;h2 id=&quot;读取的起源：ClassReader&quot;&gt;&lt;a href=&quot;#读取的起源：ClassReader&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="ASM" scheme="http://nickid2018.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Java ASM详解： 基础知识</title>
    <link href="http://nickid2018.github.io/2020/07/23/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://nickid2018.github.io/2020/07/23/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-07-23T00:00:00.000Z</published>
    <updated>2021-08-29T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASM是什么，字节码又是什么"><a href="#ASM是什么，字节码又是什么" class="headerlink" title="ASM是什么，字节码又是什么"></a>ASM是什么，字节码又是什么</h2><blockquote><p>ASM是一个Java字节码分析、创建和修改的开源应用框架。它可以动态生成二进制格式的stub类或其他代理类，或者在类被Java虚拟机装入内存之前，动态修改类。在ASM中提供了诸多的API用于对类的内容进行字节码操作的方法。与传统的BCEL和SERL不同，在ASM中提供了更为优雅和灵活的操作字节码的方式</p></blockquote><p>这是ASM官网上给出的<del>没用解释</del>，一句话概括：ASM是一个修改，分析Java类文件的框架。先抛开ASM框架的基本定义，先来看看字节码是什么</p><blockquote><p>字节码（Byte-code）是一种包含执行程序，由一序列 op 代码/数据对组成的二进制文件</p></blockquote><p>又是一段<del>废话</del>。从这里可以的知，字节码是一种介于翻译语言和底层语言的东西，与底层语言（C/C++）相比较你可以从它这里知道程序的运行方式，而与翻译语言（JavaScript）对比来看，你又无法从字节码中轻易看出什么。但是由于字节码的这个特性，我们得以修改它，操纵它，并且我们还可以反编译它。</p><hr><p><img src="/resources/2021030701/asm_picture.jpg" alt="ASM图标"></p><p>官网：<a href="https://asm.ow2.io/">https://asm.ow2.io/</a></p><h2 id="添加ASM库依赖"><a href="#添加ASM库依赖" class="headerlink" title="添加ASM库依赖"></a>添加ASM库依赖</h2><p>首先，是有关于ASM的Maven依赖<br><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.ow2.asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0_BETA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></p><p>或者</p><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.ow2.asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.ow2.asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.ow2.asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm-tree<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.ow2.asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm-analysis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>如果使用第一种，那么你最高能依赖的版本是6.0_BETA。而第二种是现在仍在持续更新的，它相当于把原先的asm-all库分开成为不同的部分，但是基本的asm库是必须的。</p><p>这个库以后会详细讲述，这里先说几个强有力的工具。</p><h2 id="帮助学习ASM的工具"><a href="#帮助学习ASM的工具" class="headerlink" title="帮助学习ASM的工具"></a>帮助学习ASM的工具</h2><h3 id="ASMifier-自动生成ASM代码"><a href="#ASMifier-自动生成ASM代码" class="headerlink" title="ASMifier: 自动生成ASM代码"></a>ASMifier: 自动生成ASM代码</h3><p>ASM库中有不少实用类，为了了解晦涩难懂的ASM代码，可以用ASMifier来进行解析。这是一个可执行类，你可以通过java.exe运行它。</p><font color="#ff0000">注意：在9.0已经没有这个类了</font><p>运行方法：下载ASM的jar（比如asm-all-6.0_beta.jar）或者从你的.m2文件夹（asm-all）里面找到它，然后运行：</p><pre><code class="hljs SH">java -classpath asm-all-6.0_BETA.jar org.objectweb.asm.util.ASMifier DemoDump.class</code></pre><p>你会得到这样的输出：</p><p><img src="/resources/2021030701/asmifier_run.png" alt="运行ASMifier的效果"></p><h3 id="javap-exe-Java自带的字节码解析工具"><a href="#javap-exe-Java自带的字节码解析工具" class="headerlink" title="javap.exe: Java自带的字节码解析工具"></a>javap.exe: Java自带的字节码解析工具</h3><p>javap是你在安装JDK时就有的一个程序文件，是JDK的原生字节码解析工具，关于它的使用因篇幅有限不再细说，可以参考这篇文章 <a href="https://www.cnblogs.com/frinder6/articles/5440173.html">https://www.cnblogs.com/frinder6/articles/5440173.html</a></p><p><img src="/resources/2021030701/javap_run.png" alt="运行javap的效果"></p><h3 id="Eclipse插件-Enhanced-Class-Decompiler"><a href="#Eclipse插件-Enhanced-Class-Decompiler" class="headerlink" title="Eclipse插件: Enhanced Class Decompiler"></a>Eclipse插件: Enhanced Class Decompiler</h3><p>这个插件是反编译器，可以在你没有库的源代码时反编译出源代码进行调试。当然，这个也可以作为你ASM程序的结果测试方案，通常反编译结果会很贴近于源代码，如果相差很大可以换一种方式反编译。</p><hr><h2 id="ASM中经常会用到的名词"><a href="#ASM中经常会用到的名词" class="headerlink" title="ASM中经常会用到的名词"></a>ASM中经常会用到的名词</h2><h3 id="类-型-的不同名称"><a href="#类-型-的不同名称" class="headerlink" title="类(型)的不同名称"></a>类(型)的不同名称</h3><ul><li>类的二进制名称/类全名/简单名称</li></ul><p>这个三个名称是等价的，也就是我们平常说的类名，例如 java.lang.Thread java.lang.Thread$UncaughtExceptionHandler这样的名称。</p><ul><li>全限定名</li></ul><p>这个名称是用于class文件中的名称，其实就是将二进制名称的所有”.”换为”/“，这个名称只有非数组引用类型才有。例如 java/lang/Thread   java/io/IOException。</p><ul><li>类型描述符</li></ul><p>类型描述符是有关于class文件内定义字段等的类型的名称。</p><h3 id="类型描述符"><a href="#类型描述符" class="headerlink" title="类型描述符"></a>类型描述符</h3><ul><li>原始类型的描述符一一对应</li></ul><p>原始类型的描述符都对应相应的一个字母，具体来说是这样的：</p><pre><code class="hljs Java"><span class="hljs-keyword">byte</span> -&gt; B<span class="hljs-keyword">short</span> -&gt; S<span class="hljs-keyword">int</span> -&gt; I<span class="hljs-keyword">long</span> -&gt; J<span class="hljs-keyword">float</span> -&gt; F<span class="hljs-keyword">double</span> -&gt; D<span class="hljs-keyword">char</span> -&gt; C<span class="hljs-keyword">void</span> -&gt; V<span class="hljs-keyword">boolean</span> -&gt; Z</code></pre><ul><li><p>非数组的引用类型为 L+全限定名+;</p></li><li><p>数组引用类型为 [+数组内类型的描述符</p></li></ul><p>例子:</p><pre><code class="hljs Java">java.lang.Thread -&gt; Ljava/lang/Thread;java.lang.Object[] -&gt; [Ljava/lang/Object;<span class="hljs-keyword">int</span>[][] -&gt; [[I</code></pre><h3 id="方法描述符"><a href="#方法描述符" class="headerlink" title="方法描述符"></a>方法描述符</h3><p>了解类名称和类型描述符，下面讲一下方法描述符（其实类型描述符和方法描述符统称描述符）</p><p>方法描述符是class文件中保存参数类型列表和返回值类型的方式，在各种方法调用的操作码里面都会涉及到。</p><p>规则：</p><ol><li>格式为 ( + 参数列表 + ) + 返回值</li><li>所有类型名称都为类型描述符</li><li>参数列表中不需要逗号分隔</li></ol><p>下面是抽象含义下的具体例子（省略了参数名称，只保留了参数类型）：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span> -&gt; <span class="hljs-params">(III)</span>V</span><span class="hljs-function">String <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-keyword">double</span>[],<span class="hljs-keyword">boolean</span>)</span> -&gt; <span class="hljs-params">([DZ)</span>Ljava/lang/String</span>;<span class="hljs-keyword">int</span>[] i(Object) -&gt; (Ljava/lang/Object;)[<span class="hljs-function">I</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">t</span><span class="hljs-params">()</span> -&gt; <span class="hljs-params">()</span>V</span></code></pre><h3 id="操作码-OpCode"><a href="#操作码-OpCode" class="headerlink" title="操作码(OpCode)"></a>操作码(OpCode)</h3><p>Opcode是用于JVM解释运行Java程序的关键。每一个Opcode都有自己独特的含义与操作，如0x60，助记符iadd，将两个int相加。</p><p>有一点要注意：操作码其实就是一个数字，我们平时经常看到的<code>iadd</code>，<code>invokestatic</code>并不是操作码，而是助记符。</p><p>而Java中字节码的名称也与操作码有关，因为每个操作码都是用一个字节，所以叫字节码。</p><p>每一个字节用来表示一个指令，理论上可以有 256 个操作码。</p><p>对于ASM库来说，所有的Opcode都存储于<code>org.objectweb.asm.Opcodes</code>里面，其中还有包括它们在什么方法中作用的注释。</p><p>有关于所有操作码的网页：<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html</a></p><hr><p>这是ASM系列的第一篇，之后会持续更新。</p><p>bilibili专栏同步： <a href="https://www.bilibili.com/read/cv6875366">https://www.bilibili.com/read/cv6875366</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ASM是什么，字节码又是什么&quot;&gt;&lt;a href=&quot;#ASM是什么，字节码又是什么&quot; class=&quot;headerlink&quot; title=&quot;ASM是什么，字节码又是什么&quot;&gt;&lt;/a&gt;ASM是什么，字节码又是什么&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ASM是一个Jav</summary>
      
    
    
    
    <category term="Java" scheme="http://nickid2018.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://nickid2018.github.io/tags/Java/"/>
    
    <category term="ASM" scheme="http://nickid2018.github.io/tags/ASM/"/>
    
  </entry>
  
</feed>
