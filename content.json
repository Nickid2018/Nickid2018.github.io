{"meta":{"title":"Nickid2018的博客","subtitle":"","description":"","author":"Nickid2018","url":"http://Nickid2018.github.io","root":"/"},"pages":[{"title":"","date":"2021-11-04T06:49:51.730Z","updated":"2021-11-04T06:49:51.730Z","comments":true,"path":"about/index.html","permalink":"http://nickid2018.github.io/about/index.html","excerpt":"","text":"啊，关于这个界面暂时不会存在的（"},{"title":"","date":"2021-11-04T05:53:11.689Z","updated":"2021-11-04T05:53:11.689Z","comments":true,"path":"links/index.html","permalink":"http://nickid2018.github.io/links/index.html","excerpt":"","text":""},{"title":"2048小游戏","date":"2021-11-09T17:19:34.000Z","updated":"2021-11-10T09:42:59.448Z","comments":true,"path":"games/2048.html","permalink":"http://nickid2018.github.io/games/2048.html","excerpt":"","text":"// Colors of numbers colors = { 2 : '#B4E2E4', 4 : '#A3BBE1', 8 : '#9C99E3', 16 : '#AB92E6', 32 : '#BE8EE8', 64 : '#D079E3', 128 : '#C666BC', 256 : '#C54B8A', 512 : '#C14360', 1024 : '#DF4E4E', 2048 : '#CA764F', 4096 : '#D5A359', 8192 : '#CDD15A', 16384 : '#9EC851', 32768 : '#8DDA5D', 65536 : '#369944', 131072: '#114514' }; // Game Table function init() { gameTable = new Array(); prevTable = new Array(); availableSlots = new Array(); { // Fill for (i = 0; i < 4; i++) { gameTable[i] = new Array(); prevTable[i] = new Array(); for(j = 0; j < 4; j++) { gameTable[i][j] = 0; prevTable[i][j] = 0; } } for (i = 0; i < 16; i++) availableSlots[i] = i; } maxValue = 0; spawnRandomValue(); spawnRandomValue(); score = 0; if(ctx != null) { document.getElementById(\"currentScore\").innerHTML = \"现在得分：\" + score; document.getElementById(\"maxValue\").innerHTML = \"最大值：\" + maxValue; } } ctx = null; maxValue = 0; init(); function spawnRandomValue() { var spawnIndex = parseInt(Math.random() * availableSlots.length); var spawnAt = availableSlots[spawnIndex]; var number = (Math.random() > 0.95 ? 4 : 2); gameTable[parseInt(spawnAt / 4)][parseInt(spawnAt % 4)] = number; var tmpSlots = availableSlots; availableSlots = tmpSlots.slice(0, spawnAt).concat(tmpSlots.slice(spawnAt + 1, tmpSlots.length)); spawnData = { slot : spawnAt, data : number }; maxValue = Math.max(maxValue, number); } function checkContinue() { if(availableSlots.length > 0) return true; for(i = 0; i < 4; i++) for(j = 0; j < 4; j++) if((i != 3 && gameTable[i][j] == gameTable[i + 1][j]) || (j != 3 && gameTable[i][j] == gameTable[i][j + 1])) return true; return false; } function getPosition(direction, rowCount, columnCount) { if(direction == 0) // UP return columnCount * 4 + rowCount; else if (direction == 1) // DOWN return (3 - columnCount) * 4 + rowCount; else if (direction == 2) // LEFT return rowCount * 4 + columnCount; else if (direction == 3) //RIGHT return rowCount * 4 + 3 - columnCount; } function getNumber(direction, rowCount, columnCount) { if(direction == 0) // UP return gameTable[columnCount][rowCount]; else if (direction == 1) // DOWN return gameTable[3 - columnCount][rowCount]; else if (direction == 2) // LEFT return gameTable[rowCount][columnCount]; else if (direction == 3) // RIGHT return gameTable[rowCount][3 - columnCount]; } function setNumber(direction, rowCount, columnCount, number) { if(direction == 0) // UP gameTable[columnCount][rowCount] = number; else if (direction == 1) // DOWN gameTable[3 - columnCount][rowCount] = number; else if (direction == 2) // LEFT gameTable[rowCount][columnCount] = number; else if (direction == 3) // RIGHT gameTable[rowCount][3 - columnCount] = number; } // Rendering data ... stayData = new Array(); moveData = new Array(); spawnData = null; function move(direction) { if(direction > 3 || direction < 0){ alert(\"Error in moving!\"); return; } for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) prevTable[i][j] = gameTable[i][j]; availableSlots = new Array(); for (i = 0; i < 4; i++) { var prevElement = -1; var numberQueue = new Array(); for(j = 0; j < 4; j++) { var number = getNumber(direction, i, j); if(number == prevElement) { score += (numberQueue[numberQueue.length - 1] *= 2); moveData.push({ from : getPosition(direction, i, j), to : getPosition(direction, i, numberQueue.length - 1), data : number }); prevElement = -1; } else if (number != 0) { numberQueue[numberQueue.length] = number; prevElement = number; if(j == numberQueue.length - 1) stayData.push({ slot : getPosition(direction, i, j), data : number }); else moveData.push({ from : getPosition(direction, i, j), to : getPosition(direction, i, numberQueue.length - 1), data : number }); } } for(j = 0; j < 4; j++) { if(j >= numberQueue.length) { availableSlots.push(getPosition(direction, i, j)); setNumber(direction, i, j, 0); } else { setNumber(direction, i, j, numberQueue[j]); maxValue = Math.max(maxValue, numberQueue[j]); } } } availableSlots.sort(); var moveSuccess = false; for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) moveSuccess |= prevTable[i][j] != gameTable[i][j]; if (moveSuccess){ spawnRandomValue(); checkContinue(); } return moveSuccess; } // Rendering moveAnimation = false; timeStampStartAnimation = -1; function renderSingleElement(posStartX, posStartY, number, ctx) { ctx.fillStyle = colors[number] == null ? 'white' : colors[number]; ctx.beginPath(); ctx.moveTo(posStartX, posStartY + 1); ctx.arcTo(posStartX, posStartY, posStartX + 1, posStartY, 1); ctx.lineTo(posStartX + 21, posStartY); ctx.arcTo(posStartX + 22, posStartY, posStartX + 22, posStartY + 1, 1); ctx.lineTo(posStartX + 22, posStartY + 21); ctx.arcTo(posStartX + 22, posStartY + 22, posStartX + 21, posStartY + 22, 1); ctx.lineTo(posStartX + 1, posStartY + 22); ctx.arcTo(posStartX, posStartY + 22, posStartX, posStartY + 21, 1); ctx.closePath(); ctx.fill(); ctx.fillStyle = colors[number] == null ? 'black' : 'white'; ctx.font = \"12px consolas\"; ctx.textAlign = \"center\"; ctx.textBaseline = \"middle\"; ctx.fillText(number + \"\", posStartX + 11, posStartY + 11, 20); } function renderAnimation(ctx) { var timeNow = new Date().getTime(); if (timeNow - timeStampStartAnimation > 200) { stayData = new Array(); moveData = new Array(); spawnData = null; moveAnimation = false; setTimeout(\"\", 1); render(); return; } if (timeNow - timeStampStartAnimation < 150) { // Move Rendering stayData.forEach(function(data) { renderSingleElement((data.slot % 4) * 26.0 + 4, parseInt(data.slot / 4) * 26.0 + 4, data.data, ctx); }); moveData.forEach(function(data) { var progress = (timeNow - timeStampStartAnimation) / 150.0; var fromX = (data.from % 4) * 26 + 4; var toX = (data.to % 4) * 26 + 4; var x = progress * toX + (1 - progress) * fromX; var fromY = parseInt(data.from / 4) * 26 + 4; var toY = parseInt(data.to / 4) * 26 + 4; var y = progress * toY + (1 - progress) * fromY; renderSingleElement(x, y, data.data, ctx); }); } else { var progress = (timeNow - timeStampStartAnimation) / 50 - 3; for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) { if(spawnData.slot != i * 4 + j) { var numberNow = gameTable[i][j]; if (numberNow != 0) renderSingleElement(4 + 26 * j, 4 + 26 * i, numberNow, ctx); } } ctx.scale(progress, progress); var x = ((spawnData.slot % 4) * 26.0 + 4 + 10 * (1 - progress)) / progress; var y = (parseInt(spawnData.slot / 4) * 26.0 + 4 + 10 * (1 - progress)) / progress; renderSingleElement(x, y, spawnData.data, ctx); } setTimeout(render, 3); } function render() { ctx.restore(); ctx.save(); ctx.scale(1, 1); ctx.clearRect(0, 0, 540, 540); // Background ctx.fillStyle = 'rgb(240, 240, 240)'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(540, 0); ctx.lineTo(540, 540); ctx.lineTo(0, 540); ctx.closePath(); ctx.fill(); // Slots ctx.fillStyle = 'white'; ctx.scale(5, 5); for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) { ctx.beginPath(); ctx.moveTo(4 + 26 * i, 5 + 26 * j); ctx.arcTo(4 + 26 * i, 4 + 26 * j, 5 + 26 * i, 4 + 26 * j, 1); ctx.lineTo(25 + 26 * i, 4 + 26 * j); ctx.arcTo(26 + 26 * i, 4 + 26 * j, 26 + 26 * i, 5 + 26 * j, 1); ctx.lineTo(26 + 26 * i, 25 + 26 * j); ctx.arcTo(26 + 26 * i, 26 + 26 * j, 25 + 26 * i, 26 + 26 * j, 1); ctx.lineTo(5 + 26 * i, 26 + 26 * j); ctx.arcTo(4 + 26 * i, 26 + 26 * j, 4 + 26 * i, 25 + 26 * j, 1); ctx.closePath(); ctx.fill(); } if(moveAnimation) { renderAnimation(ctx); } else { for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) { var numberNow = gameTable[i][j]; if (numberNow != 0) renderSingleElement(4 + 26 * j, 4 + 26 * i, numberNow, ctx); } } } window.onload = function() { canvas = document.getElementById(\"play2048\"); ctx = canvas.getContext(\"2d\"); window.onkeydown = function(event) { var success = true; if(event.keyCode >= 37 && event.keyCode"},{"title":"休闲小游戏","date":"2021-11-09T17:19:34.000Z","updated":"2022-02-13T04:25:08.916Z","comments":true,"path":"games/index.html","permalink":"http://nickid2018.github.io/games/index.html","excerpt":"","text":"2048小游戏"}],"posts":[{"title":"Java ASM详解：注解","slug":"Java ASM详解：注解","date":"2022-10-21T00:00:00.000Z","updated":"2022-10-26T15:25:31.484Z","comments":true,"path":"2022/10/21/Java ASM详解：注解/","link":"","permalink":"http://nickid2018.github.io/2022/10/21/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"在 Java 语言中，注解（Annotation）是很重要的一部分。它的存在让许多代码变得简洁。与注解执行器（AnnotationProcessor）结合之后，它能发挥出意想不到的功能。这篇文章就将讲述注解是什么写入在字节码中的。 注解类型的定义在前文（类的结构二）中已经写过了，如果不了解注解类型的写入可以先查看那一篇文章。 写入注解信息写入注解信息需要用到AnnotationVisitor这个类，它含有的方法支持我们对注解添加信息。 写入常量写入常量需要使用visit方法，它的第一个参数代表注解属性的名称，第二个参数代表值。可以写入的常量类型有：8种基本类型、字符串和Type 对象（不包括方法描述符）。 写入枚举常量写入枚举常量需要使用visitEnum方法，第一个参数仍然是注解属性的名称，第二个是枚举对象的类型描述符，第三个是枚举对象的名称。 写入其他注解类型写入其他注解类型对象需要使用visitAnnotation方法，第一个参数是注解属性名称，第二个是要写入的注解类型的类型描述符。这个方法返回一个新的AnnotationVisitor，使用这个新的 visitor 可以填充要写入的注解类型对象的信息。 假如说我们要写入下面的注解： // 省略 Target 等描述注释 @interface TestAnno &#123; String testStr(); Class&lt;?&gt; testClass(); &#125; @interface Test &#123; TestEnum testEnum(); TestAnno testAnnotation(); &#125; @Test(testEnum = TestEnum.A, testAnnotation = @TestAnno(testStr = &quot;Test&quot;, testClass = Test.class)) 我们需要写下面这些代码： // 已省略 Test 的 AnnotationVisitor 的创建，名称为av av.visitEnum(&quot;testEnum&quot;, &quot;LTestEnum;&quot;, &quot;A&quot;); // 写入 testEnum AnnotationVisitor av1 = av.visitAnnotation(&quot;testAnnotation&quot;, &quot;LTestAnno;&quot;); // 写入 testAnnotation av1.visit(&quot;testStr&quot;, &quot;Test&quot;); // 写入 testStr av1.visit(&quot;testClass&quot;, Type.of(&quot;LTest;&quot;)); // 写入 testClass av1.visitEnd(); 写入数组除了上述类型之外，注解类型还允许在注解中定义一维数组。写入数组需要用到visitArray方法，参数为注解属性名称，返回一个新的AnnotationVisitor用于填充这个数组。写入数组信息时，所有的注解属性名称都要写为null，并且不允许再调用visitArray，因为注解类型不允许二维及多维数组的存在。 下面是一个例子： // 省略 Target 等描述注释 @interface Test &#123; String[] value(); &#125; @Test(&#123;&quot;test1&quot;, &quot;test2&quot;&#125;) 写入需要下面的代码： // 已省略 Test 的 AnnotationVisitor 的创建，名称为av AnnotationVisitor av1 = av.visitArray(&quot;value&quot;); av1.visit(null, &quot;test1&quot;); av1.visit(null, &quot;test2&quot;); av1.visitEnd(); 写入带有@Repeatable注解的注解类型通常情况下，一个注解位置每个注解类型只能声明一次，但是带有@Repeatable的注解类型可以多次声明。假设有下面的注解类型： // 省略 Target 等描述注释 @Repeatable(TestContainer.class) @interface Test &#123; String value(); &#125; @interface TestContainer &#123; Test[] value(); &#125; 如果在注释位置上只有一个Test注解，那么写入时只需要写Test；但是如果一个位置上有多个Test注解，则应该使用TestContainer进行等效代替并写入，像下面这样： @Test(&quot;hello&quot;) @Test(&quot;world&quot;) // 等价于 ... @TestContainer(&#123;@Test(&quot;hello&quot;), @Test(&quot;world&quot;)&#125;) 注解类型的可见性根据不同注解类型的作用，在定义注解类型时我们通常都会设置它的可见性，也就是使用@Retention进行设置。 RetentionPolicy SOURCE CLASS RUNTIME 写入类文件 false true true 可见性 - false true 可见性影响了反射时我们能不能访问到这个注解，如果不写则默认为false。 注解的写入位置注解不是哪里都能写入的，它有一套非常详细的使用方法，下面我们将分类讲解。 类和类成员定义时的注解当类与类的成员（字段、方法、记录元素）被定义时，它可以附加注解，例如： @Retention(RetentionPolicy.RUNTIME) public @interface TestAnnotation &#123; @Deprecated String value(); &#125; 这种注解在写入时需要调用各个 visitor 的visitAnnotation方法。其中第一个参数是注解类型的类型描述符，第二个是注解类型的可见性。 对于附加在类TestAnnotation上的注解Retention，我们需要这样写入： // 省略 ClassWriter 的创建，名称为 cw AnnotationVisitor av = cw.visitAnnotation(&quot;Ljava/lang/annotation/Retention;&quot;, true); av.visitEnum(&quot;value&quot;, &quot;Ljava/lang/annotation/RetentionPolicy;&quot;, &quot;RUNTIME&quot;); av.visitEnd(); 如果一个成员在被定义时被添加上了@Deprecated注解，那么在定义这个成员时也要加上ACC_DEPRECATED访问标志。 对于value方法，我们需要这样写入： // 省略 ClassWriter 的创建，名称为 cw MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT + ACC_DEPRECATED, &quot;value&quot;, &quot;()Ljava/lang/String;&quot;, null, null); AnnotationVisitor av = mv.visitAnnotation(&quot;Ljava/lang/Deprecated;&quot;, true); av.visitEnd(); mv.visitEnd(); 类型的注解在类型上，我们也能加入注解，这些注解@Target中必须含有TYPE_USE。要知道类型的注解怎么插入，我们需要先了解两个概念：类型路径（Type Path）和类型引用（TypeReference）。 类型路径为了指定注解在类型中的位置，JVM 引入了类型路径。假设我们有下面一个泛型需要进行注解： @A Map&lt;@B?extends @C String, @D List&lt;@E Object&gt;&gt; @A Outer.@B Middle.@C Inner @A String @B[] @C[] @D[] 可以看到，注解 ABCDE分别注解了一个复杂类型中的不同元素。如果我们从类型的最外层开始对类型的参数进行遍历，我们就能最终指定插入的位置。遍历的每一步（step）都含有两个属性： 类型路径类别（Type Path Kind），它决定了这一步该走向哪种元素，可以使用的值如下表： 类别 对应元素 举例 ARRAY_ELEMENT 数组类型 @A Test[] INNER_TYPE 非静态嵌套类 Outer.@A Inner WILDCARD_BOUND 限定通配符的类型 Test&lt;? extends @A Type&gt; TYPE_ARGUMENT 泛型参数 Map&lt;@A Test, Object&gt; 类型参数索引（Type Argument Index），代表在同一级的几个相同类别的元素中要选择哪个。例如在Map&lt;@A Test, Object&gt;中，泛型参数共有两个，要指定其中一个需要用到这个索引。请注意，只有泛型参数才需要指定索引，其它的类别不需要。 假设我们有下面的类型需要注解： Map&lt;String, List&lt;@A Object&gt;&gt; 那么我们访问到注解 A 的路径就像这样： Map&lt;String, List&lt;@A Object&gt;&gt; - List&lt;@A Object&gt; // kind = TYPE_ARGUMENT, index = 1 - @A Object // kind = TYPE_ARGUMENT, index = 0 对于数组来说，注解的位置影响了它的路径长度，下面是按照 A 注解类型路径长度逐渐增大排序的注解示例： String @A[][][] // 路径长度0 String []@A[][] // 路径长度1 String [][]@A[] // 路径长度2 @A String[][][] // 路径长度3 下面是一个组合的例子： // 假设 Inner 是 Outer 的非静态内部类 List&lt;? super Outer.Inner&lt;@A String[][]&gt;&gt; - ? super Outer.Inner&lt;@A String[][]&gt; // kind = TYPE_ARGUMENT, index = 0 - Outer.Inner&lt;@A String[][]&gt; // kind = WILDCARD_BOUND - Inner&lt;@A String[][]&gt; // kind = INNER_TYPE - @A String[][] // kind = TYPE_ARGUMENT, index = 0 - @A // kind = ARRAY_ELEMENT, path_length = 2 在 ASM 库中，类型路径使用TypePath包装，创建一个 TypePath 对象需要使用fromString方法，它的参数是一个字符串，这个字符串里面存储了可以复原TypePath 的所有信息。对于每一步，都有一个对应关系，这些步按顺序连接起来就能复原 TypePath。 类别 映射字符串 ARRAY_ELEMENT [ INNER_TYPE . WILDCARD_BOUND * TYPE_ARGUMENT &lt;index&gt;; 上面的例子可以用0;*.0;[[代替。 类型引用类型路径决定了注解在一个类型内的位置，而类型引用指定了这个被注解类型的位置。 类型引用本质上是一个 int，其中第25~32位是引用的类型，1~24位是引用的参数。ASM 库提供了TypeReference类来简化创建这些数字的代码。 先来说说无参的类型引用类型，这些类型可以使用newTypeReference创建 TypeReference 对象，之后通过getValue方法获得 int形式的类型引用，如下表： 类型 传入方法 说明 FIELD FieldVisitor::visitTypeAnnotation 使用在字段声明的类型上 METHOD_RETURN MethodVisitor::visitTypeAnnotation 使用在方法声明的返回值上 METHOD_RECEIVER MethodVisitor::visitTypeAnnotation 使用在方法接收器上[1] LOCAL_VARIABLE MethodVisitor::visitLocalVariableAnnotation 使用在方法局部变量上 RESOURCE_VARIABLE MethodVisitor::visitLocalVariableAnnotation 使用在方法资源变量上[2] INSTANCEOF MethodVisitor::visitInsnAnnotation 使用在instanceof后 NEW MethodVisitor::visitInsnAnnotation 使用在new后 CONSTRUCTOR_REFERENCE MethodVisitor::visitInsnAnnotation 使用在构造函数引用后[3] METHOD_REFERENCE MethodVisitor::visitInsnAnnotation 使用在方法引用后[3] [1]：方法接收器（this）可以被显式定义，比如非静态方法Test::test()在定义时可以写为test(Test this)，这时可以在 this 上附加注解。[2]：资源局部变量是使用try-with-resource语法产生的局部变量。[3]：构造函数引用属于方法引用，语法为&lt;ClassName&gt;::new。这两个注解必须在invokedynamic字节码后。 接下来说一下有参的类型引用类型。 需要类型参数的类型引用。它们需要使用newTypeParameterReference获得 TypeReference 对象，第二个参数是类型参数的序号。 类型 传入方法 说明 CLASS_TYPE_PARAMETER ClassVisitor::visitTypeAnnotation RecordComponentVisitor::visitTypeAnnotation 使用在类类型参数上 METHOD_TYPE_PARAMETER MethodVisitor::visitTypeAnnotation 使用在方法类型参数上 需要类型参数边界的类型引用。类型参数边界即&lt;T extends ...&gt;这种类型参数后面的限定，可以不止一个。它们需要使用newTypeParameterBoundReference获得 TypeReference对象，第二个参数是类型参数的序号，第三个参数是规定边界限定的序号。 类型 传入方法 说明 CLASS_TYPE_PARAMETER_BOUND ClassVisitor::visitTypeAnnotation RecordComponentVisitor::visitTypeAnnotation 类类型参数边界 METHOD_TYPE_PARAMETER_BOUND MethodVisitor::visitTypeAnnotation 方法类型参数边界 需要超类序号的类型引用。超类序号是定义类时指定的继承类和实现类的序号，继承类的序号是-1，实现类的序号按照定义顺序从0计数。使用newSuperTypeReference创建 TypeReference 对象，第二个参数就是超类序号。类型固定为CLASS_EXTENDS，可用在ClassVisitor::visitTypeAnnotation和RecordComponentVisitor::visitTypeAnnotation方法中。 需要方法形式参数序号的类型引用。使用newFormalParameterReference 创建对象，类型固定为METHOD_FORMAL_PARAMETER，可用在MethodVisitor::visitTypeAnnotation中。 需要方法异常列表序号的类型引用。使用newExceptionReference创建 TypeReference，类型固定为THROWS，可用在MethodVisitor::visitTypeAnnotation中。 需要 try-catch 块序号的类型引用。用newTryCatchReference创建，类型是EXCEPTION_PARAMETER，使用MethodVisitor::visitTryCatchAnnotation写入字节码。 需要实际参数序号的类型引用。它们需要使用newTypeArgumentReference创建，都需要使用MethodVisitor::visitInsnAnnotation写入。 类型 说明 CAST 使用在checkcast后 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT 使用在调用构造函数时指定的类型参数中[1] METHOD_INVOCATION_TYPE_ARGUMENT 使用在调用方法时指定的类型参数中[1] CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT 使用在使用构造函数引用时指定的类型参数中[2] METHOD_REFERENCE_TYPE_ARGUMENT 使用在使用方法引用时指定的类型参数中[2] [1]：在方法或者构造函数调用时，可以手动指定类型参数，如Lists.&lt;String&gt;newArrayList()。注解可以附加到类型参数的列表之中。[2]：方法引用也可以指定类型参数，如Lists::&lt;String&gt;newArrayList。注解可以附加到这个类型参数列表中。这两个注解必须在invokedynamic字节码后。 下面是一个例子： @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.TYPE, ElementType.TYPE_USE&#125;) @interface Test &#123; String value(); &#125; public abstract class TestMain &#123; public abstract InputStream testFile(String test) throws IOException; @SuppressWarnings(&quot;unchecked&quot;) public &lt;@Test(&quot;test&quot;) T extends @Test(&quot;testA&quot;) InputStream&gt; void test( @Test(&quot;testB&quot;) TestMain this, @Test(&quot;testC&quot;) String file, Consumer&lt;BiConsumer&lt;InputStream, Integer&gt;&gt; consumer) throws @Test(&quot;testD&quot;) IOException &#123; try (@Test(&quot;testE&quot;) T input = (@Test(&quot;testF&quot;) T) testFile(file)) &#123; consumer.accept(@TestA(&quot;testG&quot;) InputStream::mark); &#125; &#125; &#125; 下面将写入这个 test 方法： // 省略 ClassWriter 创建，对象为 cw，使用 COMPUTE_FRAMES 标志 // 所有注解具体写入内容省略，仅显示目前写入哪个注解 // 省略 SuppressWarnings 注解 MethodVisitor mv = classWriter.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(Ljava/lang/String;Ljava/util/function/Consumer;)V&quot;, &quot;&lt;T:Ljava/io/InputStream;&gt;(Ljava/lang/String;Ljava/util/function/Consumer&lt;Ljava/util/function/BiConsumer&lt;Ljava/io/InputStream;Ljava/lang/Integer;&gt;;&gt;;)V&quot;, new String[]&#123;&quot;java/io/IOException&quot;&#125;); AnnotationVisitor av = mv.visitTypeAnnotation(newTypeParameterReference(METHOD_TYPE_PARAMETER, 0).getValue(), null, &quot;LTest;&quot;, true); // test av = mv.visitTypeAnnotation(newTypeParameterBoundReference(METHOD_TYPE_PARAMETER_BOUND, 0, 0).getValue(), null, &quot;LTest;&quot;, true); // testA av = mv.visitTypeAnnotation(newExceptionReference(0).getValue(), null, &quot;LTest;&quot;, true); // testD av = mv.visitTypeAnnotation(newTypeReference(METHOD_RECEIVER).getValue(), null, &quot;LTest;&quot;, true); // testB av = mv.visitTypeAnnotation(newFormalParameterReference(0).getValue(), null, &quot;LTest;&quot;, true); // testC mv.visitCode(); // try-with-resource --------------------- Label label0 = new Label(), label1 = new Label(), label2 = new Label(); mv.visitTryCatchBlock(label0, label1, label2, &quot;java/lang/Throwable&quot;); Label label3 = new Label(), label4 = new Label(), label5 = new Label(); mv.visitTryCatchBlock(label3, label4, label5, &quot;java/lang/Throwable&quot;); Label start = new Label(); mv.visitLabel(label6); mv.visitVarInsn(ALOAD, 0); // this mv.visitVarInsn(ALOAD, 1); // file mv.visitMethodInsn(INVOKEVIRTUAL, &quot;TestMain&quot;, &quot;testFile&quot;, &quot;(Ljava/lang/String;)Ljava/io/InputStream;&quot;, false); mv.visitVarInsn(ASTORE, 3); // input av = mv.visitInsnAnnotation(newTypeArgumentReference(CAST, 0).getValue(), null, &quot;LTest;&quot;, true); // testF mv.visitLabel(label0); mv.visitVarInsn(ALOAD, 2); // consumer mv.visitInvokeDynamicInsn(&quot;accept&quot;, &quot;()Ljava/util/function/BiConsumer;&quot;, new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/LambdaMetafactory&quot;, &quot;metafactory&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;, false), new Object[]&#123; Type.getType(&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;), new Handle(H_INVOKEVIRTUAL, &quot;java/io/InputStream&quot;, &quot;mark&quot;, &quot;(I)V&quot;, false), Type.getType(&quot;(Ljava/io/InputStream;Ljava/lang/Integer;)V&quot;) &#125; ); av = mv.visitInsnAnnotation(newTypeReference(METHOD_REFERENCE, 0).getValue(), null, &quot;LTest;&quot;, true); // testG mv.visitMethodInsn(INVOKEINTERFACE, &quot;java/util/function/Consumer&quot;, &quot;accept&quot;, &quot;(Ljava/lang/Object;)V&quot;, true); // try-with-resource closing mv.visitLabel(label1); mv.visitVarInsn(ALOAD, 3); Label label7 = new Label(); mv.visitJumpInsn(IFNULL, label7); mv.visitVarInsn(ALOAD, 3); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/InputStream&quot;, &quot;close&quot;, &quot;()V&quot;, false); mv.visitJumpInsn(GOTO, label7); mv.visitLabel(label2); mv.visitVarInsn(ASTORE, 4); // (exception) mv.visitVarInsn(ALOAD, 3); // input Label label8 = new Label(); mv.visitJumpInsn(IFNULL, label8); mv.visitLabel(label3); mv.visitVarInsn(ALOAD, 3); // input mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/InputStream&quot;, &quot;close&quot;, &quot;()V&quot;, false); mv.visitLabel(label4); mv.visitJumpInsn(GOTO, label8); mv.visitLabel(label5); mv.visitVarInsn(ASTORE, 5); // (exception 2) mv.visitVarInsn(ALOAD, 4); // (exception) mv.visitVarInsn(ALOAD, 5); // (exception 2) mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Throwable&quot;, &quot;addSuppressed&quot;, &quot;(Ljava/lang/Throwable;)V&quot;, false); mv.visitLabel(label8); mv.visitVarInsn(ALOAD, 4); // (exception) mv.visitInsn(ATHROW); // try-with-resource end mv.visitLabel(label7); mv.visitLineNumber(49, label7); mv.visitInsn(RETURN); // LVT Label label9 = new Label(); mv.visitLabel(label9); mv.visitLocalVariable(&quot;input&quot;, &quot;Ljava/io/InputStream;&quot;, &quot;TT;&quot;, label0, label7, 3); mv.visitLocalVariable(&quot;this&quot;, &quot;LTestMain;&quot;, null, start, label9, 0); mv.visitLocalVariable(&quot;file&quot;, &quot;Ljava/lang/String;&quot;, null, start, label9, 1); mv.visitLocalVariable(&quot;consumer&quot;, &quot;Ljava/util/function/Consumer;&quot;, &quot;Ljava/util/function/Consumer&lt;Ljava/util/function/BiConsumer&lt;Ljava/io/InputStream;Ljava/lang/Integer;&gt;;&gt;;&quot;, label6, label9, 2); av = methodVisitor.visitLocalVariableAnnotation(newTypeReference(RESOURCE_VARIABLE).getValue(), null, new Label[]&#123;label0&#125;, new Label[]&#123;label7&#125;, new int[]&#123;3&#125;, &quot;Lio/github/nickid2018/asmtest/ASMMain$TestA;&quot;, true); // testE mv.visitMaxs(2, 6); mv.visitEnd(); 方法形式参数上的注解等下，我们刚刚不是说过形式参数上怎么插入注解了吗？事实上，形式参数可以使用两种注解：一种是标记为TYPE_USE的类型注解，另一种是标记为PARAMETER的形式参数注解。如果一个注解同时拥有这两个标志，就都要写入字节码。 写入形式参数注解需要两步：写入注解形式参数数量、写入形式参数注解。 写入注解形式参数数量需要使用visitAnnotableParameterCount方法。假设我们有一个方法： // 仍然使用上一个例子中的类型 public void test(TestMain this, String s, @Test(&quot;test&quot;) int i) 它的形式参数是两个，因为接收器 this 不是形式参数。写入如下： mv.visitAnnotableParameterCount(2, true); 第二个参数代表了注解的可见性。 写入形式参数注解需要使用visitParameterAnnotation，参数类似定义注解的使用方法。 请注意：如果形式参数列表中同时存在运行时可见和不可见的注解，那么先写visitAnnotableParameterCount，可见性为true，在后面写出所有运行时可见的注解；之后再一行visitAnnotableParameterCount，可见性为false，在后面写出所有运行时不可见的注解。visitAnnotableParameterCount对于每个可见性只出现一次。 注解类型中的 default 默认值在类的结构二中，我们说到了有默认值的注解属性怎么写入。它使用的是visitAnnotationDefault方法。 它返回的AnnotationVisitor需要写入一个name为null的属性，这个属性写入什么值和怎么写入取决于你要决定的默认值。 到这里有关于注解的相关知识都已经说完了，下篇专栏可能是 ASM Tree API 部分。","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：模块","slug":"Java ASM详解：模块","date":"2022-10-17T00:00:00.000Z","updated":"2022-10-17T14:54:09.436Z","comments":true,"path":"2022/10/17/Java ASM详解：模块/","link":"","permalink":"http://nickid2018.github.io/2022/10/17/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%A8%A1%E5%9D%97/","excerpt":"","text":"在前两篇专栏中我们讨论了各种类的结构，将各种类组织一起它们就组成了模块（Module）。 模块的定义模块是在 Java 9 中引入的，它在module-info.java文件中定义。这个文件的内容是一个模块的描述，下面就是一个例子： open module JavaASMTest &#123; requires org.objectweb.asm; exports io.github.nickid2018.asmtest to nickid2018.asm; uses java.sql.Driver; provides java.sql.Driver with io.github.nickid2018.asmtest.TestDriver; &#125; 上面的代码声明了一个模块，名称为JavaASMTest，并依赖模块org.objectweb.asm。 在模块中，我们可以定义以下信息： requires 语句，它代表了这个模块需要依赖于什么其它的模块。所有的模块都隐式定义了requires java.base。 requires 语句可以使用 static 修饰符，代表静态依赖。这种依赖在编译期是必须的，但是在运行时可以不存在。 requires 语句也可以使用 transitive 修饰符，它代表了依赖此模块的模块将隐式获得对本模块依赖的模块的可读性。举一个例子：如果 A 依赖于 B，B 依赖于 C，那么 C 对 A 来说不可读，除非 A 显式定义 requires C；但是加上这个关键词，C 将对 A 可读。 exports 语句，它代表了模块内某个包内的 public 成员可以被其他模块访问，也就是开放了可读性。如果一个模块代码中直接访问了一个其他模块没有 exports 的成员，那么代码不通过编译。 exports 语句可以和 to 搭配，代表对指定模块开放这些成员。 opens 语句，和 exports 类似，但是它开放的是访问性。也就是说，允许通过反射访问模块中的类。这个语句也可以和 to 搭配。 当模块被定义为open module时，模块内的所有成员都将开放访问，并且不允许在模块中重新定义 opens。 uses 语句，用于使用服务。服务通常是抽象类，比如说java.sql.Driver。服务类所在的模块必须使用 requires 进行依赖。 provides … with … 语句，它代表提供服务的实现类。 下面是 opens 和 exports 搭配使用的情况： opens exports 通过类名直接访问 通过反射访问和执行 false false 编译错误 运行时异常 true false 编译错误 正常访问 false true 正常访问 运行时异常 true true 正常访问 正常访问 模块的字节码表示和普通的类一样，模块也是使用 ClassWriter 写入的，但是写入类信息的时候和普通的类不一样：它要求类名称是module-info，仅带有ACC_MODULE访问标志，并且没有超类和签名。 cw.visit(V17, ACC_MODULE, &quot;module-info&quot;, null, null, null); 接下来就是写入模块信息，这里用到了visitModule方法。如果模块是open的，那么访问标志要写为ACC_OPEN，否则写为0。最后一个参数是模块的版本，可以为null。 ModuleVisitor mv = cw.visitModule(&quot;JavaASMTest&quot;, ACC_OPEN, null); 模块中有三种定义信息的模式：显式定义，也就是在文件中显式写出；隐式定义，由模块的依赖关系自行推断而出；既不是显式定义也不是隐式定义，由编译器编译时决定添加。如果访问标志含有ACC_MANDATED，则说明这个信息是被隐式定义的；如果访问标志含有ACC_SYNTHETIC，则这个模块信息既不是显式定义也不是隐式定义。所有使用访问标志的模块信息都可以使用这两个标志，下文将不再重复出现。 接下来就是填充模块的信息，这些信息与ModuleVisitor类中的方法一一对应。 requires 语句对应visitRequire方法，第一个参数是依赖模块的名称，最后一个参数是依赖模块的版本。第二个参数访问标志可以使用ACC_TRANSITIVE和ACC_STATIC_PHASE，分别代表了 transitive 和 static。 由于所有的模块都隐式定义了requires java.base，所以所有模块都必须像下面一样写入： mv.visitRequire(&quot;java.base&quot;, ACC_MANDATED, &quot;17&quot;); // 最后一个参数是对应 Java 版本 exports 和 opens 语句分别使用了visitExport和visitOpen方法，参数分别是全限定包名、访问标志和指定模块列表，最后一个参数可以为null，代表向所有模块开放。 mv.visitExport(&quot;io/github/nickid2018/asmtest&quot;, 0, &quot;nickid2018.asm&quot;); uses 语句使用visitUse方法写入，它唯一的参数代表服务类全限定名。 mv.visitUse(&quot;java/sql/Driver&quot;); provides … with … 语句使用visitProvide方法，其中第一个参数代表服务类的全限定名，第二个则是实现类的列表。 mv.visitProvide(&quot;java/sql/Driver&quot;, &quot;io/github/nickid2018/asmtest/TestDriver&quot;); 现在，ModuleVisitor 类中还有两个方法我们没有说到：visitPackage和visitMainClass。这两个方法的实际作用不大，所以不讲解它的用法。 到这里模块的知识就结束了，下一篇专栏将讲述注解的使用。 若无特殊说明，所有字节码均以 Java 17 为标准。 参考资料： The Java Language Specification (Java SE 17 Edition) The Java Virtual Machine Specification (Java SE 17 Edition) ASM 9.4 Javadoc","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：类的结构（二）","slug":"Java ASM详解：类的结构（二）","date":"2022-06-02T00:00:00.000Z","updated":"2022-10-17T16:08:53.822Z","comments":true,"path":"2022/06/02/Java ASM详解：类的结构（二）/","link":"","permalink":"http://nickid2018.github.io/2022/06/02/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"上次专栏讲解了普通类的结构，这篇专栏将继续讲解接口、注解、枚举和记录这四种特殊的类。 接口接口类似于抽象类，内部含有静态方法、公开抽象方法、公开默认实例方法、私有实例方法和常量字段。 声明一个接口，需要在ClassWriter::visit时同时使用ACC_ABSTRACT和ACC_INTERFACE访问标志。如果只含有ACC_INTERFACE标志，在加载这个类的时候 JVM 就会抛出java.lang.ClassFormatError: Illegal class modifiers in class *: 0x200的异常。接口的继承本质其实是实现，也就是说接口的父类仍然是Object，但是实现接口列表可以加入其它的接口。 如果接口是一个内部类，在使用时类似于静态内部类，也就是说内部接口不需要外部类实例作为依托。（但是在使用visit时不用写ACC_STATIC，这是一种等效）同样的，如果接口内部有内部类，那么内部类也等效于静态内部类。 紧接着说说接口的字段。接口内只能存在一种字段，那就是公开常量字段，也就是PSF（public static final）字段。在visitField时必须同时使用ACC_PUBLIC、ACC_STATIC和ACC_FINAL访问标志，否则在加载这个类的时候就会抛出java.lang.ClassFormatError: Illegal field modifiers in class *: *的异常。 接着来看看方法。接口不存在构造函数，并且只允许两种访问修饰符：public和private（引入于 Java 9），protected不能在接口中使用，不写访问修饰符则默认公开。 接口内可以定义静态方法，与普通的类没有太多差别，只是访问修饰有差别。对于接口内的实例方法，在 Java 层如果不定义default或者private那就会自动加上abstract，但是对于字节码来说，除了访问修饰外所有的定义都和普通的类一样。 接口也可以使用桥接方法。 下面是个例子，要生成下面的类： public interface Test &#123; int TEST = 0; // PSF void test1(); // 抽象方法 static void test2() &#123;&#125; // 公开静态方法 default void test3() &#123;&#125; // 公开默认方法 private void test4() &#123;&#125; // 私有方法(Java 9+) private static void test5() &#123;&#125; // 私有静态方法(Java 9+) &#125; 将使用下面的代码： // 省略MethodVisitor和FieldVisitor的使用 ClassWriter cw = new ClassWriter(0); cw.visit(V17, ACC_INTERFACE + ACC_ABSTRACT, &quot;Test&quot;, null, &quot;java/lang/Object&quot;, null); cw.visitField(ACC_PUBLIC + ACC_STATIC + ACC_FINAL, &quot;TEST&quot;, &quot;I&quot;, null, 0); cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, &quot;test1&quot;, &quot;()V&quot;, null, null); cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;test2&quot;, &quot;()V&quot;, null, null); cw.visitMethod(ACC_PUBLIC, &quot;test3&quot;, &quot;()V&quot;, null, null); cw.visitMethod(ACC_PRIVATE, &quot;test4&quot;, &quot;()V&quot;, null, null); cw.visitMethod(ACC_PRIVATE + ACC_STATIC, &quot;test5&quot;, &quot;()V&quot;, null, null); cw.visitEnd(); 注解注解类型是特殊的接口，除了接口都具有的特性之外还增加了一些限制。 先说一下声明。注解类型除了接口要求的两个访问标志外还需要添加一个ACC_ANNOTATION标志，且必须只实现（或者说是 Java 层的继承）于java.lang.annotation.Annotation。（注意：JVM 对实现Annotation接口这件事不加以检查，但是如果你使用了反射尝试获取这个注解时会报错） 注解对于方法的要求很严格：要求不能有私有方法、默认方法和静态方法，只能存在公开抽象方法。 到这里你可能会问：注解方法的默认值是怎么实现的？其实默认值不是方法体，而是使用了visitAnnotationDefault这个方法用于写入默认值。 下面我们要生成这个注解： public @interface Test &#123; String test1(); String test2() default &quot;&quot;; &#125; 可以使用下面的代码生成： ClassWriter cw = new ClassWriter(0); cw.visit(V17, ACC_PUBLIC + ACC_INTERFACE + ACC_ABSTRACT + ACC_ANNOTATION, &quot;Test&quot;, null, &quot;java/lang/Object&quot;, new String[]&#123;&quot;java/lang/annotation/Annotation&quot;&#125;); MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, &quot;test1&quot;, &quot;()Ljava/lang/String;&quot;, null, null); mv.visitEnd(); mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, &quot;test2&quot;, &quot;()Ljava/lang/String;&quot;, null, null); AnnotationVisitor av = mv.visitAnnotationDefault(); // 写入默认值 av.visit(null, &quot;&quot;); // 这里以后会说，name写入null是要求 av.visitEnd(); mv.visitEnd(); cw.visitEnd(); 枚举枚举是一种特殊的类，主要用于存贮常量。和普通的类相比，它有下面的性质： 所有枚举都继承于java.lang.Enum，并且都为final。 枚举的所有构造函数都是私有的。 自动生成values和valueOf方法。 作为内部类时等效静态。 写入一个枚举，在visit时要将ACC_ENUM和ACC_FINAL访问标志同时写入，并且父类必须写为java/lang/Enum。由于Enum带有泛型，所以signature也要写入。例如，下面这个枚举： public enum Test &#123; // 省略 &#125; 在声明时必须用下面的代码： cw.visit(V17, ACC_ENUM + ACC_FINAL + ACC_PUBLIC, &quot;Test&quot;, &quot;Ljava/lang/Enum&lt;LTest;&gt;;&quot;, // 泛型签名 &quot;java/lang/Enum&quot;, null); 在使用 Java 编写枚举类时可以写两种字段：一种是普通的字段，这个和普通的类一样，没有限制；另一种就是枚举字段，它必须是枚举类的对象，并且是 PSF 字段还带有ACC_ENUM访问标志。例如下方的枚举字段 A： public enum Test &#123; A &#125; 在声明时应该遵照下面的方式： // 只保留字段定义 cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC + ACC_ENUM, &quot;A&quot;, &quot;LTest;&quot;, null, null); 在字节码中，除了上面的两种字段外，枚举中还有一个字段是系统生成用于保存所有枚举字段的私有常量，$VALUES。它的访问标志除了ACC_PRIVATE、ACC_STATIC和ACC_FINAL外还带有ACC_SYNTHETIC，这代表它是编译时自动生成的。它的类型是这个类的数组。 $VALUES存在的价值是为了values方法和Enum的索引。在介绍它的用途之前先来说说$VALUES和枚举字段的初始化。 枚举字段和普通常量的初始化一样，也是简单的创建、调用构造函数和赋值。但是不同的是，枚举的构造函数和普通的构造函数不同，它默认带有两个形参。实际上，枚举的默认构造函数是这样的： private Test(String name, int ordinal) &#123; super(name, ordinal); &#125; 枚举默认构造函数的写入如下： // 省略ClassWriter创建和visit MethodVisitor mv = cw.visitMethod(ACC_PRIVATE, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;I)V&quot;, null, null); mv.visitVarInsn(ALOAD, 0); // this mv.visitVarInsn(ALOAD, 1); mv.visitVarInsn(ILOAD, 2); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Enum&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;I)V&quot;, false); mv.visitInsn(RETURN); mv.visitMaxs(3, 3); mv.visitEnd(); 如果枚举类有定义构造函数，那么在字节码中仍然需要将这两个形参添加到 Java 源代码的形参列表之前，且必须调用Enum的这个父类构造函数。 所以枚举字段的创建对于上面的 A 来说就像下面这样： // 省略mv创建，mv现在是&lt;clinit&gt;的visitor mv.visitTypeInsn(NEW, &quot;Test&quot;); mv.visitInsn(DUP); mv.visitLdc(&quot;A&quot;); // 枚举字段的名称 mv.visitInsn(ICONST_0); // A是第一个枚举常量字段，编号是0 mv.visitMethodInsn(INVOKESPECIAL, &quot;Test&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;I)V&quot;, false); mv.visitFieldInsn(PUTSTATIC, &quot;Test&quot;, &quot;A&quot;, &quot;LTest;&quot;); $VALUES的赋值不太一样，它是委托到了另一个方法$values生成的。这个方法带有ACC_PRIVATE、ACC_STATIC和ACC_SYNTHETIC访问标志，且方法返回值是该类的数组，形参列表为空。它的作用就是创建一个数组，并将所有枚举字段按顺序存储进数组之中并返回。对于上面的 Test 就是这样的： // 省略ClassWriter创建 MethodVisitor mv = cw.visitMethod(ACC_PRIVATE + ACC_STATIC + ACC_SYNTHETIC, &quot;$values&quot;, &quot;()[LTest;&quot;, null, null); mv.visitInsn(ICONST_1); mv.visitTypeInsn(ANEWARRAY, &quot;Test&quot;); // 创建长度为1的数组（枚举字段的数量） mv.visitInsn(DUP); mv.visitInsn(ICONST_0); mv.visitFieldInsn(GETSTATIC, &quot;Test&quot;, &quot;A&quot;, &quot;LTest;&quot;); mv.visitInsn(AASTORE); // 放入A mv.visitInsn(ARETURN); mv.visitMaxs(4, 0); mv.visitEnd(); 在静态初始化中，$VALUES直接由$values的返回值赋值： // mv创建省略，此时为&lt;clinit&gt; mv.visitMethodInsn(INVOKESTATIC, &quot;Test&quot;, &quot;$values&quot;, &quot;()[Test;&quot;, false); mv.visitFieldInsn(PUTSTATIC, &quot;Test&quot;, &quot;$VALUES&quot;, &quot;[LTest;&quot;); 我们用到的values是另一个方法，也是由编译器自动生成的。它返回的是$VALUES的副本，Java 的代码像这样： public static Test[] values() &#123; return (Test[]) $VALUES.clone(); &#125; 可以注意到这个方法不存在try-catch，即使clone定义了抛出CloneNotSupportedException。JVM对这种异常处理不检查，可以说在字节码范围内，异常处理是可有可无的。 字节码像这样： // 省略ClassWriter创建 MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;values&quot;, &quot;()[LTest;&quot;, null, null); mv.visitFieldInsn(GETSTATIC, &quot;Test&quot;, &quot;$VALUES&quot;, &quot;[LTest;&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;[LTest;&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;, false); mv.visitTypeInsn(CHECKCAST, &quot;[LTest;&quot;); mv.visitInsn(ARETURN); mv.visitMaxs(1, 0); mv.visitEnd(); 另一个会自动创建的方法，valueOf，用 Java 表示是这样的： public static Test valueOf(String name) &#123; return (Test) Enum.valueOf(Test.class, name); &#125; 字节码写入如下： // 省略ClassWriter创建 MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;valueOf&quot;, &quot;(Ljava/lang/String;)LTest;&quot;, null, null); mv.visitLdcInsn(Type.getType(&quot;LTest;&quot;)); // Test.class mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Enum&quot;, &quot;valueOf&quot;, &quot;(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;&quot;, false); mv.visitTypeInsn(CHECKCAST, &quot;Test&quot;); mv.visitInsn(ARETURN); mv.visitMaxs(2, 1); mv.visitEnd(); 到这里一个完整的枚举才写完。可以看到我们必须写出$VALUES、$values、values、valueOf这些字段和方法，非常的麻烦。即使一个非常简单的枚举也必须有所有这些要素，所以枚举的写入很繁琐，还要注意别忘了它的组件。 记录记录也是一种特殊的类，它在 Java 14 开始加入。和普通的类相比，它有下面的不同之处： 不能单独定义实例字段，所有终态实例字段都要在类之后的括号定义。 继承于java.lang.Record，且都为final。 自动生成toString、hashCode和equals。（除非自行定义） 作为内部类时等效静态。 写入一个记录，在visit时必须带有ACC_FINAL和ACC_RECORD访问标志，并且要继承java/lang/Record。接下来以下面的记录作为例子： public record Test(int a) &#123; &#125; 在写入时要这样定义： // 省略了ClassWriter创建 cw.visit(V17, ACC_PUBLIC + ACC_FINAL + ACC_SUPER + ACC_RECORD, &quot;Test&quot;, null, &quot;java/lang/Record&quot;, null); 对于记录的终态实例字段（也可以叫记录字段），它只能含有ACC_PRIVATE和ACC_FINAL这两个访问标志。它需要两次定义：一次是普通的字段定义，使用visitField；另一次是记录组件的定义，使用visitRecordComponent，在定义字段之前写入。这里的a就像下面这样定义： // 省略ClassWriter创建和Visitor使用 cw.visitRecordComponent(&quot;a&quot;, &quot;I&quot;, null); // 没有泛型所以最后一项是null cw.visitField(ACC_PRIVATE + ACC_FINAL, &quot;a&quot;, &quot;I&quot;, null, null); 每个记录字段都有自动生成的对应的 Getter，代码很简单，就像下面这样： public int a() &#123; return a; &#125; 字节码像这样写： // 省略ClassWriter创建 MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;a&quot;, &quot;()I&quot;, null, null); mv.visitVarInsn(ALOAD, 0); // this mv.visitFieldInsn(GETFIELD, &quot;Test&quot;, &quot;a&quot;, &quot;I&quot;); mv.visitInsn(IRETURN); mv.visitMaxs(1, 1); mv.visitEnd(); 记录的默认构造函数和记录字段有关，形参列表正好和记录字段的顺序一致。对于上面的Test，构造函数是这样的： public Test(int a) &#123; super(); this.a = a; &#125; 转换成字节码如下： // 省略ClassWriter创建 MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;(I)V&quot;, null, null); mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Record&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); mv.visitVarInsn(ALOAD, 0); mv.visitVarInsn(ILOAD, 1); mv.visitFieldInsn(PUTFIELD, &quot;Test&quot;, &quot;a&quot;, &quot;I&quot;); mv.visitInsn(RETURN); mv.visitMaxs(2, 2); mv.visitEnd(); 记录必须有toString、hashCode、equals这三个方法，这是因为在Record中声明了它们3个是抽象的。如果我们不自己写这三个方法，那么系统在编译的时候会自动生成。 自动生成的这三个方法都用到了invokedynamic，使用的引导方法都是java.lang.runtime.ObjectMethods.bootstrap。这个方法的定义是： public static Object bootstrap( MethodHandles.Lookup lookup, // 引导方法必要参数 String methodName, // 引导方法必要参数，实现的方法名称 TypeDescriptor type, // 引导方法必要参数，实现的方法描述符 Class&lt;?&gt; recordClass, // 记录的Class&lt;?&gt;对象 String names, // 记录实例字段的名称序列 MethodHandle... getters // 获取记录实例字段的句柄 ) throws Throwable 其中names是记录实例字段的名称序列，用分号;隔开。 下面仅给出toString的代码，另两个除了methodName和type不同外没有差别。 MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, null, null); mv.visitVarInsn(ALOAD, 0); // this mv.visitInvokeDynamicInsn(&quot;toString&quot;, // 方法名 &quot;(LTest;)Ljava/lang/String;&quot;, // 方法描述符 new Handle(H_INVOKESTATIC, &quot;java/lang/runtime/ObjectMethods&quot;, &quot;bootstrap&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/TypeDescriptor;Ljava/lang/Class;Ljava/lang/String;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/Object;&quot;, false), // 引导方法 new Object[]&#123; Type.getType(&quot;Lio/github/nickid2018/asmtest/ASMMain$A;&quot;), // 记录类对象 &quot;a&quot;, // 实例字段名称序列 new Handle(H_GETFIELD, &quot;Test&quot;, &quot;a&quot;, &quot;I&quot;, false) // 字段a的句柄 &#125;); mv.visitInsn(ARETURN); mv.visitMaxs(1, 1); mv.visitEnd(); 到这里记录才算写入完毕。 到这里类的结构就结束了，接下来的文章将讨论好玩的东西（因为还没想出来）。 这系列专栏没有特殊声明都是 Java 17 的字节码，请注意使用。","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：类的结构（一）","slug":"Java ASM详解：类的结构（一）","date":"2022-03-30T00:00:00.000Z","updated":"2022-04-06T14:59:42.797Z","comments":true,"path":"2022/03/30/Java ASM详解：类的结构（一）/","link":"","permalink":"http://nickid2018.github.io/2022/03/30/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"了解了各个字节码的意义，我们可以构建出方法。这篇文章开始不再讲具体的字节码，而是开始介绍类的结构。今天这篇文章主要讲类的成员/属性和它们在字节码中的写入表示。 类静态初始化方法当一个类被装载入内存，它是没有静态初始化过的。当从其他类调用它内部的方法或字段时，类才会被静态初始化。静态初始化只进行一次。 静态初始化的主要工作是在类加载之后使用之前进行内部数据的初始化操作。在Java代码中，它使用static块声明，一个类文件可以有多个static块。 static &#123; // Code... &#125; 在字节码中，静态初始化会被写入成为一个方法，名称为&lt;clinit&gt;，是Class Initialization的缩写。它的描述符要求是()V，不带有泛型签名，不抛出异常，访问标志必须含有static。如果&lt;clinit&gt;不满足这些条件，会产生下面这些报错： 错误输入 报错 访问标志不存在static java.lang.ClassFormatError: Method &lt;clinit&gt; is not static in class file * 方法描述符不是()V java.lang.ClassFormatError: Method “&lt;clinit&gt;” in class * has illegal signature * 和static块不同，在字节码中&lt;clinit&gt;只能存在一个。多个static块合成一个&lt;clinit&gt;会按照static块的顺序一块一块进行拼接，同时局部变量也会进行拼接。例如下方的代码： static &#123; String a = &quot;a&quot;; System.out.println(a); &#125; static &#123; Object a = &quot;b&quot;; System.out.println(a); &#125; 在字节码中会进行拼接，翻译后变成这样： static &#123; &#123; String a = &quot;a&quot;; System.out.println(a); &#125; &#123; Object a = &quot;b&quot;; System.out.println(a); &#125; &#125; 构造函数创建某个类的对象必然会调用某一个具体的构造函数。构造函数的意义就是对类对象内部数据进行初始化。 在字节码中，构造函数的名称是&lt;init&gt;而非类名。它要求返回值是void（V），访问标志只包含访问权限标志（public/protected/private），对于参数列表和异常列表不加限制。如果不满足上面的条件，JVM在加载阶段会抛出下面的异常： 错误输入 报错 访问标志存在不合法的标志 java.lang.ClassFormatError: Method &lt;init&gt; in class * has illegal modifiers: * 方法描述符返回值不是V java.lang.ClassFormatError: Method “&lt;init&gt;” in class * has illegal signature * 构造函数的另一项限制在它的内部。构造函数必须调用它父类的构造函数或本类的另一个构造函数，否则会在验证时抛出java.lang.VerifyError: Constructor must call super() or this() before return。 每个类都要含有一个构造函数。如果源码中没有构造函数，那么编译时会自动添加默认构造函数，它的Java源码和字节码写入如下： 【注意：这里的代码不适用于非静态内部类，下文会详细介绍】 public ClassName() &#123; super(); &#125; // --- 字节码 mv.visitVarInsn(ALOAD, 0); // 加载this mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); // 类名需要改成父类 mv.visitInsn(RETURN); mv.visitMaxs(1, 1); 类字段的初始化类中的静态字段不和类对象绑定而和类绑定，因此它们必须在静态初始化时被初始化；而类中的实例字段和对象绑定，需要在对象构造时被初始化。 如果初始化语句是一个常量字面值且字段是静态字段，如字符串、数字、null或XXXX.class，它们的初始化字节码应该直接使用visitField的value参数将初始值传入。 如果初始化语句不是常量字面值或不是静态字段，如调用方法语句、对象创建、数组创建等，它们的初始化字节码应该在&lt;clinit&gt;或&lt;init&gt;方法内。 根据这个规则，我们可以推断出一段静态字段初始化的代码的具体实现： public static final int CONST_INT = 1; public static final long START_TIME = System.currentTimeMillis(); public static Object object; 在写入字节码时，Java代码应该是这样的： public static final int CONST_INT = 1; public static final long START_TIME; public static Object object; static &#123; START_TIME = System.currentTimeMillis(); &#125; 写入字节码的代码： // 类名为Test，省略ClassWriter创建 FieldVisitor fv = cw.visitField(ACC_PUBLIC + ACC_STATIC + ACC_FINAL, &quot;CONST_INT&quot;, &quot;I&quot;, null, 1); fv.visitEnd(); fv = cw.visitField(ACC_PUBLIC + ACC_STATIC + ACC_FINAL, &quot;START_TIME&quot;, &quot;J&quot;, null, null); fv.visitEnd(); fv = cw.visitField(ACC_PUBLIC + ACC_STATIC, &quot;object&quot;, &quot;Ljava/lang/Object;&quot;, null, null); fv.visitEnd(); MethodVisitor mv = cw.visitMethod(ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null); mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/System&quot;, &quot;currentTimeMillis&quot;, &quot;()J&quot;, false); mv.visitFieldInsn(PUTSTATIC, &quot;Test&quot;, &quot;START_TIME&quot;, &quot;J&quot;); mv.visitInsn(RETURN); mv.visitMaxs(2, 0); mv.visitEnd(); 在字节码中，静态初始化方法内可以对一个静态常量字段进行多次赋值，并且JVM不报错。如果在静态初始化中不存在初始化某个静态字段的代码，那么它们就会使用默认值，也就是visitField中value参数决定的值。 实例字段的初始化类似于静态初始化，只是它们在构造函数内写入。 桥接方法在介绍桥接方法（Bridge Method）之前，先来简单介绍重写（Override）。 重写就是子类将父类的某个方法进行覆盖，进而实际执行时会执行子类方法而不是父类的。重写需要满足： 名称相同：父类的方法名称必须与子类的方法名称相同。 参数列表对应：父类的方法参数列表应该与子类一一对应，这一点适用于泛型，也就是子类确定的类型参数应该在重写方法中带入类型参数确定的类型。 异常列表不增添：子类的复写方法不能出现父类没有声明抛出的异常。 访问权限不缩小：子类的复写方法的可见性不能低于父类方法可见性，如父类的访问可见性为public，那么子类也必须声明为public。 下面是具体的例子，下方的重写案例都是正常能通过编译的： interface SupClass&lt;T, R&gt; &#123; void test1(); void test2(T t); R test3(); R test4(T t); &#125; class BaseClass&lt;R&gt; implements SupClass&lt;String, R&gt; &#123; public void test1() ... public void test2(String s) ... public R test3() ... public R test4(String s) ... &#125; 之前我们说到，泛型的实现是所谓的泛型擦除，也就是类型参数会被擦除到其限定的父类上。现在来看看test2这个方法，在父类和子类中，它们的方法描述符和泛型签名是不一样的： SupClass test2: (Ljava/lang/Object;)V &lt;T:Ljava/lang/Object;&gt;(T)V BaseClass test2: (Ljava/lang/String;)V null 虽然描述符不同，但是在逻辑上已经达成了重写条件，应该当作重写处理。但是，因为方法描述符不同，实际调用时JVM是找不到这个方法的：invokevirtual字节码只会寻找名称相同且方法描述符相同的方法。因此，桥接方法出现用于解决这个问题。它的代码意义就是将确定的类型参数强制转换，将父类泛型化的参数传入具体化的子类复写方法中。 例如test2，编译器给出的桥接方法就像下面这样： // BaseClass // 注意：不要在源码中这样写！编译器会因为&quot;具有相同擦除但不构成重写&quot;抛出异常 public void test2(Object s) &#123; // 父类的方法描述符 test2((String) s); // 通过强制类型转换，将参数列表转换以满足子类的方法描述符 &#125; 桥接方法仅出现在父类方法和子类重写方法擦除后的方法描述符不一致时，如下方的例子： interface SupClass&lt;T, R, E extends Exception&gt; &#123; void test1(T t); R test2(); void test3() throws E; &#125; class BaseClass&lt;R extends InputStream&gt; implements SupClass&lt;String, R, IOException&gt; &#123; void test1(String s) ... // 需要生成桥接方法：参数列表描述符不同 R test2() ... // 需要生成桥接方法：R擦除到的类型和父类擦除不一样 void test3() throws IOException ... // 不需要生成桥接方法：方法描述符相同 &#125; 桥接方法拥有下面的特性： 名称与方法描述符相同：为了invokevirtual字节码能成功定位到这个重写方法，桥接方法必须和父类的目标方法名称和描述符一致。 访问标志带有ACC_SYNTHETIC和ACC_BRIDGE标志。 访问权限和子类重写方法相同。 异常列表和父类方法相同。 接下来我们要使用字节码实现BaseClass： interface SupClass&lt;T&gt; &#123; void test(T t): &#125; class BaseClass implements SupClass&lt;String&gt; &#123; public void test(String s) &#123; System.out.println(s); &#125; &#125; 字节码： // 略过构造函数，cw是ClassWriter MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;test&quot;, &quot;(Ljava/lang/String;)V&quot;, null, null); mv.visitVarInsn(ALOAD, 1); mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitInsn(RETURN); mv.visitMaxs(2, 2); mv.visitEnd(); // 桥接方法 mv = cw.visitMethod(ACC_PUBLIC + ACC_SYNTHETIC + ACC_BRIDGE, &quot;test&quot;, &quot;(Ljava/lang/Object;)V&quot;, null, null); mv.visitVarInsn(ALOAD, 0); mv.visitVarInsn(ALOAD, 1); mv.visitTypeInsn(CHECKCAST, &quot;java/lang/String&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;Test&quot;, &quot;test&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitInsn(RETURN); mv.visitMaxs(2, 2); mv.visitEnd(); 内部类类的内部成员除了字段和方法外，还有内部类。内部类分为两种： 静态内部类：使用static修饰的内部类。内部接口、内部枚举默认带有static访问标志，因此它们也属于静态内部类。 非静态内部类：不使用static修饰的内部类。 内部类的字节码数据不应该在外部类中的类文件数据中出现，应该独立于外部类。命名方式为外部类名称$内部类名称；如果内部类是局部内部类，在内部类名称前还需要加上编号；如果内部类是一个匿名内部类，应该使用编号代替。 虽然内部类不需要写在外部类文件里面，但是外部类文件还是要声明它的。声明使用ClassWriter的visitInnerClass方法，它的每个参数的意义如下： name - 内部类的全限定名。例如test.Test下的内部类Inner这项值就是test/Test$Inner。 outerName - 外部类的全限定名，如果内部类是匿名内部类或局部内部类，这项是null。 innerName - 内部类的名称，如果内部类是匿名内部类，这项是null。 access - 内部类的访问标志。 最外层外部类需要写出它内部所有的类，包括嵌套的内部类。 下面是一些内部类和它们的声明： class Test &#123; private class Inner1 &#123; ... &#125; // 内部类1 - 成员内部类 public void test() &#123; class Inner2 &#123; ... &#125; // 内部类2 - 局部内部类 System.out.println(new Test() &#123; ... &#125;); // 内部类3 - 匿名内部类 &#125; &#125; // --- 字节码 外部类Test cw是ClassWriter cw.visitInnerClass(&quot;Test$Inner1&quot;, &quot;Test&quot;, &quot;Inner1&quot;, ACC_PRIVATE); cw.visitInnerClass(&quot;Test$1Inner2&quot;, null, &quot;Inner2&quot;, 0); // 局部内部类无访问标志 cw.visitInnerClass(&quot;Test$1&quot;, null, null, 0); // 匿名内部类无访问标志 在Java 11，JEP 181（Nest-Based Access Control）加入了NestHost和NestMember两项属性用于辅助访问权限控制，规定了所有内部类（包括嵌套的内部类）是最外层外部类的NestMember，最外层的外部类是所有内部类（包括嵌套）的NestHost。 声明NestMember使用ClassWriter的visitNestMember方法，参数是内部类的全限定名。写入它的字节码如下（仍然使用上方的代码）： cw.visitNestMember(&quot;Test$Inner1&quot;); cw.visitNestMember(&quot;Test$1Inner2&quot;); cw.visitNestMember(&quot;Test$1&quot;); 说回到内部类文件，它也需要声明外部类和NestHost。声明外部类也使用visitInnerClass方法，需要写出所有的外部类，包括嵌套；声明NestHost使用visitNestHost方法，参数是最外层外部类全限定名。 下面是Inner1声明外部类的字节码写入： cw.visitNestHost(&quot;Test&quot;); cw.visitInnerClass(&quot;Test$Inner1&quot;, &quot;Test&quot;, &quot;Inner1&quot;, ACC_PRIVATE); 内部类的声明到此为止，接下来看看内部类和外部类的不同之处。 对于非静态内部类，它的类对象需要依托于一个外部类实例才能创建。例如下方的代码： public class OuterClass &#123; public class InnerClass &#123; &#125; &#125; // ---- OuterClass outer = new OuterClass(); InnerClass inner = outer.new InnerClass(); // 正确：使用外部类实例调用内部类默认构造函数 InnerClass inner2 = new InnerClass(); // 错误：需要一个外部类对象创建内部类对象 非静态内部类保存了外部类的实例，保存的字段名称是this$嵌套类深度-1（如果名称已存在那么就在这个名字后加$直到不存在有这个名称的字段），以InnerClass举例，它的字节码实际上类似于这样： public class InnerClass &#123; final /* synthetic */ OuterClass this$0; ... &#125; 外部类实例字段要求访问标志是ACC_FINAL和ACC_SYNTHETIC。使用类名.this相当于使用这个字段逐级获取，下面两个代码等价： OuterClass.this this.this$0 为了适应外部类实例字段的加入，非静态内部类的构造函数和普通的构造函数不同。它的第一个局部变量仍然是this，但是第二个局部变量（或者说是第一个形式参数）成为了外部类的实例，从第二个形式参数开始才是真正在源码层级的参数列表。内部类的默认构造函数如下（使用InnerClass举例）。 public InnerClass(OuterClass this$0) &#123; // 源码中这样写和字节码中是不一样的，编译器会自动在第一个参数前加上这个参数 // 字节码中不要求super调用是第一句语句 this.this$0 = this$0; super(); &#125; 字节码如下： // cw是ClassVisitor MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;(LOuterClass;)V&quot;, null, null); mv.visitVarInsn(ALOAD, 0); mv.visitVarInsn(ALOAD, 1); mv.visitFieldInsn(PUTFIELD, &quot;OuterClass$InnerClass&quot;, &quot;this$0&quot;, &quot;LOuterClass;&quot;); // 赋值字段 mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); // 调用super mv.visitInsn(RETURN); mv.visitMaxs(2, 3); mv.visitEnd(); 密封类密封类（Sealed Class）于Java 15（JEP 360）被加入，它限制了类可被哪些类继承。下面是例子： public sealed class SupClass permits SubA, SubB &#123; // 密封类要求至少有一个子类 &#125; public non-sealed class SubA extends SupClass &#123; // 密封类子类要求必须具有non-sealed/sealed/final修饰 &#125; public final class SubB extends SupClass &#123; &#125; 声明密封类属性只需要ClassWriter的visitPermittedSubclass，参数是子类全限定名。上面的SupClass字节码可以这样写入： // cw是ClassWriter cw.visitPermittedSubclass(&quot;SubA&quot;); cw.visitPermittedSubclass(&quot;SubB&quot;); 类的基本结构就到这里，下一期：类的结构（二），主要讲解枚举、记录等特殊的类结构。","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：泛型","slug":"Java ASM详解：泛型","date":"2022-02-13T00:00:00.000Z","updated":"2022-02-13T04:35:53.486Z","comments":true,"path":"2022/02/13/Java ASM详解：泛型/","link":"","permalink":"http://nickid2018.github.io/2022/02/13/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"在之前的字节码学习中，我们都是对有确定类型的数据/类进行操作。可是，Java有着一种“黑”操作用于更好的检查对象类型：在Java 5加入的泛型。 泛型的声明在正式导入泛型声明之前，先说说泛型描述符。 普通的非基本类型的描述符的命名方法是L+类名+;，但是泛型不能以这种方式命名——它需要和普通的描述符有区别以便于区分。所以，它的命名要求是T+泛型名称+;。所以一个命名为T的泛型的描述符是TT;。接下来说回到声明。 每个泛型在使用之前必须经过声明，声明的位置是类、方法、字段、内部类等的声明部分。如果非静态方法或字段使用的泛型在它们所在的类中被声明过了，那么在它们声明时这个泛型不需要二次声明。 泛型要求必须继承于一个确切的类，对于没有写extends限定的泛型，它们默认继承于Object。 在字节码中，泛型的声明要用尖括号包围。每对泛型用冒号隔开，冒号前方是类型参数名称，后方是类型参数的超类或另一个已声明的类型参数。如果类型参数继承于一个接口，那么应该使用双冒号。（可以不用遵守这个约定，冒号数量不影响解析） 泛型与泛型之间不需要多余的分隔符分割它们的定义，这是因为描述符都以分号结尾从而阻止二义性的解析。（这里也就说明了为什么基本类型不能当类型参数的限制符号，它们的描述符不带分号会造成不可阻止的二义性解析） 下面是泛型声明的例子： T extends InputStream &lt;T:Ljava/io/InputStream;&gt; T extends Serializable &lt;T::Ljava/io/Serializable;&gt; T, E extends T &lt;T:Ljava/lang/Object;E:TT;&gt; 但是上面的几条规范不能包括我们使用的所有情况。就比如下面的例子： T extends Enum&lt;T&gt; 类型参数的超类具有类型参数的使用，这时我们需要写出超类类型参数的位置和限定关系。 对于一个使用了类型参数的类，它需要在类名之后分号之前用尖括号表示各个类型参数的配置。每个参数都可以是确切的类、声明过的类型参数或通配符。和上面的声明一样，因为描述符以分号结尾，不会产生二义性解析，因此不需要额外分隔符用于分割定义。 对于上面的例子，它的声明就可以表示成： &lt;T:Ljava/lang/Enum&lt;TT;&gt;;&gt; 这个T可以代指所有的枚举类型，因为所有的枚举都隐式继承Enum。 如果超类类型参数使用通配符?代替，就有三种情况： 没有任何限定，需要用*填入 有extends限定，需要用+加上超类描述符填入 有super限定，需要用-加上子类描述符填入 下面是这三种情况的实例： T extends Set&lt;?&gt; &lt;T::Ljava/util/Set&lt;*&gt;;&gt; T extends List&lt;? extends T&gt; &lt;T::Ljava/util/List&lt;+TT;&gt;;&gt; T extends Map&lt;? super FileInputStream, T&gt; &lt;T::Ljava/util/Map&lt;-Ljava/io/FileInputStream;TT;&gt;;&gt; 泛型签名泛型在声明之后就可以用于描述类、字段、方法等的具体描述符，这部分也叫泛型签名，是另一种描述类、字段、方法类型的方式。 泛型签名与修饰的结构有关。它不仅包含了类、字段、方法每个具体位置上需要的具体类型，还包含对泛型的声明。如果这个签名中使用的泛型没有被声明过，那么就应该在签名的前方加入它的声明。（也就是说声明是签名的一部分） 下面对签名的不同作用位置分开说明： 泛型签名修饰了一个类。类有两个地方需要泛型的信息：超类和实现接口。这些类的具体泛型信息要以超类和实现接口的顺序排列写入，写入规则和上面的类型参数超类写入规则一样。 public class Test&lt;T&gt; extends SuperClass&lt;T&gt; implements Interface1, Interface2&lt;T&gt; &lt;T:Ljava/lang/Object;&gt;LSuperClass&lt;TT;&gt;;LInterface1;LInterface2&lt;TT;&gt;; 泛型签名修饰了一个字段。字段只需要描述字段本身具体的泛型信息，并且字段不能定义泛型，所以泛型签名只包含它的类型的泛型信息。 public Set&lt;T&gt; set; Ljava/util/Set&lt;TT;&gt;; 泛型签名修饰了一个方法。这时这里就是方法描述符的具体泛型信息。格式类似普通的方法描述符，只是泛型信息的写入要遵照上方规则。如果方法带有抛出异常声明并且异常列表含有泛型，那么在描述符之后还要加上异常列表。异常列表的每个类都要用^开头并且需要写出具体的泛型信息。 public &lt;E extends Exception&gt; void test(T obj, List&lt;? super T&gt; list) throws E &lt;E:Ljava/lang/Exception;&gt;(TT;Ljava/util/List&lt;-TT;&gt;;)V^TE; 下面我们定义一个类作为例子，写出所有成员的泛型签名： public abstract class Test&lt;T extends List&lt;? extends Number&gt;&gt; implements Comparable&lt;T&gt; &#123; // &lt;T::Ljava/util/List&lt;+Ljava/lang/Number;&gt;;&gt;Ljava/lang/Object;Ljava/lang/Comparable&lt;TT;&gt; public abstract &lt;E extends Exception&gt; void test1(T obj) throws E; // &lt;E:Ljava/lang/Exception;&gt;(TT;)V^TE; public abstract T test2(); // ()TT; public Set&lt;T&gt; set; // Ljava/lang/Set&lt;TT;&gt;; &#125; 泛型擦除在阅读完上面的文本后，你可能会有一个疑问：Java已经有方法描述符可以用来描述方法、字段描述符来描述字段等等，为什么还要再加入一个泛型签名用于额外的检查呢？这就有关于Java对泛型的具体实现方式，也就是泛型擦除。 在正式介绍这个机制之前，我们先看看反射对于泛型的处理。定义下面这个类： public class Test&lt;T extends InputStream&gt; &#123; public void test(T stream) &#123; &#125; &#125; 接下来我们想要反射调用test这个方法。可是我们看到这个方法的形参列表里面含有一个类型参数T，这个我们没有办法具体表示。所以，我们可以用Class类的getDeclaredMethods获取所有方法检查它的真正形参列表的样子： [public void Test.test(java.io.InputStream)] 可以看到，类型参数的形参的位置上使用了它的超类InputStream。字节码在所有的含有类型参数的地方都用它们的超类的原始类型代替，这种现象就是泛型擦除。 泛型擦除保证了JVM获取方法时不含有未知量，在本质上其实是保证各个字节码中只存在静态的信息，这样能保证运行的正确性，不会产生方法的二义性调用等。 对于具体的字节码，所有字节码指令都不能用带有泛型信息的类。具体来说，new/checkcast/instanceof/invokeXXX字节码都不能使用任何泛型信息，它们只能使用原始类型和替换的超类。 在JVM中，泛型擦除之后泛型的真正实现其实是checkcast等字节码指令的约束和运行时对于对象真实类型推断的方法。在下面的例子中能体现字节码对于泛型的约束。 实例：泛型方法下面，我们要生成这样的代码： public static &lt;T extends Number&gt; int test(List&lt;? extends T&gt; list, T value) &#123; Comparator&lt;? super Number&gt; comparator = (n1, n2) -&gt; (int) Math.signum(n1.doubleValue() - n2.doubleValue()); list.sort(comparator); T num = list.get(0); return num.intValue() + Collections.binarySearch(list, value, comparator); &#125; 首先写出它的方法描述符和泛型签名： Desc: (Ljava/util/List;Ljava/lang/Number;)I // List擦除类型参数所以回到原始类型，T擦除到父类Number Signature: &lt;T:Ljava/lang/Number;&gt;(Ljava/util/List&lt;+TT;&gt;;TT;)I 接下来注意到第一行有一个lambda表达式，它实现的是Comparator类的compare方法。根据comparator变量的类型，得知实现方法的参数列表应该是(Number, Number)。所以我们应该生成下面的lambda方法： private static /* synthetic */ int lambda$test$0(Number n1, Number n2) &#123; return (int) Math.signum(n1.doubleValue() - n2.doubleValue()); &#125; 字节码写入如下： // 省略方法声明，mv是MethodVisitor mv.visitVarInsn(ALOAD, 0); // n1 mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Number&quot;, &quot;doubleValue&quot;, &quot;()D&quot;, false); mv.visitVarInsn(ALOAD, 1); // n2 mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Number&quot;, &quot;doubleValue&quot;, &quot;()D&quot;, false); mv.visitInsn(DSUB); // 相减 mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Math&quot;, &quot;signum&quot;, &quot;(D)D&quot;, false); mv.visitInsn(D2I); // 强制类型转换 mv.visitInsn(IRETURN); mv.visitMaxs(4, 2); 这时候就能把comparator给构造出来了。注意我们实现的方法是compare(Object, Object)——类型参数T被擦除到父类型Object（这和你代码中的使用无关，取决于类和方法的定义），而我们需要的实现是(Number, Number)，这两个不冲突，但是会损失类型信息（下文会讲）。因此我们inDy的参数第一个是实现的目标的描述符，第三个是我们真正实现目标的描述符。 mv.visitInvokeDynamicInsn(&quot;compare&quot;, // 实现的方法名 &quot;()Ljava/util/Comparator;&quot;, // 要求返回Comparator，注意泛型被擦除 new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/LambdaMetafactory&quot;, &quot;metafactory&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM的句柄 Type.getType(&quot;(Ljava/lang/Object;Ljava/lang/Object;)I&quot;), // compare的方法描述符，泛型擦除到了Object new Handle(H_INVOKESTATIC, &quot;Test&quot;, &quot;lambda$test$0&quot;, &quot;(Ljava/lang/Number;Ljava/lang/Number;)I&quot;, false), // lambda实现方法的句柄 Type.getType(&quot;(Ljava/lang/Number;Ljava/lang/Number;)I&quot;) // 真正实现的方法描述符 ); mv.visitVarInsn(ASTORE, 2); 剩下的代码就比较简单了，就像下面这样： mv.visitVarInsn(ALOAD, 0); // list mv.visitVarInsn(ALOAD, 2); // comparator mv.visitMethodInsn(INVOKEINTERFACE, &quot;java/util/List&quot;, &quot;sort&quot;, &quot;(Ljava/util/Comparator;)V&quot;, true); mv.visitVarInsn(ALOAD, 0); // list mv.visitInsn(ICONST_0); mv.visitMethodInsn(INVOKEINTERFACE, &quot;java/util/List&quot;, &quot;get&quot;, &quot;(I)Ljava/lang/Object;&quot;, true); // 返回值被擦除到Object，这和List::get定义有关而和使用无关 mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Number&quot;); // 强制转换到T的擦除类型Number，这是因为局部变量的类型是T mv.visitVarInsn(ASTORE, 3); mv.visitVarInsn(ALOAD, 3); // num mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Number&quot;, &quot;intValue&quot;, &quot;()I&quot;, false); mv.visitVarInsn(ALOAD, 0); // list mv.visitVarInsn(ALOAD, 1); // value mv.visitVarInsn(ALOAD, 2); // comparator mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/Collections&quot;, &quot;binarySearch&quot;, &quot;(Ljava/util/List;Ljava/lang/Object;Ljava/util/Comparator;)I&quot;, false); mv.visitInsn(IADD); mv.visitInsn(IRETURN); mv.visitMaxs(4, 4); 这样我们的使用泛型的方法就构建好了。我们可以通过反射传入参数： // Loader::defineClassNow是自定义的类加载器加载类的方法 Class&lt;?&gt; generated = new Loader().defineClassNow(&quot;Test&quot;, cw.toByteArray()); System.out.println(generated.getDeclaredMethod(&quot;test&quot;, List.class, Number.class) .invoke(null, new ArrayList&lt;&gt;(List.of(1, 2, 3, 4)), 3)); 得到的结果是： 3 这就说明了我们的方法写入成功并成功地被JVM执行。 泛型的安全性泛型的加入本质是为了确保代码的简洁和编译时辅助类型检查，也就是说，泛型能阻止类型的错误转换，就比如下面的例子： List list = new ArrayList(); list.add(&quot;hello&quot;); int i = (Integer) list.get(0); 这种代码在javac编译时是无法检查出语法和类型错误的：List的封装性造成了它内部数据的类型丢失，在get时只能得知对象是Object子类的对象但是不能得知确切的类型。但是在JVM运行时这就不一样了。JVM能知道任何对象的确切类型，因此在强制转换Integer时JVM能探测到String-&gt;Integer这种不可能的强制类型转换并抛出ClassCastException。 当泛型加入后，这种情况被改变了： List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;hello&quot;); int i = (Integer) list.get(0); 这样的代码在javac就不能通过编译了：get的返回值是类型参数T（通过字节码中的泛型签名得知），在前面的声明中已经定义为String，因此javac可以探测到这个不可能的类型转换，抛出编译异常阻止编译，保证类型的安全性。 总而言之，泛型确保了源码级别上的类型安全性。 但是在字节码上看来，这就是另外一回事了。因为“泛型擦除”机制，字节码是不能使用泛型检查的，只能通过类型参数的已知超类约束泛型。但是这种约束不能阻止我们使用错误的类型传入：类验证时是无法检查泛型的。下面使用反射（本质和字节码差不多）举一个例子，使用到了我们刚才写的泛型方法： System.out.println(generated.getDeclaredMethod(&quot;test&quot;, List.class, Number.class) .invoke(null, new ArrayList&lt;&gt;(List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;)), 3)); 这里是不会产生任何警告的（即使在IDE中），但是我们能清楚的看出它不符合我们对于test的定义：test要求传入的是List&lt;? extends T&gt;和T的形参，并且T要求是Number的子类，但是我们实际传入的是List&lt;String&gt;和Number，明显不符合test的形参列表。可是我们是能成功调用的：类型擦除让这些类型回到了原始类型，也就是说test的形参列表变成了List和Number，这时与我们传入的对象相符合，因此反射调用不会产生问题，但是在方法内的具体实现时会使用到checkcast用于类型转换，这里就会被JVM检测到异常并抛出ClassCastException。对于我们的这个调用，它最后的结果是： Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:568) at io.github.nickid2018.asmtest.ASMMain.main(ASMMain.java:23) Caused by: java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader &#x27;bootstrap&#x27;) at java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355) at java.base/java.util.TimSort.sort(TimSort.java:220) at java.base/java.util.Arrays.sort(Arrays.java:1307) at java.base/java.util.ArrayList.sort(ArrayList.java:1721) at Test.test(Unknown Source) ... 5 more 这样的结果说明了泛型在字节码中是不能保证安全的，类验证无法通过泛型签名阻止错误调用。因此在写入字节码时，遇到泛型必须严谨的检查，否则就会因为类型信息的丢失造成了类型的不安全行为，并且在写字节码时应尽量避免使用泛型。泛型的便利性仅体现在源码上，字节码中的泛型写入很麻烦。 有关于泛型的字节码知识就到这里了，有错误可以在评论指出。 到这里有关于具体方法字节码的写入就结束了，之后主要是有关于类结构的详解和ASM库各种工具的讲解。 下一篇文章暂定为类的结构（一）。","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：MethodVisitor与Opcode（五）invokedynamic、方法句柄、lambda","slug":"Java ASM详解：MethodVisitor与Opcode（五）invokedynamic、方法句柄、lambda","date":"2021-12-02T00:00:00.000Z","updated":"2021-12-02T07:54:42.213Z","comments":true,"path":"2021/12/02/Java ASM详解：MethodVisitor与Opcode（五）invokedynamic、方法句柄、lambda/","link":"","permalink":"http://nickid2018.github.io/2021/12/02/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%BA%94%EF%BC%89invokedynamic%E3%80%81%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84%E3%80%81lambda/","excerpt":"","text":"前四篇专栏已经简要的描述了常用的字节码，这篇专栏将讲述Java 7以来最重要的字节码之一：invokedynamic。 方法句柄（Method Handle）方法句柄在Java 7时被引入，位于java.lang.invoke包下。它类似于反射，但与反射不同的是，它的检查在创建阶段就已经结束，而反射需要每次运行时检查，所以在理论上方法引用更快。 方法类型（Method Type）方法句柄包含了一个方法的信息——所在的类、名称、参数列表与返回值。为了描述参数列表与返回值，Java引入了一个类————即MethodType，来描述它们。 它类似于反射使用的getMethod方法，但是它不仅需要参数列表，它还需要返回值。创建一个MethodType可以使用下面的方法： public static MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) public static MethodType methodType(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes) public static MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0, Class&lt;?&gt;... ptypes) public static MethodType methodType(Class&lt;?&gt; rtype) public static MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0) public static MethodType methodType(Class&lt;?&gt; rtype, MethodType ptypes) 这些方法中的rtype参数都代表了返回值类型，ptypes代表了参数类型。 下面是一个例子：使用MethodType描述Arrays::binarySearch(Object[], int, int, Object) -&gt; int MethodType mt = MethodType.methodType(int.class, Object[].class, int.class, int.class, Object.class); 从已有的方法中提取方法句柄为了获取一个方法句柄，最简单的途径就是从一个现成的方法中提取。为了从一个现成的类中提取一个方法句柄，我们需要一个MethodHandles.Lookup对象，这个对象有两种获取方法： public static Lookup lookup() // 可查找所有方法 public static Lookup publicLookup() // 只可以查找公有方法 Lookup类提供了以下方法用于查找方法句柄对象： // 查找静态方法 public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException // 查找实例方法 public MethodHandle findVirtual(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException // 查找构造函数 public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException // 查找特殊执行的方法（需要特殊指定执行类） public MethodHandle findSpecial(Class&lt;?&gt; refc, String name, MethodType type, Class&lt;?&gt; specialCaller) throws NoSuchMethodException, IllegalAccessException // 查找获取字段的方法句柄（不是调用你定义的方法，而是系统内建一个getter的方法句柄） public MethodHandle findGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException // 查找设置字段的方法句柄（同上，系统内建setter） public MethodHandle findSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException // 查找获取静态字段的方法句柄（同上） public MethodHandle findStaticGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException // 查找设置静态字段的方法句柄（同上） public MethodHandle findStaticSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException 可以看到，这些find方法都实现了某个字节码的功能：findStatic与invokestatic进行对应、findGetter与getfield对应等。 除了查找方法，从一个反射对象反反射也能获得方法句柄对象： // 从Method反反射到一个方法句柄上 public MethodHandle unreflect(Method m) throws IllegalAccessException // 从Method反反射到一个方法句柄上，需要指定特殊执行类 public MethodHandle unreflectSpecial(Method m, Class&lt;?&gt; specialCaller) throws IllegalAccessException // 从Constructor反反射到方法句柄上 public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException // 从Field反反射到方法句柄上 public MethodHandle unreflectGetter(Field f) throws IllegalAccessException // 从Field反反射到方法句柄上 public MethodHandle unreflectSetter(Field f) throws IllegalAccessException 下面是使用例： 获取System::currentTimeMillis() -&gt; long的方法句柄 MethodType mt = MethodType.methodType(long.class); // ()J MethodHandle handle = MethodHandles.lookup().findStatic(System.class, &quot;currentTimeMillis&quot;, mt); 获取获得System.out(java.io.PrintStream)字段的方法句柄 MethodHandle handle = MethodHandles.lookup().findStaticGetter(System.class, &quot;out&quot;, PrintStream.class); 获取String::&lt;init&gt;()的方法句柄 MethodType mt = MethodType.methodType(void.class); // ()V MethodHandle handle = MethodHandles.lookup().findConstructor(String.class, mt); 获取访问sun.misc.Unsafe.theUnsafe(Unsafe)字段的方法句柄 // 因为Unsafe.theUnsafe是private，所以要用反射先获取Field解除访问限制之后再进行反反射 Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); field.setAccessible(true); MethodHandle handle = MethodHandles.lookup().unreflectGetter(field); 自定义方法句柄方法句柄不止可以通过查找获取，还可以通过MethodHandles内置的一些方法获取，下面是一部分内置的方法句柄生成器： // 创建数组的方法句柄，需要传入int作为数组长度，返回数组；参数类必须是数组类；对应ANEWARRAY public static MethodHandle arrayConstructor(Class&lt;?&gt; arrayClass) throws IllegalArgumentException // 获取数组长度的方法句柄，需要一个数组传入，返回长度；参数类必须是数组类；对应ARRAYLENGTH public static MethodHandle arrayLength(Class&lt;?&gt; arrayClass) throws IllegalArgumentException // 其他数组操作忽略 // 创建返回参数自身的方法句柄 public static MethodHandle identity(Class&lt;?&gt; type) // 创建返回常量的方法句柄，实际实现是identity(type).bindTo(value) public static MethodHandle constant(Class&lt;?&gt; type, Object value) // 创建返回null的方法句柄 public static MethodHandle zero(Class&lt;?&gt; type) // 类似zero，但是可以传入参数 public static MethodHandle empty(MethodType type) // 创建一个方法句柄，用于在第pos参数后插入values个参数传入target public static MethodHandle insertArguments(MethodHandle target, int pos, Object... values) // 创建一个方法句柄，用于取消第pos参数后valueTypes的参数传入target public static MethodHandle dropArguments(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) public static MethodHandle dropArguments(MethodHandle target, int pos, Class&lt;?&gt;... valueTypes) // 创建取消target返回的方法句柄 public static MethodHandle dropReturn(MethodHandle target) // 创建一个方法句柄，用于筛选第pos参数后传入target的方法参数 public static MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) 这些生成器不止包括了基本的创建对象与对象操作，还实现了一部分流程结构，也就是说你可以通过MethodHandles“动态”地创建一个方法片段。 使用方法句柄说了这么多创建方法句柄的方式，我们该怎么使用它呢？MethodHandle提供了两个方法用于执行方法句柄： @IntrinsicCandidate public final native @PolymorphicSignature Object invoke(Object... args) throws Throwable @IntrinsicCandidate public final native @PolymorphicSignature Object invokeExact(Object... args) throws Throwable 这两种调用方式的区别在于参数的类型转换：invokeExact要求参数必须准确对应MethodType定义的参数，而invoke会进行自动转换来尝试对应。 如果无法对应参数，这两个方法都会抛出WrongMethodTypeException。 下面给出一个例子，使用上面2.1创建的MethodHandle： long time = (long) (handle.invokeExact()); 有些情况下，我们不需要第一个参数变化（实例方法的调用对象/静态方法的第一个参数），这时我们可以用bindTo绑定第一个参数： public MethodHandle bindTo(Object x) 下面是使用例： MethodHandle handle = MethodHandles.lookup().findVirtual(PrintStream.class, &quot;println&quot;, MethodType.methodType(void.class, String.class)).bindTo(System.out); handle.invokeExact(&quot;hello&quot;); 说完了方法句柄，接下来来看看CallSite。 动态调用点（CallSite）CallSite是一个为了引导invokedynamic字节码指向调用方法的类，通过它的dynamicInvoker方法可以获取一个方法句柄，这个句柄就代表了inDy的目标。 非常量动态调用点允许重新指定调用目标，这时inDy会对目标进行重新连接。 它有三个子类：ConstantCallSite、MutableCallSite和VolatileCallSite。它们的区别如下： ConstantCallSite指向的方法句柄不能修改，也就是永久性的。连接到它的inDy指令会永远绑定这个方法句柄。 MutableCallSite允许修改指向的方法句柄目标，指向目标的行为类似普通字段。它的目标改变是不同步的——当调用目标被另一个线程修改，现在的线程不一定能同步到更新的值。为了强制同步，可以使用MutableCallSite::syncAll。连接到它的inDy指令每次调用都会调用它当前的方法句柄目标。 VolatileCallSite类似MutableCallSite，其指向的目标可以修改。它的行为类似volatile字段，另一个线程修改指向目标会立刻反应到现在的线程，因此不需要syncAll之类的方法保持同步。volatile会造成不可避免的性能损失，所以如果不涉及线程问题最好用MutableCallSite。 下面演示了常量动态调用点的使用方法（此处不涉及inDy）： MethodType type = MethodType.methodType(String.class, int.class, int.class); MethodHandle handle = MethodHandles.lookup().findVirtual(String.class, &quot;substring&quot;, type); ConstantCallSite callSite = new ConstantCallSite(handle); // 创建常量调用点 MethodHandle invoker = callSite.dynamicInvoker(); // 获取动态的方法句柄 assert handle == invoker; // 这两个是一个对象 String str = (String) (invoker.invokeExact(&quot;hello&quot;, 1, 3)); 引导方法（BootStrap Method，简称BSM）在Java类执行中，少不了动态的东西。这些动态的东西分为两类：一种是动态计算调用点，一种是动态计算常量。引导方法就是为了它们产生的。 动态计算常量，由ConstantDynamic表示。它们在JVM使用它们之前被解析，解析时调用的就是它内部的引导方法和它们内置的引导方法参数。 动态计算调用点，也就是inDy的实现。inDy的目标在第一次调用它之前解析调用获得CallSite。 引导方法的声明有一定规则，和它们的使用方式有关： 如果引导方法用于动态计算常量，则引导方法的前三个参数分别是MethodHandles.Lookup、String、Class对象，分别代表了调用方、名称和常量类型，后面的参数是其他静态参数，返回值需要与Class对象代表的类型保持一致（或者写为Object，只需要运行时返回值可以被强制转换到指定类型就可以）。 如果引导方法用于动态计算调用点，则引导方法的前三个参数分别是MethodHandles.Lookup、String、MethodType对象，分别代表调用方、名称和调用点方法类型，后面的参数是其他静态参数，它的返回值要求是CallSite（通常是ConstantCallSite，当然写成Object也可以，只要保证能被强制类型转换成CallSite就不报错） 下面是一些正确的用于动态计算调用点的引导方法声明： CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args) CallSite bootstrap(Lookup caller, String name, MethodType type) // 没有其他静态参数 CallSite bootstrap(Lookup caller, Object... nameAndType) CallSite bootstrap(Lookup caller, String name, MethodType type, Object arg) // 只有一个静态参数 CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args) CallSite bootstrap(Lookup caller, String name, MethodType type, String... args) // 只允许String静态参数 CallSite bootstrap(Lookup caller, String name, MethodType type, String x, int y) // 只允许一个String和一个int作为静态参数传入 CallSite bootstrap(Object... args) CallSite bootstrap(Object caller, Object... nameAndTypeWithArgs) 注意：静态参数允许了动态计算常量传入。 invokedynamic字节码经过前面一系列的铺垫，终于我们要讲inDy该怎么写入了。 写入inDy字节码需要使用MethodVisitor的方法，visitInvokeDynamicInsn： public void visitInvokeDynamicInsn( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) 它的四个参数分别是名称、方法描述符、引导函数的句柄和传入引导方法的静态参数。名称和描述符都分别对应了引导方法的参数：name（第二个参数）、type（第三个参数）。 这里面的Handle句柄不等于MethodHandle方法句柄，但是它们也是紧密相关的，它的定义如下： public Handle( final int tag, final String owner, final String name, final String descriptor, final boolean isInterface) 可以看到这里的参数和visitMethodInsn的参数基本一样。第一个参数是调用标签，分为9个，它们与方法句柄差不多： H_GETFIELD，对应findGetter，字节码getfield，要求isInterface是false H_GETSTATIC，对应findStaticGetter，字节码getstatic，要求isInterface是false H_PUTFIELD，对应findSetter，字节码putfield，要求isInterface是false H_PUTSTATIC，对应findStaticSetter，字节码putstatic，要求isInterface是false H_INVOKEVIRTUAL，对应findVirtual，字节码invokevirtual H_INVOKESTATIC，对应findStatic，字节码invokestatic H_INVOKESPECIAL，对应findSpecial，字节码invokespecial H_NEWINVOKESPECIAL，对应findConstuctor，字节码invokespecial H_INVOKEINTERFACE，对应findVirtual，字节码invokeinterface，isInterface是true 下面是个例子，将Arrays::binarySearch(Object[], int, int, Object) -&gt; int用Handle表述： new Handle(H_INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;binarySearch&quot;, &quot;([Ljava/lang/Object;IILjava/lang/Object;)I&quot;, false); 那么inDy对操作栈做了什么？这就和它的第二个参数，descriptor有关系了。 之前说过，BSM会传入一个MethodType，而这个MethodType是用于描述返回动态调用点目标句柄的。又由于descriptor在字节码中最终会解释成为MethodType，所以能得出一个结论：descriptor决定了BSM返回CallSite内部方法句柄的类型。 而inDy在JVM的操作正是通过CallSite获取dynamicInvoker进行调用——也就是说，inDy相当于间接调用了一个类型为descriptor的方法。这样我们就不难理解inDy对操作栈干了什么：弹出descriptor指定的一部分参数并压回规定的返回值。 JVM调用BSM的逻辑可以在java.lang.invoke.BootstrapMethodInvoker找到。 使用inDy字节码还需要一步操作：你需要让你的类访问MethodHandles.Lookup，因此你需要在类声明时加入一个visitInnerClassInsn（其实不加也不会报错，但是最好加上）： cw.visitInnerClass(&quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;java/lang/invoke/MethodHandles&quot;, &quot;Lookup&quot;, ACC_PUBLIC | ACC_FINAL | ACC_STATIC); lambda表达式匿名函数表达式，简称lambda表达式，它在Java 8被加入。它简化了一部分的匿名类，让代码更加简洁。 为了展示它的用法和字节码表示，我们先定义一个接口和一个方法： public static void test(StringSupplier lambda) &#123; System.out.println(lambda.getString()); &#125; @FunctionalInterface public interface StringSupplier &#123; String getString(); &#125; 接着，我们使用这个方法： public static void main(String[] args) &#123; test(() -&gt; &quot;hello&quot;); &#125; 这时，后面的() -&gt; &quot;hello&quot;被解析成了一个StringSupplier的实现类对象。但是，在字节码中无法自动去生成一个这样的类用于适配它。于是，javac在此处写入了inDy字节码要求动态生成。 动态生成lambda调用点的引导方法位于java.lang.invoke.LambdaMetafactory： // 使用了优化协议的标准版本 public static CallSite metafactory(MethodHandles.Lookup caller, String interfaceMethodName, MethodType factoryType, MethodType interfaceMethodType, MethodHandle implementation, MethodType dynamicMethodType) throws LambdaConversionException // 备用版本 public static CallSite altMetafactory(MethodHandles.Lookup caller, String interfaceMethodName, MethodType factoryType, Object... args) throws LambdaConversionException 通常情况下，javac生成的lambda都是通过第一个BSM的，这6个参数的意义分别是： caller，由JVM提供的查找对象，lambda会使用这个进行动态类创建 interfaceMethodName，lambda实现接口内部需要实现的方法名称 factoryType，要求BSM返回CallSite内部指向方法句柄的方法类型 interfaceMethodType，lambda实现接口内需要实现方法的类型 implementation，实现lambda内部代码功能的方法句柄 dynamicMethodType，实现lambda内部代码功能方法的类型，和interfaceMethodType相同或者是它的更具体的类型 可以看到，为了提供lambda的功能，javac会让inDy字节码连接到另一个方法上去。这种方法不需要我们自己写，它是编译时自动生成的，名称是lambda$方法名$序号。上例中，javac动态生成的lambda方法如下： private static /* synthetic */ String lambda$main$0() &#123; return &quot;hello&quot;; &#125; 这些方法都带有private和synthetic的访问标志，是否拥有static访问标志取决于lambda在的方法是否静态和是否使用this对象。 接下来，我们使用这个方法连接到LambdaMetafactory： // 注意：这只是个演示！真正的字节码不是这样，这只是一种方式用于理解调用流程！ test(LambdaMetafactory.metafactory( lookup, // JVM提供 &quot;getString&quot;, // lambda实现方法的名称 MethodType.methodType(StringSuppiler.class), // 返回CallSite中的方法类型 MethodType.methodType(String.class), // 需要提供接口方法的类型，描述符()Ljava/lang/String; MethodHandles.lookup().findStatic(Test.class, &quot;lambda$main$0&quot;, MethodType.methodType(String.class)), // lambda的实现 MethodType.methodType(String.class)) // 指向方法目标的类型，描述符()Ljava/lang/String; .dynamicInvoker() .invokeExact() ); metafactory通过这些参数可以动态创建一个类实现指定的接口获得实现接口的对象。具体而言，它通过asm库（java内置了asm库）在现在的类中动态的生成了内部类，类的名称是$Lambda$序号（但是在getClass()获取时名称不是这个，因为这个类被“隐藏”定义，会带上另一个编号）。对于这个例子，生成的内部类像下面这样： final /* synthetic */ class $Lambda$14 implements StringSupplier &#123; // 序号不重要 private $Lambda$14() &#123; super(); &#125; public String getString() &#123; // 实现 return Test.lambda$main$0(); // 注意这里使用的不是方法句柄 &#125; &#125; 对于这种lambda表达式，生成的类对象永远不变，所以JVM对此进行优化——这种lambda只会生成一个实例，返回的CallSite其实只是返回一个常量（详情可见InnerClassLambdaMetafactory）。 说回到字节码的写入。之前说过visitInvokeDynamicInsn和BSM的参数一一对应，所以我们可以这样写入： mv.visitInvokeDynamicInsn(&quot;getString&quot;, // 实现的方法名称 &quot;()LStringSupplier;&quot;, // 要求返回CallSite的类型 new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/LambdaMetafactory&quot;, &quot;metafactory&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM的句柄 Type.getType(&quot;()Ljava/lang/String;&quot;), // 接口方法的类型 new Handle(H_INVOKESTATIC, &quot;Test&quot;, &quot;lambda$main$0&quot;, &quot;()Ljava/lang/String;&quot;, false), // lambda的实现代码 Type.getType(&quot;()Ljava/lang/String;&quot;) // lambda实现方法的类型 ); mv.visitMethodInsn(INVOKESTATIC, &quot;Test&quot;, &quot;test&quot;, &quot;(LStringSupplier;)V&quot;, false); // 调用test mv.visitInsn(RETURN); mv.visitMaxs(1, 1); // 最大操作栈[StringSupplier]，局部变量表[[Ljava/lang/String;] 除了这种lambda外，还有另一种lambda：它们需要局部变量传入内部。这些局部变量有要求——它们无法被修改，或者叫“等效终态”。下面是一个例子： // main方法 /* final */ String hello = &quot;hello&quot;; test(() -&gt; hello); 由于传入了局部变量，lambda的实现方法就需要多加一个参数用于传递这个变量。下面是javac生成的lambda代理实现方法： private static /* synthetic */ String lambda$main$0(String str) &#123; return str; &#125; 但是这个str要怎么透过inDy字节码进行传入？JVM为了解决这个问题，在动态生成的委托类上做了一些操作：让传入的变量先用构造函数存储在字段里，在调用时取出字段值： final /* synthetic */ class $Lambda$14 implements StringSupplier &#123; // 序号不重要 private final String arg$0; // 用于储存传入的局部变量，名称以序号命名 private $Lambda$14(String str) &#123; super(); arg$0 = str; &#125; public String getString() &#123; // 实现 return Test.lambda$main$0(arg$0); &#125; &#125; 但是，这种lambda的CallSite不能返回一个常量——因为我们不能保证局部变量是同一个值！因此，这个CallSite内部指向了动态生成内部类的构造函数。 接下来，我们用字节码写入一下： mv.visitLdcInsn(&quot;hello&quot;); mv.visitVarInsn(ASTORE, 1); // 保存变量到1号位 mv.visitVarInsn(ALOAD, 1); // 加载1号位 mv.visitInvokeDynamicInsn(&quot;getString&quot;, // 实现的方法名称 &quot;(Ljava/lang/String;)LStringSupplier;&quot;, // 要求返回CallSite的类型，注意这里要求传入String局部变量 new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/LambdaMetafactory&quot;, &quot;metafactory&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM的句柄 Type.getType(&quot;()Ljava/lang/String;&quot;), // 接口方法的类型 new Handle(H_INVOKESTATIC, &quot;Test&quot;, &quot;lambda$main$0&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, false), // lambda的实现代码 Type.getType(&quot;()Ljava/lang/String;&quot;) // lambda实现方法的类型（生成内部类实现方法的类型） ); mv.visitMethodInsn(INVOKESTATIC, &quot;Test&quot;, &quot;test&quot;, &quot;(LStringSupplier;)V&quot;, false); // 调用test mv.visitInsn(RETURN); mv.visitMaxs(1, 2); // 最大操作栈[StringSupplier]，局部变量表[[Ljava/lang/String;Ljava/lang/String;] 方法引用当lambda内只有一行方法调用时，在特定条件下可以简写为方法引用。它分为不同的类型： 静态调用当方法引用指向一个类中的静态方法时，就是静态调用，类似于： public static String hello() &#123; return &quot;hello&quot;; &#125; // ... test(Test::hello); 它的实现类似于lambda，但是不同的是，javac编译时不会生成一个新的方法用于lambda定位，而是选择直接指向这个方法： mv.visitInvokeDynamicInsn(&quot;getString&quot;, // 实现的方法名称 &quot;()LStringSupplier;&quot;, // 要求返回CallSite的类型 new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/LambdaMetafactory&quot;, &quot;metafactory&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM的句柄 Type.getType(&quot;()Ljava/lang/String;&quot;), // 接口方法的类型 new Handle(H_INVOKESTATIC, &quot;Test&quot;, &quot;hello&quot;, &quot;()Ljava/lang/String;&quot;, false), // 方法引用的目标 Type.getType(&quot;()Ljava/lang/String;&quot;) // lambda实现方法的类型（生成内部类实现方法的类型） ); mv.visitMethodInsn(INVOKESTATIC, &quot;Test&quot;, &quot;test&quot;, &quot;(LStringSupplier;)V&quot;, false); // 调用test mv.visitInsn(RETURN); mv.visitMaxs(1, 1); // 最大操作栈[StringSupplier]，局部变量表[[Ljava/lang/String;] 对象调用当方法引用的目标不是静态的，它就需要使用一个对象用于方法的调用，下面是个例子： public String hello() &#123; return &quot;hello&quot;; &#125; // ... test(new Test()::hello); 这类似于将局部变量传入了lambda内部，因此这里的inDy字节码是这样写的： mv.visitTypeInsn(NEW, &quot;Test&quot;); // 创建Test类对象 mv.visitInsn(DUP); // 复制一份 mv.visitMethodInsn(INVOKESPECIAL, &quot;Test&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); // 构造函数调用 mv.visitInvokeDynamicInsn(&quot;getString&quot;, // 实现的方法名称 &quot;(LTest;)LStringSupplier;&quot;, // 要求返回CallSite的类型，注意这里要求传入Test局部变量 new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/LambdaMetafactory&quot;, &quot;metafactory&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM的句柄 Type.getType(&quot;()Ljava/lang/String;&quot;), // 接口方法的类型 new Handle(H_INVOKEVIRTUAL, &quot;Test&quot;, &quot;hello&quot;, &quot;()Ljava/lang/String;&quot;, false), // 方法引用的目标 Type.getType(&quot;()Ljava/lang/String;&quot;) // lambda实现方法的类型（生成内部类实现方法的类型） ); mv.visitMethodInsn(INVOKESTATIC, &quot;Test&quot;, &quot;test&quot;, &quot;(LStringSupplier;)V&quot;, false); // 调用test mv.visitInsn(RETURN); mv.visitMaxs(2, 1); // 最大操作栈[Test,Test]，局部变量表[[Ljava/lang/String;] 对象调用的对象没有特殊要求，只需要能获得这个局部变量就可以。方法引用的目标可以是实例方法，也可以是抽象方法（区别在于Handle的标签）。 由于JVM不能保证传入的局部变量是非空的（例外就是上面的情况：直接新建对象），所以在传入lambda之前，JVM会进行requireNonNull进行检查。也就是说，下面这两种方式等价： Test obj; // ... // 1 test(obj::hello); // 2 Objects.requireNonNull(obj); test(() -&gt; obj.hello()); 上面的方法引用版本的代码可以写为： mv.visitVarInsn(ALOAD, 1); // 假设位于1号位 mv.visitInsn(DUP); // 复制一份，使用时可以不进行复制 mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/Objects&quot;, &quot;requireNonNull&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;, false); mv.visitInsn(POP); // 弹出栈顶 mv.visitInvokeDynamicInsn(&quot;getString&quot;, // 实现的方法名称 &quot;(LTest;)LStringSupplier;&quot;, // 要求返回CallSite的类型，注意这里要求传入Test局部变量 new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/LambdaMetafactory&quot;, &quot;metafactory&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM的句柄 Type.getType(&quot;()Ljava/lang/String;&quot;), // 接口方法的类型 new Handle(H_INVOKEVIRTUAL, &quot;Test&quot;, &quot;hello&quot;, &quot;()Ljava/lang/String;&quot;, false), // 方法引用的目标 Type.getType(&quot;()Ljava/lang/String;&quot;) // lambda实现方法的类型（生成内部类实现方法的类型） ); mv.visitMethodInsn(INVOKESTATIC, &quot;Test&quot;, &quot;test&quot;, &quot;(LStringSupplier;)V&quot;, false); // 调用test mv.visitInsn(RETURN); mv.visitMaxs(2, 1); // 最大操作栈[Test,Test]，局部变量表[[Ljava/lang/String;] 除了这两种方式外，我们还能使用超类的实例方法，现在假设Test继承于SuperTest，有一个superTest方法，这时javac不会直接引用超类方法，而是生成lambda实现方法在内部调用invokespecial。下面是使用例： test(super::superTest); javac生成的lambda实现方法是这样的： private /* synthetic */ String lambda$main$0() &#123; return super.superTest(); &#125; 接下来的代码省略（因为和上面一样）。 最后，还有一种对象调用：lambda内部传入了一个对象，我们可以通过这个对象进行调用。这个调用方式和静态调用差不多，只不过Handle的标签是H_INVOKEVIRTUAL，这个也不举例了。 构造函数调用方法引用允许传递构造函数，下面使用了String的无参构造函数传入test内部： test(String::new); 这时，传入的方法句柄是构造函数，对应了Handle中的H_NEWINVOKESPECIAL： mv.visitInvokeDynamicInsn(&quot;getString&quot;, // 实现的方法名称 &quot;()LStringSupplier;&quot;, // 要求返回CallSite的类型 new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/LambdaMetafactory&quot;, &quot;metafactory&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM的句柄 Type.getType(&quot;()Ljava/lang/String;&quot;), // 接口方法的类型 new Handle(H_NEWINVOKESPECIAL, &quot;String&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false), // 方法引用的目标 Type.getType(&quot;()Ljava/lang/String;&quot;) // lambda实现方法的类型（生成内部类实现方法的类型） ); mv.visitMethodInsn(INVOKESTATIC, &quot;Test&quot;, &quot;test&quot;, &quot;(LStringSupplier;)V&quot;, false); // 调用test mv.visitInsn(RETURN); mv.visitMaxs(1, 1); // 最大操作栈[LStringSupplier;]，局部变量表[[Ljava/lang/String;] 数组构造调用除了普通的构造函数，数组也可以通过方法引用创建。它只需要一个int作为参数，因此它实现的方法必须只有一个int形参： public static void test(ArrayIntSupplier lambda) &#123; // ... &#125; @FunctionalInterface public interface ArrayIntSupplier &#123; Object[] getString(int count); &#125; // ... test(Object[]::new); 这种方法引用也不是直接指向构造函数的，还是javac生成lambda实现方法并引用的： private static /* synthetic */ Object[] lambda$main$0(int cnt) &#123; return new Object[cnt]; &#125; 到此，所有方法引用的写入方式就都介绍完了。 字符串连接在学习Java的时候，我们就知道Java的String允许用+进行连接。但是，Java没有符号重载，那么字符串是怎么打破这个限制的呢？答案就是javac编译时做了一些“操作”。 接下来，我们使用这个例子： &quot;hello world at &quot; + System.currentTimeMillis() 在Java 8，字符串的连接被自动识别为StringBuilder的链式调用，那么上面的这句话在javac编译之后就变成了这样： new StringBuilder().append(&quot;hello world at &quot;).append(System.currentTimeMillis()).toString() 字节码写入如下： mv.visitTypeInsn(NEW, &quot;java/lang/StringBuilder&quot;); mv.visitInsn(DUP); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/StringBuilder&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); // 构造函数 mv.visitLdcInsn(&quot;hello world at &quot;); // 字符串常量 mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false); // append mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/System&quot;, &quot;currentTimeMillis&quot;, &quot;()J&quot;, false); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(J)Ljava/lang/StringBuilder;&quot;, false); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, false); 但是这种方式有两个缺点：一是会生成大量的字节码片段，使类文件膨胀；二是这种调用每次都会生成StringBuilder对象，性能会损失一部分。 所以，从Java 9开始，字符串连接使用inDy字节码动态调用。它使用的引导方法位于StringConcatFactory。 public static CallSite makeConcat(MethodHandles.Lookup lookup, String name, MethodType concatType) throws StringConcatException public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup, String name, MethodType concatType, String recipe, Object... constants) throws StringConcatException makeConcat是makeConcatWithConstants的简化版本，如果没有常量，就用第一个方法，但是javac编译时通常使用第二个方法，所以我们对它进行讲解。 首先说说方法参数的意义： lookup，由JVM提供的查找对象 name，名称，和最后的连接效果没有任何关系，只要不是null都能传入。程序写入常用makeConcatWithConstants concatType，生成CallSite的签名，返回值需要是String，参数列表要和字符串中的变量的数量、类型和位置保持一致 recipe，用于连接字符串的模板，只有两种字符：\\u0001代表了这里应该写入变量，\\u0002代表这里应该写入常量。\\u0001的数量、位置需要和变量保持一致；\\u0002的数量、位置要与常量保持一致 constants，字符串中的常量部分，数量和\\u0002一致，可以不是String。 它的原理比lambda要简单——它是动态生成了一个MethodHandle存储到CallSite中，因此在执行一次BSM之后它就成为了常量。 现在我们用它写入字节码： mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/System&quot;, &quot;currentTimeMillis&quot;, &quot;()J&quot;, false); // 先获得字符串中的变量 mv.visitInvokeDynamicInsn(&quot;makeConcatWithConstants&quot;, // name随意，只要求不是null &quot;(J)Ljava/lang/String;&quot;, // 变量只有一个long，要求返回String new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/StringConcatFactory&quot;, &quot;makeConcatWithConstants&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM句柄，注意不定长参数需要写成数组 &quot;hello world at \\u0001&quot; // 模板 ); 但是你可能有一个疑问：如果我字符串里面本身有\\u0001或者\\u0002不就出错了吗？JVM考虑了这个情况，它的解决方案是——提取这一段字符串为常量放到后面。例如下面这个字符串： &quot;\\u0001 hello&quot; + System.currentTimeMillis() 它的写入是： mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/System&quot;, &quot;currentTimeMillis&quot;, &quot;()J&quot;, false); // 先获得字符串中的变量 mv.visitInvokeDynamicInsn(&quot;makeConcatWithConstants&quot;, // name随意，只要求不是null &quot;(J)Ljava/lang/String;&quot;, // 变量只有一个long，要求返回String new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/StringConcatFactory&quot;, &quot;makeConcatWithConstants&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM句柄，注意不定长参数需要写成数组 &quot;\\u0002\\u0001&quot;, // 模板，常量+变量 &quot;\\u0001 hello&quot; // 常量的值 ); 模式匹配在Java 17，模式匹配进行了预览。下面就是它的使用例： Object o ... switch (o) &#123; case String s: System.out.println(s.substring(1)); break; case Number n: System.out.println(n.longValue()); break; default: System.out.println(&quot;Others&quot;); &#125; 模式匹配之间必须使用break，否则会被提示为非法。 使用增强型switch可以写成下面形式： Object o ... switch (o) &#123; case String s -&gt; System.out.println(s.substring(1)); case Number n -&gt; System.out.println(n.longValue()); default -&gt; System.out.println(&quot;Others&quot;); &#125; 它的写入和其他switch不同，它使用了inDy用于获得序号，再用这个序号进行lookupswitch。 它使用的引导方法位于java.lang.runtime.SwitchBootstraps： public static CallSite typeSwitch(MethodHandles.Lookup lookup, String invocationName, MethodType invocationType, Object... labels) 它的参数意义如下： lookup，由JVM提供的查找对象 invocationName，名称，和最后的效果没有任何关系，只要不是null都能传入。程序写入常用typeSwitch invocationType，要求第一个参数非基本类型、第二个参数是int、返回值是int的方法类型，也就是说它强制要求传入一个对象和一个int。对象用于检查模式，int用于确定lookupswitch的起始位置（通常是0）。返回值是从第二个参数开始的连续数列中的一个值。 labels，模式匹配目标。可以是Class、Integer或String对象，但是实际上编译时只使用了Class对象。它规定了返回的CallSite的内容：如果输入的对象是这个Class的对象，返回对应的位置。如果输入的对象是null，返回-1。如果输入的对象不存在匹配项，返回labels数组的长度。 通过这个引导方法，上面的代码可以变为： Object o ... Objects.requireNonNull(o); // 先检查对象是否为null Object tmp = o; // 复制一份，javac是这么做的 int startIndex = 0; // 传入的起始lookup偏移 // --- 这里有一次栈帧信息写入 --- labelStart // 这里加载了tmp和startIndex switch(#invokedynamic) &#123; // inDy的调用部分省略 case 0: /* labelString */ String s = (String) o; System.out.println(s.substring(1)); break; case 1: /* labelNumber */ Number n = (Number) n; System.out.println(n.longValue()); break; default: /* labelDefault */ System.out.println(&quot;Others&quot;); &#125; /* labelEnd */ 使用字节码写入： mv.visitVarInsn(ALOAD, 0); // o mv.visitInsn(DUP); // 复制一份，同样，不复制也行，这是javac的迷惑操作 mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/Objects&quot;, &quot;requireNonNull&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;, false); // 检查null mv.visitInsn(POP); // 弹出栈顶 mv.visitVarInsn(ASTORE, 1); // 转存到临时变量tmp mv.visitInsn(ICONST_0); // 常量0 mv.visitVarInsn(ISTORE, 2); // 给局部变量startIndex赋值 Label labelStart = new Label(); // 用于标记switch块的开始（这样tmp和startIndex不能在结束时访问） mv.visitLabel(labelStart); mv.visitFrame(F_APPEND, 2, new Object[]&#123; &quot;java/lang/Object&quot;, INTEGER &#125;, 0, null); // 写入栈帧信息 mv.visitVarInsn(ALOAD, 1); // 加载对象 mv.visitVarInsn(ILOAD, 2); // 加载偏移 mv.visitInvokeDynamicInsn(&quot;typeSwitch&quot;, // 无关紧要的名字，只要不是null就行 &quot;(Ljava/lang/Object;I)I&quot;, // CallSite的方法签名 new Handle(H_INVOKESTATIC, &quot;java/lang/runtime/SwitchBootstraps&quot;, &quot;typeSwitch&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;&quot;, false), // BSM句柄 Type.getType(&quot;Ljava/lang/String;&quot;), // 第一个模式 Type.getType(&quot;Ljava/lang/Number;&quot;) // 第二个模式 ); Label labelString = new Label(), labelNumber = new Label(), labelDefault = new Label(); mv.visitLookupSwitchInsn(labelDefault, new int[]&#123; 0, 1 &#125;, new Label[]&#123; labelString, labelNumber &#125;); // 返回值用于lookupSwitch mv.visitLabel(labelString); mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitVarInsn(ALOAD, 1); // tmp mv.visitTypeInsn(CHECKCAST, &quot;java/lang/String&quot;); // 强制类型转换 mv.visitVarInsn(ASTORE, 3); // 存储到s mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitVarInsn(ALOAD, 3); mv.visitInsn(ICONST_1); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); Label labelEnd = new Label(); mv.visitJumpInsn(GOTO, labelEnd); // break mv.visitLabel(labelNumber); mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitVarInsn(ALOAD, 1); // tmp mv.visitTypeInsn(CHECKCAST, &quot;java/lang/Number&quot;); // 强制类型转换 mv.visitVarInsn(ASTORE, 4); // 存储到n mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitVarInsn(ALOAD, 4); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/Number&quot;, &quot;longValue&quot;, &quot;()J&quot;, false); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(J)V&quot;, false); mv.visitJumpInsn(GOTO, labelEnd); // break mv.visitLabel(labelDefault); mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;Others&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(labelEnd); mv.visitFrame(F_CHOP, 2, null, 0, null); // 清除局部变量 mv.visitInsn(RETURN); 通过SwitchBootstrap可以看出switch以后可能将尽可能使用invokedynamic：typeSwitch支持String输入，也许之后会将String的switch语句修改为这种实现；现在的类内部还有一个enumSwitch但是javac并不能编译出这个引导方法。在下个版本也许会进一步增加细节。 自定义引导方法注意：自定义一个引导方法可能导致你的程序不稳定、出现奇奇怪怪的问题、编译变得极度麻烦。如果不是特殊用途（比如说真正的让一个反编译器完全失效）不要用这个！ 根据上面引导方法的定义和inDy的实现，我们自己也能创造出一个引导方法——只需要满足要求就好。下面就是一个简单的引导方法： public static CallSite bootstrap(MethodHandles.Lookup lookup, String name, MethodType type) &#123; if (!type.returnType().equals(String.class) || type.parameterCount() != 0) throw new RuntimeException(&quot;Unknown&quot;); // 我们限定只能输入这种方法类型 return new ConstantCallSite(MethodHandles.constant(String.class, &quot;hello&quot;)); // 方法句柄：返回常量hello &#125; 接着，我们在我们的方法里面用字节码指向它： mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); // System.out mv.visitInvokeDynamicInsn(&quot;testBootstrap&quot;, // 名字，我们定义的引导方法没有使用它 &quot;()Ljava/lang/String;&quot;, // 方法类型，我们强制规定了使用返回值为String的无参方法 new Handle(H_INVOKESTATIC, &quot;Test&quot;, &quot;bootstrap&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;, false) // 引导方法的句柄 ); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // println mv.visitInsn(RETURN); mv.visitMaxs(2, 0); // 最大操作栈是[java/io/PrintStream,java/lang/String] 没有局部变量 接下来就是执行，输出结果是： hello 这样，我们就成功让字节码指向我们自定义的引导方法。 全部的代码：https://paste.ubuntu.com/p/d82FNcP6jS/ 动态常量（Constant Dynamic）之前在BSM那里简单提到了动态计算常量，这是JEP 309（Java 11）引入的，在这里我们再进一步深入讲解。 首先，它的BSM定义和动态调用点的BSM定义方式不同，详情可以看上面。在写入ASM时，它使用的是visitLdcInsn，和普通常量一样。 创建一个动态常量使用ConstantDynamic，它的构造函数如下： public ConstantDynamic( final String name, final String descriptor, final Handle bootstrapMethod, final Object... bootstrapMethodArguments) 可以看到它和visitInvokeDynamicInsn差不多，唯一的区别是：descriptor是类描述符而不是方法描述符。因此，所有动态常量的BSM都不允许传入变量。 有关于动态常量的BSM都存储到了一个类中：java.lang.invoke.ConstantBootstraps。 // null的常量，只与type有关 public static Object nullConstant(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type) // 获得类描述符为name的Class对象，type必须是Class.class public static Class&lt;?&gt; primitiveClass(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type) // 获得名称为name的枚举对象 public static &lt;E extends Enum&lt;E&gt;&gt; E enumConstant(MethodHandles.Lookup lookup, String name, Class&lt;E&gt; type) // 获得位于declaringClass内部的静态终态字段name public static Object getStaticFinal(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type, Class&lt;?&gt; declaringClass) // 上面的简化版本，令declaringClass与type相同 public static Object getStaticFinal(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type) // 获得handle使用静态参量args的结果 public static Object invoke(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; type, MethodHandle handle, Object... args) // 获得字段的VarHandle public static VarHandle fieldVarHandle(MethodHandles.Lookup lookup, String name, Class&lt;VarHandle&gt; type, Class&lt;?&gt; declaringClass, Class&lt;?&gt; fieldType) // 获得静态字段的VarHandle public static VarHandle staticFieldVarHandle(MethodHandles.Lookup lookup, String name, Class&lt;VarHandle&gt; type, Class&lt;?&gt; declaringClass, Class&lt;?&gt; fieldType) // 获得数组的VarHandle public static VarHandle arrayVarHandle(MethodHandles.Lookup lookup, String name, Class&lt;VarHandle&gt; type, Class&lt;?&gt; arrayClass) // 将value显式转换到dstType public static Object explicitCast(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; dstType, Object value) throws ClassCastException 使用动态计算常量可以使用其他动态计算常量作为静态参数，这时JVM会倒序一个个计算创建常量。 下面是个例子： #ldc 动态常量 System.out .println(&quot;hello&quot;); 字节码写入如下： mv.visitLdcInsn(new ConstantDynamic( &quot;out&quot;, // 字段的名称 &quot;Ljava/io/PrintStream;&quot;, // 字段类型 new Handle(H_INVOKESTATIC, &quot;java/lang/invoke/ConstantBootstraps&quot;, &quot;getStaticFinal&quot;, &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/Object;&quot;, false), // BSM句柄 Type.getType(&quot;Ljava/lang/System;&quot;) // 字段声明位置 )); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); 每个ConstantDynamic都可以复用——你可以使用一个对象传入到不同的LDC里面去。这些对象最终和普通常量一样存储到常量池内部。 这篇专栏就这些了，只讲了一个字节码，但是内容很多。加上以前的一共191个。 有错误可以在评论区指出。","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：MethodVisitor与Opcode（四）其他流程结构","slug":"Java ASM详解：MethodVisitor与Opcode（四）其他流程结构","date":"2021-11-20T18:02:53.000Z","updated":"2021-11-20T14:05:07.734Z","comments":true,"path":"2021/11/21/Java ASM详解：MethodVisitor与Opcode（四）其他流程结构/","link":"","permalink":"http://nickid2018.github.io/2021/11/21/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/","excerpt":"","text":"上一篇文章中，我们已经了解了基本的流程结构。这篇专栏将详细描述Java中其他的流程结构。 异常捕获结构在平常我们使用流程结构时，除了选择结构和循环结构外，使用最多的大概就是异常捕获结构了。 异常捕获结构的写入都使用了visitTryCatchBlock方法（内部的实现是JSR和RET字节码），它需要早于其他所有字节码写入，也就是在方法写入一开始就要定义。它的定义如下： public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) 其中，start是try块开始的标签；end是try结束后的标签（try的范围不包括这个标签）；handler是try块内抛出Throwable对象后跳转到的标签，即相应的catch块标签；type是catch接受的异常类型，要求传入异常类的全限定名（例外是finally块）。 try-catch在讲述完整的try-catch-finally块之前，我们先来看看普通的try-catch块怎么写入。 普通的try-catch块类似这样： try &#123; // try块 &#125; catch (FirstException e) &#123; // 处理FirstException &#125; catch (SecondException e) &#123; // 处理SecondException &#125; 对于一个指定的try块，可能有多个catch块和它对应。每一个catch块都需要用一次visitTryCatchBlock声明。对于catch块对应的跳转标签目标，它的栈帧信息应该和try块前的局部变量相同，但是操作栈上有一个对应的异常对象。下面给出了使用try-catch块的例子： public static int parseIntSafely(String s) &#123; try &#123; /* labelTryStart */ return Integer.parseInt(s); &#125; catch (NumberFormatException e) &#123; /* labelCatch */ return 0; &#125; &#125; 使用asm写入如下: javac编译时生成的字节码和这里不太一样——它会把已经在操作栈上的Throwable对象先存入局部变量，这是为了输出文件的行号。而这里我们选择直接忽视栈上的Throwable对象。 // 初始栈帧信息 [java/lang/String] Label labelTryStart = new Label(); Label labelCatch = new Label(); mv.visitTryCatchBlock(labelTryStart, labelCatch, labelCatch, &quot;java/lang/NumberFormatException&quot;); // try的范围是[labelTryStart, labelCatch) mv.visitLabel(labelTryStart); // try块内部 mv.visitVarInsn(ALOAD, 0); // 加载s mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Integer&quot;, &quot;parseInt&quot;, &quot;(Ljava/lang/String;)I&quot;, false); // Integer::parseInt mv.visitInsn(IRETURN); // try结束 mv.visitLabel(labelCatch); // catch块开始 // 栈帧信息 [java/lang/String] [java/lang/NumberFormatException] mv.visitFrame(F_SAME1, 0, null, 1, new Object[] &#123; &quot;java/lang/NumberFormatException&quot; &#125;); mv.visitInsn(ICONST_0); mv.visitInsn(IRETURN); mv.visitMaxs(2, 1); // 最大栈帧为2 （catch块内），局部变量1 multi-catch除了普通的catch外，还有一种multi-catch结构： try &#123; // try块 &#125; catch (FirstException | SecondException e) &#123; // catch块 &#125; multi-catch可以看做几个catch块被共用，这时栈帧信息上的操作栈压入的是multi-catch中所有异常类的共有超类。例如一个multi-catch块能捕获NumberFormatException和NullPointerException，它的字节码写入如下： Label labelTryStart = new Label(); Label labelCatch = new Label(); mv.visitTryCatchBlock(labelTryStart, labelCatch, labelCatch, &quot;java/lang/NumberFormatException&quot;); // try的范围是[labelTryStart, labelCatch) mv.visitTryCatchBlock(labelTryStart, labelCatch, labelCatch, &quot;java/lang/NullPointerException&quot;); // 代码和try块，略 mv.visitLabel(labelCatch); mv.visitFrame(F_XXXX, X, XXX, 1, new Object[] &#123; &quot;java/lang/RuntimeException&quot; &#125;); // 栈帧其他信息忽略，操作栈上是共有超类RuntimeException // catch块及之后的代码... try-finally说完了try-catch，我们再看看try-finally语句。 try &#123; // try块内容 &#125; finally &#123; // finally块内容 &#125; finally其实类似catch，它们都会在操作栈上压入Throwable对象（如果产生了异常），但是它是无跳转条件（null）的，无论是否出现异常都会执行一次finally，即代码流必须经过finally。如果try块内包含return，也必须先执行finally的内容之后再执行return。如果finally中含有return，则try内的所有return将被忽略，通常IDE会对这种情况给出警告。 在finally执行之后，如果是没有发生异常进入finally，则正常向下运行；如果是因为异常进入了finally，那么在finally执行之后必须抛出异常————这就意味着你必须把finally的字节码重复两遍，一次没有异常进入finally，一次发生异常进入finally。 下面是一个例子： public static int parseIntAndHello(String s) &#123; try &#123; /* labelTry */ return Integer.parseInt(s); /* labelReturn */ &#125; finally &#123; /* labelFinally */ System.out.println(&quot;hello&quot;); &#125; &#125; asm写入： javac编译还是不是这样，但是运行结果是一样的。javac会让一行语句的执行前后操作栈是空，所以在labelReturn前会进行ISTORE，在IRETURN前ILOAD Label labelTry = new Label(); Label labelReturn = new Label(); Label labelFinally = new Label(); mv.visitTryCatchBlock(labelTry, labelReturn, labelFinally, null); // try位于[labelTry, labelReturn)，发生任何异常都会跳转finally mv.visitLabel(labelTry); // try开始 mv.visitVarInsn(ALOAD, 0); // s mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Integer&quot;, &quot;parseInt&quot;, &quot;(Ljava/lang/String;)I&quot;, false); // Integer::parseInt // try结束，无异常进入finally mv.visitLabel(labelReturn); mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // System.out.println mv.visitInsn(IRETURN); // 正常进入finally结束 mv.visitLabel(labelFinally); // 发生异常进入finally mv.visitFrame(F_SAME1, 0, null, 1, new Object[] &#123; &quot;java/lang/Throwable&quot; &#125;); // finally接受Throwable对象 mv.visitVarInsn(ASTORE, 1); // 保存到槽位1用于之后抛出 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // 重复finally内容 mv.visitVarInsn(ALOAD, 1); // 取出Throwable对象 mv.visitInsn(ATHROW); // 抛出 mv.visitMaxs(3, 2); try-catch-finally接下来，我们把try-catch和try-finally整合到一起。 finally块的意义是无论发生什么异常都要保证执行，所以catch块的异常也会被finally接受。也就是说，一个完整的try-catch-finally语句需要$1+2catch$次visitTryCatchBlock，并且需要重复finally块字节码$1+catch$次。（其中$catch$是catch块的数量） 下面是个整合的例子： public static int parseIntSafelyHello(String s) &#123; try &#123; /* ltry */ return Integer.parseInt(s); /* lreturn */ &#125; catch (NumberFormatException e) &#123; /* lcatch */ return -1; /* lcatchRet */ &#125; finally &#123; /* lfinally */ System.out.println(&quot;hello&quot;); &#125; &#125; asm写入： Label ltry = new Label(), lreturn = new Label(), lcatch = new Label(), lcatchRet = new Label(), lfinally = new Label(); mv.visitTryCatchBlock(ltry, lreturn, lcatch, &quot;java/lang/NumberFormatException&quot;); mv.visitTryCatchBlock(ltry, lreturn, lfinally, null); mv.visitTryCatchBlock(lcatch, lcatchRet, lfinally, null); mv.visitLabel(ltry); // try块开始 mv.visitVarInsn(ALOAD, 0); // s mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Integer&quot;, &quot;parseInt&quot;, &quot;(Ljava/lang/String;)I&quot;, false); // Integer::parseInt // try结束，try无异常进入finally mv.visitLabel(lreturn); mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // System.out.println mv.visitInsn(IRETURN); // try无异常finally结束 mv.visitLabel(lcatch); // catch块开始 mv.visitFrame(F_SAME1, 0, null, 1, new Object[] &#123; &quot;java/lang/NumberFormatException&quot; &#125;); // 栈帧信息：压入异常对象 mv.visitInsn(POP); // 我们不需要这个对象,直接弹栈（javac会进行ASTORE，无论是否使用，因为要记录名称） mv.visitLabel(lcatchRet); // catch无异常进入finally mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // 重复一遍finally... mv.visitInsn(ICONST_M1); mv.visitInsn(IRETURN); // 返回-1 mv.visitLabel(lfinally); // 发生异常跳转finally mv.visitFrame(F_SAME1, 0, null, 1, new Object[] &#123; &quot;java/lang/Throwable&quot; &#125;); mv.visitVarInsn(ASTORE, 1); // 保存到槽位1 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // 再重复一遍finally... mv.visitVarInsn(ALOAD, 1); mv.visitInsn(ATHROW); // 抛出 mv.visitMaxs(3, 2); try-with-resources除了try-catch、multi-catch、try-finally、try-catch-finally结构外，还有一种结构：try-with-resources。这种结构要求一个AutoClosable的对象在try后的语句中初始化： try (AutoClosable res1 = getObject1(), res2 = getObject2(), ...) &#123; // try内的语句 &#125; catch (Exception e) &#123; // catch块 &#125; finally &#123; // finally... &#125; 它可以转化为普通的try-catch-finally块，类似于这样： javac编译之后内部不是这样，这里是将执行流程强制转换为可读Java源码 AutoClosable res = null; try &#123; res = getObject1(); // try块内容... &#125; catch (Exception e) &#123; // catch块内容... // 这里res也会被close，但是因为Java代码没法表现就没有写 &#125; catch (Throwable t) &#123; try &#123; res.close(); // 这里其实res已经被创建了，但是因为Java代码没法表现就放在这里了 &#125; catch (Throwable t2) &#123; t.addSupressed(t2); &#125; throw t; &#125; finally &#123; // finally... &#125; 使用try-with-resources结构写入字节码的时候，只要记住每一个出口都会进行一次带try-catch的close就可以。由于这种结构很复杂且代码量巨大，就不举例子了。 switch多分支结构在一些情况下，if...else if...else结构非常的长，这时我们可以用switch替代。 可直接表示为int的switch多分支语句最简单的switch是键为整形数字常量（可以用int表示的）的，类似于这样： int i = ...; switch (i) &#123; case 0: case 1: ... ... default: ... &#125; 在写入switch中，我们有两个方法可以选择： public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label... labels) public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) 它们的相同之处是：它们都需要操作栈顶上有一个int类型的值。它们的不同之处在于它们对于键值的存储方式和使用的字节码： visitTableSwitchInsn写入的键值是一个连续的数组——一个$[min,max]$的一个整形数字数组。如果switch中没有中间的某些键值，那么这些键值会和dflt一致，即default的标签（如果没有default块，则dflt应该指向switch结束后的第一条语句）。它使用TABLESWITCH字节码。 visitLookupSwitchInsn要求传入一个switch键值的数组，数组内的数字要从小到大排序。labels数组的长度要与keys一致。dflt也是指向default或者switch结束后的第一条语句的标签。它使用LOOKUPSWITCH字节码。 回到最简单的switch上来。我们需要按照键值的特性选择我们的写入方式： 如果switch内的键值差异小，并且键值组成一个连续整数数组的空缺不超过6个，则使用visitTableSwitchInsn 如果switch内的键值差异大，则使用visitLookupSwitchInsn 先看个简单的小例子： public static void test(int i) &#123; switch (i) &#123; case 0: case 1: /* label1 */ System.out.println(&quot;1&quot;); case 2: /* label2 */ System.out.println(&quot;2&quot;); break; case 3: /* label3 */ System.out.println(&quot;3&quot;); &#125; /* labelEnd */ &#125; 可以看到，键值$\\{0,1,2,3\\}$组成了一个连续的整数数组，所以这里我们应该使用visitTableSwitchInsn。 mv.visitVarInsn(ILOAD, 0); // i Label label1 = new Label(), label2 = new Label(), label3 = new Label(), labelEnd = new Label(); mv.visitTableSwitchInsn(0, 3, labelEnd, label1, label1, label2, label3); // 解释：没有default块所以指向了switch结束的下一条语句，0和1用了一个跳转位置 mv.visitLabel(label1); // 0和1处理 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;1&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(label2); // 2的处理，注意这里0和1处理之后也会经过这个地方 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;2&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitJumpInsn(GOTO, labelEnd); // break的作用，跳出switch mv.visitLabel(label3); // 3的处理，这里不会被0、1、2访问了 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;3&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // switch结束 mv.visitLabel(labelEnd); mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitInsn(RETURN); mv.visitMaxs(2, 1); 这是对于switch最简单的一种清况之一。因为byte、short、char在JVM内解释为int，所以这些步骤基本相同。 使用枚举的switch多分支语句switch语句还可以用于枚举类型，下面我们定义了一个枚举，并使用了它： enum TestEnum &#123; FIRST, SECOND, THIRD, FOURTH &#125; public static void test(TestEnum i) &#123; switch (i) &#123; case FIRST: case SECOND: System.out.println(&quot;1&quot;); case THIRD: System.out.println(&quot;2&quot;); break; case FOURTH: System.out.println(&quot;3&quot;); default: System.out.println(&quot;4&quot;); &#125; &#125; 枚举类型不能直接作为两种switch字节码的参数，它必须先变为一个int才能传入字节码。为此，javac在编译的时候会自动创建一个内部类，用于保存这个类里面出现的所有使用枚举对象switch的一个映射表。对于我们定义的TestEnum，它对应的映射类应该像这样（假设我们方法定义的类是Test）： // 注意：这个类和字段都要有ACC_SYNTHETIC访问标志 class Test$1 &#123; static final int[] $SwitchMap$TestEnum; static &#123; $SwitchMap$TestEnum = new int[TestEnum.values().length]; try &#123; $SwitchMap$TestEnum[TestEnum.FIRST.ordinal()] = 1; &#125; catch (NoSuchFieldError e) &#123; &#125; try &#123; $SwitchMap$TestEnum[TestEnum.SECOND.ordinal()] = 2; &#125; catch (NoSuchFieldError e) &#123; &#125; try &#123; $SwitchMap$TestEnum[TestEnum.THIRD.ordinal()] = 3; &#125; catch (NoSuchFieldError e) &#123; &#125; try &#123; $SwitchMap$TestEnum[TestEnum.FOURTH.ordinal()] = 4; &#125; catch (NoSuchFieldError e) &#123; &#125; &#125; &#125; 这个内部类中含有所有在这个类中出现的枚举对象，每个枚举类都会创建一个字段，命名为$SwitchMap$+.替换成$的类型名，它们的长度是对应枚举类枚举字段的数量，按照ordinal大小排序将1-n写入数组（n是本类使用了多少个这个类的枚举字段）。 接下来，switch的传入方式也发生了变化： TestEnum i ... switch (Test$1.$SwitchMap$TestEnum[i.ordinal()]) &#123; ... &#125; 那么之前给出的例子我们可以用asm写入为： mv.visitFieldInsn(GETSTATIC, &quot;Test$1&quot;, &quot;$SwitchMap$TestEnum&quot;, &quot;[I&quot;); // 获取常量字段 mv.visitVarInsn(ALOAD, 0); // i mv.visitMethodInsn(INVOKEVIRTUAL, &quot;TestEnum&quot;, &quot;ordinal&quot;, &quot;()I&quot;, false); // Enum::ordinal mv.visitInsn(IALOAD); // 取出常量 Label label1 = new Label(), label2 = new Label(), label3 = new Label(), labelDefault = new Label(), labelEnd = new Label(); mv.visitTableSwitchInsn(1, 4, labelDefault, label1, label1, label2, label3); // default标签-labelDefault, 1/2用了同一个跳转目标 mv.visitLabel(label1); // 1/2 FIRST/SECOND mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;1&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(label2); // 3 THIRD mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;2&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitJumpInsn(GOTO, labelEnd); // break mv.visitLabel(label3); // 4 FOURTH mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;3&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(labelDefault); // default mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;4&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(labelEnd); // switch结束 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitInsn(RETURN); mv.visitMaxs(2, 2); 如果是我们自己写入asm，推荐不要用这种方式写入——毕竟太麻烦了。最好的方案是使用Enum::ordinal获取序号对序号进行switch，而不是存一个新的表。 使用字符串的switch多分支语句除了枚举和基本int之外，switch还允许字符串传入。下面就是一个例子： public static void test(String s) &#123; switch (s) &#123; case &quot;HELLO&quot;: System.out.println(&quot;hello&quot;); break; case &quot;BYEBYE&quot;: System.out.println(&quot;byebye&quot;); break; default: System.out.println(&quot;ss&quot;); &#125; &#125; 很明显，String不能直接转换成为int。在String中，hashCode这个方法可以让我们将字符串映射到int上，这样就能把它作为键值。但是还有一个问题需要解决：String和int不能一一对应——不同的字符串可能有相同的hashCode，例如ddnqavbj和166lr735ka3q6的哈希码值都为0。因此，javac在编译时将这个switch块拆开为两个，并使用一个临时量保存字符串的映射。这样，上面的例子就变成了下面这样： public static void test(String s) &#123; &#123; String tempStr = s; int temp = -1; switch (tempStr.hashCode()) &#123; case 68624562: // &quot;HELLO&quot;的哈希码 /* hashHello */ if (tempStr.equals(&quot;HELLO&quot;)) temp = 0; break; case 1973839168: // &quot;BYEBYE&quot;的哈希码值 /* hashBye */ if (tempStr.equals(&quot;BYEBYE&quot;)) temp = 1; break; &#125; /* switch2 */ switch (temp) &#123; case 0: /* case0 */ System.out.println(&quot;hello&quot;); break; case 1: /* case1 */ System.out.println(&quot;byebye&quot;); break; default: /* caseDefault */ System.out.println(&quot;ss&quot;); &#125; &#125; /* end */ &#125; 按照上面的Java代码，我们能用asm将它写入： // 初始帧 [java/lang/String] mv.visitVarInsn(ALOAD, 0); // s mv.visitVarInsn(ASTORE, 1); // 转存到tempStr mv.visitInsn(ICONST_M1); // -1 mv.visitVarInsn(ISTORE, 2); // 存入temp mv.visitVarInsn(ALOAD, 1); // tempStr mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;hashCode&quot;, &quot;()I&quot;, false); // tempStr.hashCode() Label hashHello = new Label(), hashBye = new Label(), switch2 = new Label(); mv.visitLookupSwitchInsn(switch2, new int[]&#123; 68624562, 1973839168 &#125;, new Label[]&#123; hashHello, hashBye &#125;); mv.visitLabel(hashHello); // HELLO的哈希码 // 栈帧 [java/lang/String java/lang/String I] mv.visitFrame(F_APPEND, 2, new Object[]&#123;&quot;java/lang/String&quot;, Opcodes.INTEGER&#125;, 0, null); mv.visitVarInsn(ALOAD, 1); // tempStr mv.visitLdcInsn(&quot;HELLO&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false); // 判断 mv.visitJumpInsn(IFEQ, switch2); // 反转判断，失败直接跳转出去 mv.visitInsn(ICONST_0); // 0 mv.visitVarInsn(ISTORE, 2); // 赋值给temp mv.visitJumpInsn(GOTO, switch2); // 也跳转出去 mv.visitLabel(hashBye); // BYEBYE的哈希码 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitVarInsn(ALOAD, 1); // tempStr mv.visitLdcInsn(&quot;BYEBYE&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false); // 判断 mv.visitJumpInsn(IFEQ, switch2); // 反转判断，失败直接跳转 mv.visitInsn(ICONST_1); // 1 mv.visitVarInsn(ISTORE, 2); // 赋值给temp mv.visitLabel(switch2); // 第一个switch结束 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitVarInsn(ILOAD, 2); // 加载temp Label case0 = new Label(), case1 = new Label(), caseDefault = new Label(), end = new Label(); mv.visitLookupSwitchInsn(caseDefault, new int[]&#123; 0, 1 &#125;, new Label[]&#123; case0, case1 &#125;); // 这里可以用tableswitch，但是javac是这样编译出来的 mv.visitLabel(case0); // HELLO mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitJumpInsn(GOTO, end); // 跳转结束 mv.visitLabel(case1); // BYEBYE mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;byebye&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitJumpInsn(GOTO, end); // 跳转结束 mv.visitLabel(caseDefault); // default mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;ss&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(end); // 结束 // 栈帧信息 [java/lang/String] mv.visitFrame(F_CHOP, 2, null, 0, null); mv.visitInsn(RETURN); mv.visitMaxs(2, 3); 增强型switch最后来看看Java 14新加的增强型switch。 首先，增强型switch可以返回一个值赋给变量或者进行操作： System.out.println(switch (s) &#123; case &quot;HELLO&quot; -&gt; 3; case &quot;BYEBYE&quot; -&gt; 4; default -&gt; 5; &#125;); 这种操作的本质还是和上面的一样，下面是展开增强型switch但是不展开String转换的结果： int temp; switch (s) &#123; case &quot;HELLO&quot;: temp = 3; break; case &quot;BYEBYE&quot;: temp = 4; break; default: temp = 5; &#125; System.out.println(temp); 另一种增强型switch使用了yield关键字： System.out.println(switch (s) &#123; case &quot;HELLO&quot;: System.out.println(&quot;case0&quot;); yield 3; case &quot;BYEBYE&quot;: System.out.println(&quot;case1&quot;); yield 4; default: System.out.println(&quot;default&quot;); yield 5; &#125;); 它的原理也和上面差不多： int temp; switch (s) &#123; case &quot;HELLO&quot;: System.out.println(&quot;case0&quot;); temp = 3; break; case &quot;BYEBYE&quot;: System.out.println(&quot;case1&quot;); temp = 4; break; default: System.out.println(&quot;default&quot;); temp = 5; &#125; System.out.println(temp); 这篇文章到这里就结束了（最后不写例子主要是因为这两种结构需要的代码量太大了）。 这回一共讲了4个字节码，加上以前的一共190个。 有错误可以在评论区指出~ 下一期 Java ASM详解：MethodVisitor与Opcode（五）invokedynamic、方法引用、BSM","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：MethodVisitor与Opcode（三）标签，条件结构，循环结构，栈帧","slug":"Java ASM详解：MethodVisitor与Opcode（三）标签，条件结构，循环结构，栈帧","date":"2021-11-06T11:09:19.000Z","updated":"2021-11-06T04:37:32.781Z","comments":true,"path":"2021/11/06/Java ASM详解：MethodVisitor与Opcode（三）标签，条件结构，循环结构，栈帧/","link":"","permalink":"http://nickid2018.github.io/2021/11/06/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%B8%89%EF%BC%89%E6%A0%87%E7%AD%BE%EF%BC%8C%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%8C%E6%A0%88%E5%B8%A7/","excerpt":"","text":"在之前的文章中，我们已经知道了基础的字节码。但是，这些字节码只能构建起一个简单的结构，不能实现循环条件等高级结构。这篇文章将讨论关于程序流程结构的字节码。 标签标签（Label）是用来划明一部分字节码的标识（通常意义上标签就是一个标记点，但是为了接下来的讲述就用它代表一块字节码）。一个标签下的字节码块，应该从操作栈空开始到操作栈被清空结束——也就是说，一个标签代表的字节码块反编译之后应该是完整的一或多条语句。 在通常情况下，javac编译器会把每条单独语句都分配一个标签，这么做的目的是为了输出行号和局部变量名称。 标签也可以在我们使用Java时自己定义，下面的LABEL就是一个标签： LABEL: while(true) &#123; for(int i = 0; i &lt; 10; i++) if(Math.random() &gt; 0.1) break LABEL; &#125; 在字节码中，标签代表的字节码块是从这个标签写入开始到下一个标签写入或该方法的字节码读取完毕的一部分字节码。 在ASM库中，标签用org.objectweb.asm.Label进行表示，构造方法如下： public Label() 写入一个Label，需要用到MethodVisitor的方法，方法如下： public void visitLabel(final Label label) 正如前面所说，两个标签的写入之间的字节码可以看作这个标签代表的一块字节码块。因此，两个visitLabel之间的语句也可以被看作前一个Label代表的一部分字节码区域。 MethodVisitor mv = ... Label l1 = new Label(); mv.visitLabel(l1); // --- l1代表的字节码块开始 mv.... mv.... // --- l1代表的字节码块结束 Label l2 = new Label(); mv.visitLabel(l2); 那么标签有什么用呢？ 首先它可以保存代码的行号，这就用到了MethodVisitor::visitLineNumber这个方法了。 public void visitLineNumber(final int line, final Label start) 第一个参数代表了这条语句的行号，第二个参数就是这条语句的标签。标签必须先于行号被写入，否则就会抛出IllegalArgumentException。 其次，它可以保存局部变量的名称。局部变量有作用域，而作用域可以用两个标签指定。在这两个标签之内且在指定局部变量槽位上的变量就是我们要命名的局部变量。写入局部变量的名称使用MethodVisitor::visitLocalVariable。 public void visitLocalVariable( final String name, final String descriptor, final String signature, final Label start, final Label end, final int index) 参数的意义分别是：名称、描述符、泛型签名、开始的标签、结束的标签、局部变量槽位。在javac编译生成的类文件中，局部变量名称的写入都要在最后写入。 最后，标签的最重要意义就是它可以用于跳转字节码上。 跳转字节码用于跳转的字节码都使用了visitJumpInsn方法： public void visitJumpInsn(final int opcode, final Label label) 第一个就是字节码，第二个是跳转的目标。字节码决定了是否进行跳转，标签决定了跳转的目的地。 跳转字节码分为两种——比较跳转和无条件跳转。 无条件跳转字节码无条件跳转，也就是goto字节码： 输入：无 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(GOTO, label1); goto字节码是当程序运行到这里时，就直接跳转到对应的标签继续执行，通常都是用在循环内部的。 比较跳转字节码比较跳转是大多数条件结构和循环结构使用的字节码，它有四套字节码，分别对应了int比较、int与0比较、对象比较和对象空检测： if_icmp&lt;cond&gt;&lt;cond&gt; = eq/ne/lt/ge/gt/le 输入：两个int数据 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(IF_ICMPEQ, label1); 这六个字节码分别对应了两个int数据进行相等、不相等、小于、大于等于、大于、小于等于的比较测试。如果比较成功，就跳转到指定的标签处运行。如果比较不成功，就沿着当前的流程继续运行。 if&lt;cond&gt;&lt;cond&gt; = eq/ne/lt/ge/gt/le 输入：一个int数据 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(IFEQ, label1); 这六个字节码分别对应了一个int数据进行等于0、不等于0、小于0、大于等于0、大于0、小于等于0的比较测试。测试结果和跳转方式和上文相同。 if_acmp&lt;cond&gt;&lt;cond&gt; = eq/ne 输入：两个对象 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(IF_ACMPNE, label1); 这两个字节码分别对应两个对象相等和不相等。这个字节码比较的是对象的引用，而不是内部的值——也就是说，即使两个String对象内部存储字符串一样，也不能保证它们的检测结果为真！（例外是使用了String::intern，它会把字符串放进常量池，并返回一个固定的引用）所以判断字符串相等必须使用equals方法而不是==。 ifnull/ifnonnull输入：一个对象 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(IFNULL, label1); 这两个字节码分别测试对象是空还是非空。执行流程和之前3个一样。 可以看到，这几个字节码指针对了int和对象引用的情况，而没有考虑long、float、double的情况。于是Java加入了下面几个字节码用于比较它们，获取到值后就可以传递给各个IF字节码判断。 比较字节码lcmp输入：两个long 输出：一个int 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LCMP); 它用于比较两个long的大小：如果第一个数字比第二个小，返回-1；如果第二个数字比第一个小，返回1；如果相等，返回0。 xcmp&lt;op&gt;x=f/d, &lt;op&gt;=l/g 输入：两个浮点数 输出：一个int 方法：visitInsn 参数：无 使用范例： mv.visitInsn(FCMPG); 这套字节码和lcmp的逻辑差不多：如果第一个数小于第二个数，返回-1；如果第二个数小于第一个数，返回1；如果相等，返回0。但是，如果其中一方是NaN，&lt;op&gt;就决定了它们返回的值：l版本返回-1，而g版本返回1。 接下来，我们将用这22个字节码实现程序的复杂流程结构。 条件结构在Java中，条件结构类似于下面： if (condition1) &#123; // ... &#125; else if (condition2) &#123; // ... // N 个else if &#125; else if (conditionN) &#123; // ... &#125; else &#123; // ... &#125; 在编译期间，这种代码可以被看为： if (condition1) &#123; // ... &#125; else if (condition2) &#123; // ... &#125; else // N 个else if.. if (conditionN) &#123; // ... &#125; else &#123; // ... &#125; 也就是说，这种结构就是由一个一个的if...else结构组合形成的。一个简单的if…else结构用字节码写入后可以表示为这样的流程： if判断条件通常都使用了返回boolean的表达式（除了特殊字节码指定的比较方式外都需要这样传入），而boolean值的true是1，false是0，使用IFEQ字节码相当于被反向判断。相类似的，javac在编译时经常将字节码操作反转来保证if块先于else块写入。 返回boolean值传入if中的选择结构类似于这样： ...返回一个boolean ifeq label2 label1: if块内内容 goto label3 label2: else块内内容 label3: if块外部代码 在跳转之后，我们的操作栈和局部变量表会和跳转之前相等。同时，visitMaxs的参数变成了所有分支下最大的局部变量表大小和最大的操作栈深度。 下面举一个例子。要生成这样的Java代码： public static int max(int a, int b) &#123; if(a &gt; b) return a; else return b; &#125; 我们的字节码应该像下面这样写： // 省略ClassWriter和MethodVisitor创建和其他内容 mv.visitVarInsn(ILOAD, 0); mv.visitVarInsn(ILOAD, 1); // 加载a、b Label label1 = new Label(); // 创建标签 mv.visitJumpInsn(IF_ICMPLE, label1); // a &gt; b 的反转判断（小于等于），这样能保证if块在前 // if部分内容 mv.visitVarInsn(ILOAD, 0); mv.visitInsn(IRETURN); // return a 方法结束 mv.visitLabel(label1); // else部分内容 mv.visitVarInsn(ILOAD, 1); mv.visitInsn(IRETURN); // return b 方法结束 mv.visitMaxs(2, 2); // 两个int变量，操作栈深度最大2 条件结构可以被简化为三元运算符，三元运算符的字节码也类似于if…else。 下面是一个使用三元运算符的例子： public static int compute(int val) &#123; int endVal = val &lt; 0 ? -val : val; return endVal * 2; &#125; 字节码写入： // 省略ClassWriter和MethodVisitor创建和其他内容 Label labelElse = new Label(); // else 块的标签 mv.visitJumpInsn(IFGE, labelElse); // 反转判断val // 三元运算符中前面的表达式 mv.visitVarInsn(ILOAD, 0); mv.visitInsn(INEG); Label labelIfEnd = new Label(); // if...else之后的标签 mv.visitJumpInsn(GOTO, labelIfEnd); // 结束，跳转 mv.visitLabel(labelElse); // 三元运算符后面的表达式 mv.visitVarInsn(ILOAD, 0); mv.visitLabel(labelIfEnd); // 保存到endVal中 mv.visitVarInsn(ISTORE, 1); // 计算 endVal * 2 mv.visitVarInsn(ILOAD, 1); mv.visitInsn(ICONST_2); mv.visitInsn(IMUL); mv.visitInsn(IRETURN); mv.visitMaxs(2, 2); 循环结构循环结构都比较类似，都是流程返回到之前的代码部分。先从最简单的while语句开始： while循环while循环的流程类似与这样： 接下来用一段Java代码写一个例子： public static int test() &#123; int sum = 0; int now = 0; while(sum &lt; 1000) &#123; sum += ++now; &#125; return now; &#125; 这是用字节码的方式写入： mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 0); // 存入sum mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 1); // 存入now Label labelCondition = new Label(); mv.visitLabel(labelCondition); // 循环条件 mv.visitVarInsn(ILOAD, 0); // 加载sum mv.visitIntInsn(SIPUSH, 1000); Label labelEnd = new Label(); mv.visitJumpInsn(IF_ICMPGE, labelEnd); // 反转比较sum &lt; 1000 mv.visitVarInsn(ILOAD, 0); mv.visitIincInsn(1, 1); mv.visitVarInsn(ILOAD, 1); mv.visitInsn(IADD); mv.visitVarInsn(ISTORE, 0); mv.visitJumpInsn(GOTO, labelCondition); // 流程跳转回到条件处 mv.visitLabel(labelEnd); mv.visitVarInsn(ILOAD, 1); mv.visitInsn(IRETURN); mv.visitMaxs(2, 2); do…while循环类似于while，do...while结构也用了和它基本一致的思路，只不过是循环条件写到了后面，并且循环条件不用反转： do…while循环就不再举例子了，下面来看看for循环。 for循环for循环有两种：普通的for语句和for-each语句。普通的for循环语句在定义时包括了三条语句：一条初始化、一条条件和一条循环结束执行语句。它的流程类似于while多加了一些部分： 接下来就是一个例子，使用for循环： public static int test() &#123; int sum = 0; for(int i = 0; i &lt; 100; i++) sum += i; return sum; &#125; 在字节码里面要这样写： mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 0); // 存入sum mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 1); // int i = 0，for循环初始化语句 Label labelCondition = new Label(); mv.visitLabel(labelCondition); mv.visitVarInsn(ILOAD, 1); // i mv.visitIntInsn(BIPUSH, 100); // 100 Label labelEnd = new Label(); mv.visitJumpInsn(IF_ICMPGE, labelEnd); // i &lt; 100的反转 mv.visitVarInsn(ILOAD, 0); // sum mv.visitVarInsn(ILOAD, 1); // i mv.visitInsn(IADD); mv.visitVarInsn(ISTORE, 0); mv.visitIincInsn(1, 1); // i++， for循环结束语句 mv.visitJumpInsn(GOTO, labelCondition); // 回到条件 mv.visitLabel(labelEnd); mv.visitVarInsn(ILOAD, 0); mv.visitInsn(IRETURN); mv.visitMaxs(2, 2); 另一种for循环，即for-each循环，它的实现和for循环很不一样。 for-each需要一个Iterable的对象才能使用，它的原理就是通过iterator进行迭代。下面这两种形式是等价的： // 设 T extends Iterable&lt;E&gt; T set = ...; // for-each写法 for(E element : set) &#123; ... &#125; // 等价写法 Iterator&lt;E&gt; iterator = set.iterator(); while(iterator.hasNext()) &#123; E element = iterator.next(); ... &#125; 也就是说，for-each本质是while循环。由于没有讲泛型，所以就不细讲此处。 栈帧我相信你已经把上面的例子都跑了一遍（没跑也没事，我默认已经跑了），可是这些东西在你尝试运行它们的时候都会报错。它们报的错无一例外都是VerifyError，这是出了什么毛病？这就有关于栈帧了。 Java中执行方法时，JVM会分配给当前线程一个栈帧，栈帧和方法绑定，它的内部就是现在的局部变量表和操作栈数据（这在第三篇文章说过）。栈帧内的局部变量表大小和操作栈大小来自visitMaxs。栈帧在方法开始执行时创建，在方法返回时（包括抛出异常）销毁。 但是在类文件中，我们不能保证一个类它的数据是不是异常的——有可能它规定的栈帧局部变量表或者操作栈小于真正运行时的大小。所以Java引入了类的验证阶段，检查类内部数据。其中有一项就是检查方法栈帧——检查方法字节码是否正确排序、变量类型是不是一致等。但是这种验证很耗费时间，所以JVM验证器引入了StackMapTable进行辅助，这样就能在线性的运行下检查。但是每一行都加入栈帧映射（stack map frame）实在是太浪费空间了，所以JVM做了优化，规定每个跳转目标之后都必须有一个映射用于表示栈帧变化。 栈帧映射中并不是一个真的局部变量表和操作栈类型表，它是以一种和前面的映射比较的方式保存——比如这个映射要比前面的映射少两个元素等。第一个映射前面并没有别的映射，所以它和空的操作栈与参数列表组成的局部变量表的栈帧比较。 （可以看看https://stackoverflow.com/questions/25109942/what-is-a-stack-map-frame下面的评论） 所以引发异常的真正原因我们找到了——看来验证器没有检查到方法内部跳转指令后的栈帧映射，导致了验证失败抛出异常。 那么怎么写入栈帧映射呢？ MethodVisitor提供了一个方法，叫visitFrame。它就是用于写入当前栈帧数据变化的方法。这个方法需要在每个跳转目标的visitLabel后面去写，不是用于跳转的标签不需要visitFrame。 visitFrame的方法原型如下： public void visitFrame( final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) 它有5个参数，指明了这个映射和前面的映射的比较方式和数据。先讲后面的参数，最后再讲第一个参数。 第三个参数是一个代表局部变量变化的一个数组，长度应该为第二个参数。数组内的取值分为这几种： 如果变量是一个没有初始化的对象，那么这个值是指向这个对象NEW字节码的标签对象。 如果变量是this并且在调用父类构造函数之前被调用，这个值是UNINITIALIZED_THIS。 如果变量类型不是基本类型，值就应该是它的类的全限定名/描述符字符串。 如果是基本类型，那么取值是固定的：int用INTEGER代替，float用FLOAT代替，long用LONG代替，double用DOUBLE代替，空用NULL代替。long和double即使需要占两个槽位也不需要写两遍，byte、short、char、boolean要用INTEGER代替。 如果这个局部变量槽位上暂时是空位（注意不是空对象），用TOP代替。 第五个参数类似，是表示操作栈变化的一个数组，长度是第四个参数。 下面是重点——第一个参数的意义。它的不同取值和意义如下： F_NEW，只能在Java 6使用（或者ClassWriter被指定扩展栈帧映射），它的写入和之后的版本不一样（其实是类似F_FULL，写入和之前的栈帧信息无关）。这篇文章不会介绍Java 6的栈帧映射写入。 F_SAME，代表这里的局部变量表和之前的栈帧信息相比没有变化，numLocal和numStack为0，两个数组都为null。（即使不是null也不会写入） F_SAME1，代表这里的局部变量表和之前的栈帧信息一样，而操作栈上有一个变量。numLocal是0，numStack是1，local是null，stack是一个数组，内部只有一个元素，代表现在栈上对象的类型。 F_APPEND，代表现在的局部变量表和之前的栈帧信息一样，但是会多出1-3个新的局部变量。numLocal是新增加的局部变量的数量，local是一个长度为numLocal的数组，存储新增加的局部变量的类型。numStack是0，stack为null。 F_CHOP，代表现在的局部变量表要比之前的栈帧信息少1-3个局部变量。numLocal就是局部变量缺少的数量，numStack是0，local和stack都是null。 F_FULL，这代表现在的栈帧和之前的栈帧没有关系，相当于复写了栈帧的信息。numLocal是局部变量数量，local是局部变量类型数组，numStack是操作栈深度，stack是操作栈类型数组。当现在的栈帧比之前的栈帧多/少3个以上的局部变量，或者操作栈上有变量（除非局部变量表不变且栈深度为1可以使用F_SAME1对应），都需要用这个标志重新写入。 在编译时，编译器会尽量减少F_FULL的出现次数，保证类文件不会因为额外栈帧信息变得臃肿。在我们自己生成字节码时，也尽量不要用F_FULL。 接下来，我们来回顾我们报错的代码： public static int test() &#123; int sum = 0; for(int i = 0; i &lt; 100; i++) sum += i; return sum; &#125; 按照之前的代码，我们要在每个跳转目标上加上栈帧信息： // 初始栈帧信息 局部变量表 [] mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 0); // 存入sum mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 1); // int i = 0，for循环初始化语句 Label labelCondition = new Label(); mv.visitLabel(labelCondition); // 这个标签是跳转目标，加入visitFrame // 这里的栈帧信息 局部变量表 [I I] 操作栈 [] mv.visitFrame(F_APPEND, 2, new Object[] &#123; INTEGER, INTEGER &#125;, 0, null); mv.visitVarInsn(ILOAD, 1); // i mv.visitIntInsn(BIPUSH, 100); // 100 Label labelEnd = new Label(); mv.visitJumpInsn(IF_ICMPGE, labelEnd); // i &lt; 100的反转 mv.visitVarInsn(ILOAD, 0); // sum mv.visitVarInsn(ILOAD, 1); // i mv.visitInsn(IADD); mv.visitVarInsn(ISTORE, 0); mv.visitIincInsn(1, 1); // i++， for循环结束语句 mv.visitJumpInsn(GOTO, labelCondition); // 回到条件 mv.visitLabel(labelEnd); // 跳转目标，加入栈帧信息 // 这里的栈帧信息 局部变量表 [I] 操作栈 [] mv.visitFrame(F_CHOP, 1, null, 0, null); mv.visitVarInsn(ILOAD, 0); mv.visitInsn(IRETURN); mv.visitMaxs(2, 2); 为了方便用户操作，asm自己加了一个计算栈帧信息的标识：COMPUTE_FRAMES。在ClassWriter构造函数中使用。 ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES); 使用这个后，所有的visitFrame和visitMaxs都不需要我们自己写。ClassWriter会根据字节码推断栈帧信息等并写入，代价是增加近一倍的运行时间。 实战下面，我们将用字节码写出一个简单的阶乘程序，使用for循环计算阶乘并且用if判断是否溢出。对应的Java代码如下： public static long secureFactorial(long number) &#123; long result = 1; for (int i = 1; i &lt;= number; i++) &#123; result *= i; if (result &lt; 0) // Overflow throw new IllegalArgumentException(&quot;Overflow!&quot;); &#125; return result; &#125; 首先计划一下程序标签的位置： public static long secureFactorial(long number) &#123; long result = 1; for (int i = 1; /* labelCondition*/ i &lt;= number; i++) &#123; result *= i; if (result &lt; 0) // Overflow throw new IllegalArgumentException(&quot;Overflow!&quot;); /* labelNoError */ &#125; /* labelEnd */ return result; &#125; 下面我们用不开启COMPUTE_FRAMES的ClassWriter进行写入： // 初始帧 局部变量 [J] mv.visitInsn(LCONST_1); mv.visitVarInsn(LSTORE, 2); // 存入result mv.visitInsn(ICONST_1); mv.visitVarInsn(ISTORE, 4); // 存入i Label labelCondition = new Label(); mv.visitLabel(labelCondition); // 栈帧信息 局部变量 [J J I] 操作栈 [] mv.visitFrame(F_APPEND, 2, new Object[]&#123; LONG, INTEGER &#125;, 0, null); mv.visitVarInsn(ILOAD, 4); // i mv.visitInsn(I2L); // 拉长比较 mv.visitVarInsn(LLOAD, 0); // number mv.visitInsn(LCMP); Label labelEnd = new Label(); mv.visitJumpInsn(IFGT, labelEnd); // 反向比较i &lt;= number mv.visitVarInsn(LLOAD, 2); // result mv.visitVarInsn(ILOAD, 4); // i mv.visitInsn(I2L); // 拉长计算 mv.visitInsn(LMUL); // 相乘 mv.visitVarInsn(LSTORE, 2); // 存入result mv.visitVarInsn(LLOAD, 2); // result mv.visitInsn(LCONST_0); mv.visitInsn(LCMP); Label labelNoError = new Label(); mv.visitJumpInsn(IFGE, labelNoError); // 反向比较 result &lt; 0 // 创建异常对象抛出 mv.visitTypeInsn(NEW, &quot;java/lang/IllegalArgumentException&quot;); mv.visitInsn(DUP); mv.visitLdcInsn(&quot;Overflow!&quot;); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/IllegalArgumentException&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitInsn(ATHROW); mv.visitLabel(labelNoError); // 栈帧信息 局部变量 [J J I] 操作栈 [] mv.visitFrame(F_SAME, 0, null, 0, null); mv.visitIincInsn(4, 1); // i++ mv.visitJumpInsn(GOTO, labelCondition); // 回到判断条件 mv.visitLabel(labelEnd); // 栈帧信息 局部变量 [J J] 操作栈 [] mv.visitFrame(F_CHOP, 1, null, 0, null); mv.visitVarInsn(LLOAD, 2); // result mv.visitInsn(LRETURN); // 返回 mv.visitMaxs(4, 5); // 最大操作栈深度4（两个long比较），局部变量5个槽位 然后我们对生成的类进行测试： Class&lt;?&gt; generated = new Loader().defineClassNow(&quot;Test&quot;, cw.toByteArray()); System.out.println(generated.getMethod(&quot;secureFactorial&quot;, long.class).invoke(null, 20)); System.out.println(generated.getMethod(&quot;secureFactorial&quot;, long.class).invoke(null, 50)); 得到下面的输出： 2432902008176640000 Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:568) at io.github.nickid2018.asmtest.ASMMain.main(ASMMain.java:60) Caused by: java.lang.IllegalArgumentException: Overflow! at Test.secureFactorial(Unknown Source) ... 5 more 这就代表成功了！ 全部源代码：https://paste.ubuntu.com/p/Gyhn3wHMQ3/ 下一期：Java ASM详解：MethodVisitor与Opcode（四）其他流程结构 这篇文章一共讲了22个字节码，加上以前讲过的一共186个。 有错误可以在评论区指出","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步","slug":"Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步","date":"2021-10-05T12:22:46.000Z","updated":"2022-09-24T07:41:50.507Z","comments":true,"path":"2021/10/05/Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步/","link":"","permalink":"http://nickid2018.github.io/2021/10/05/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E5%92%8COpcode%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E6%AE%B5%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%90%8C%E6%AD%A5/","excerpt":"","text":"上次讲过了操作栈与数值运算操作，这篇专栏主要讲ASM中有关于类型、数组与方法调用的字节码。 P.S.ASM库已经更新到了9.2版本，可以试试解析Java 18的类了。 有关于类型的字节码有关于类型的字节码都是用visitTypeInsn进行写入的。这类字节码共有4个：NEW，ANEWARRAY，INSTANCEOF和CHECKCAST。ANEWARRAY在之后的数组字节码里面会仔细去讲。 new输入：无 输出：一个指定类型的对象 方法：visitTypeInsn 参数：类型 使用范例： mv.visitTypeInsn(NEW, &quot;java/lang/Object&quot;); NEW只进行创建对象，不负责调用构造函数，所以内部字段的值都为默认值。调用构造函数必须用invokespecial字节码进行调用（下文）。 在调用这个字节码时，如果指向的类没有初始化，就它的调用静态初始化函数&lt;clinit&gt;。如果在初始化中发生异常就会抛出错误。如果目标类的类格式有误，则抛出异常。如果目标类时抽象的，则抛出InstantiationError。 instanceof输入：一个对象 输出：布尔值，代表是否为指定类的对象（栈上表示为一个四字节数据） 方法：visitTypeInsn 参数：类型（对于数组是描述符） 使用范例： mv.visitTypeInsn(INSTANCEOF, &quot;java/lang/String&quot;); instanceof用于检查对象是否为这个类型的实例，如果是则返回boolean值true，即操作栈上的一个int数据1；如果不是就返回0。 对于null对象，该字节码永远返回0。 checkcast输入：一个对象 输出：类型检查后的对象 方法：visitTypeInsn 参数：类型（对于数组是描述符） 使用范例： mv.visitTypeInsn(CHECKCAST, &quot;java/io/InputStream&quot;); checkcast用于检查对象的类型，类似于instanceof。但不同的是，如果无法将对象转换为指定类型，该字节码会抛出ClassCastException。这个字节码经常见于泛型中。 加入这个字节码通常是为了指定对象是某个类型好让验证器验证，在局部变量无法得知确切类型时必须加入此字节码保证验证通过（运行时报错就是另一回事了）。 下面是这三个字节码组合的例子： 要生成的Java代码如下： public static String testTypeASM() &#123; Object object = new String(&quot;Hello&quot;); boolean bool = object instanceof String; return (String) object; &#125; 对应的生成这段代码的字节码程序如下： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 // ---- 第一行语句 ----- mv.visitTypeInsn(NEW, &quot;java/lang/String&quot;); mv.visitInsn(DUP); // 栈上复制一份对象 mv.visitLdcInsn(&quot;Hello&quot;); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/String&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // 执行构造函数 mv.visitVarInsn(ASTORE, 0); // 存在局部变量表0号位 // ---- 第二行语句 ----- mv.visitVarInsn(ALOAD, 0); // 取出局部变量object mv.visitTypeInsn(INSTANCEOF, &quot;java/lang/String&quot;); mv.visitVarInsn(ISTORE, 1); // ---- 第三行语句 ----- mv.visitVarInsn(ALOAD, 0); mv.visitTypeInsn(CHECKCAST, &quot;java/lang/String&quot;); // 注：此处可以不加这个CHECKCAST，因为局部变量表已知是String。如果局部变量表无法判断是否真的为String且没有加入这个语句，在验证时下方ARETURN字节码会报错 mv.visitInsn(ARETURN); // ---- 结束 ---- mv.visitMaxs(3, 2); mv.visitEnd(); 数组操作的字节码数组操作的字节码一共有20个，其中加载指令8个，存储指令8个，三个创建还有一个获取数组长度的字节码。 newarray输入：int，代表数组长度 输出：指定长度的数组 方法：visitIntInsn 参数：数组的类型，有8个常量值分别代表了不同的值类型 使用范例： mv.visitIntInsn(NEWARRAY, T_INT); 和newarray字节码用于创建基本类型的数组，它的参数代表了它的类型，在Opcodes类中一共有8个：T_BOOLEAN（boolean），T_CHAR（char），T_FLOAT（float），T_DOUBLE（double），T_BYTE（byte），T_SHORT（short），T_INT（int）和T_LONG（long）。 如果数组长度小于0，这个字节码会抛出NegativeArraySizeException。 anewarray输入：int，代表数组长度 输出：指定长度的数组 方法：visitTypeInsn 参数：类型 使用范例： mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;); 基本类型的数组由newarray创建，而不是基本类型的数组由anewarray创建。 和newarray一样，如果数组长度小于0，这个字节码会抛出NegativeArraySizeException。 multianewarray输入：一系列的int，代表多维数组中每一维的长度 输出：多维数组 方法：visitMultiANewArrayInsn 参数：描述符和维度 使用范例： mv.visitMultiANewArrayInsn(&quot;[[Ljava/lang/String;&quot;, 2); mv.visitMultiANewArrayInsn(&quot;[[[I&quot;, 3); 创建一个多维数组，多维数组的描述符要与第二个参数维度相匹配。和另两个字节码相同，如果多维数组任意一维的长度小于0，这个字节码就会抛出NegativeArraySizeException。 下面是使用这三个字节码的例子： Java代码： int[] arrayInt = new int[10]; int[][] multi2Int = new int[100][2]; String[] strings = new String[30]; String[][] multiStrings = new String[127][128]; 生成这些代码的字节码程序： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 // new int[10] mv.visitIntInsn(BIPUSH, 10); mv.visitIntInsn(NEWARRAY, T_INT); mv.visitVarInsn(ASTORE, 0); // new int[100][2] mv.visitIntInsn(BIPUSH, 100); mv.visitInsn(ICONST_2); mv.visitMultiANewArrayInsn(&quot;[[I&quot;, 2); mv.visitVarInsn(ASTORE, 1); // new String[30] mv.visitIntInsn(BIPUSH, 30); mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;); mv.visitVarInsn(ASTORE, 2); // new String[127][128] mv.visitIntInsn(BIPUSH, 127); mv.visitIntInsn(SIPUSH, 128); mv.visitMultiANewArrayInsn(&quot;[[Ljava/lang/String;&quot;, 2); mv.visitVarInsn(ASTORE, 3); 在创建数组时，如果是一维数组就用newarray或anewarray。multianewarray也能创建一维数组，但是使用上面的两个更加高效。 arraylength输入：数组 输出：数组长度 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ARRAYLENGTH); 获取数组的长度，返回int。如果数组输入为null，抛出空指针异常。 xaloadx=a,b,c,d,f,i,l,s, 其中b同时负责了byte和boolean 输入：数组，int类型的下标 输出：数组元素 方法：visitInsn 参数：无 使用范例： mv.visitInsn(BALOAD); xaload的作用是从数组指定下标取元素。如果下标超过数组长度，抛出ArrayIndexOutOfBoundsException。对于多维数组的提取元素方式类似下面： // Java 代码： // 设int[][] multi = new int[10][20];位于局部变量表0位 return multi[1][4]; // 字节码： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitVarInsn(ALOAD, 0); mv.visitInsn(ICONST_1); mv.visitInsn(AALOAD); mv.visitInsn(ICONST_4); mv.visitInsn(IALOAD); mv.visitInsn(IRETURN); xastorex=a,b,c,d,f,i,l,s, 其中b同时负责了byte和boolean 输入：数组，int类型的下标，一个变量 输出：无 方法：visitInsn 参数：无 使用范例： mv.visitInsn(BASTORE); 将对象存入数组指定下标。如果下标超过数组长度，抛出ArrayIndexOutOfBoundsException。对于多维数组，存储对象需要和xaload一起配合。 // Java 代码： // 设int[][] multi = new int[10][20];位于局部变量表0位 multi[1][4] = 20; // 字节码： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitVarInsn(ALOAD, 0); mv.visitInsn(ICONST_1); mv.visitInsn(AALOAD); mv.visitInsn(ICONST_4); mv.visitIntInsn(BIPUSH, 20); mv.visitInsn(IASTORE); 操作字段的字节码在代码中我们经常会调用类中的字段，例如System.out。Java提供了四个字节码用于访问和修改字段。 getfield输入：一个对象 输出：对应字段的值 方法：visitFieldInsn 参数：字段所处的类、字段名、字段描述符 使用范例： mv.visitFieldInsn(GETFIELD, &quot;org/objectweb/asm/MethodVisitor&quot;, &quot;mv&quot;, &quot;Lorg/objectweb/asm/MethodVisitor;&quot;); getfield用于获取非静态字段的值。如果它作用目标是一个静态字段，则在类连接验证时抛出IncompatibleClassChangeError。 如果输入的对象是null，这个字节码会在运行时抛出空指针异常。 这个字节码不能调用数组的length字段，在编译的时候length字段会自行转变成arraylength字节码。 getstatic输入：无 输出：对应字段的值 方法：visitFieldInsn 参数：字段所处的类、字段名、字段描述符 使用范例： mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); getstatic用于获取静态字段的值。如果它作用目标是一个非静态字段，则在类连接验证时抛出IncompatibleClassChangeError。 putfield输入：一个对象、准备修改成的对象 输出：无 方法：visitFieldInsn 参数：字段所处的类、字段名、字段描述符 使用范例： mv.visitFieldInsn(PUTFIELD, &quot;org/objectweb/asm/MethodVisitor&quot;, &quot;mv&quot;, &quot;Lorg/objectweb/asm/MethodVisitor;&quot;); putfield用于修改非静态字段的值。如果它作用目标是一个静态字段，则在类连接验证时抛出IncompatibleClassChangeError。 如果输入的对象是null，这个字节码会在运行时抛出空指针异常。 对于final字段，如果不是在初始化对象时修改（构造函数中），那么就会抛出IllegalAccessError。 putstatic输入：准备修改成的对象 输出：无 方法：visitFieldInsn 参数：字段所处的类、字段名、字段描述符 使用范例： mv.visitFieldInsn(PUTSTATIC, &quot;io/github/nickid2018/Constants&quot;, &quot;test&quot;, &quot;Z&quot;); putstatic用于修改静态字段的值。如果它作用目标是一个非静态字段，则在类连接验证时抛出IncompatibleClassChangeError。 对于final字段，如果不是在类初始化时修改（&lt;clinit&gt;中），那么就会抛出IllegalAccessError。 调用方法的字节码调用方法的字节码共有五个：invokevirtual，invokespecial，invokestatic，invokeinterface和invokedynamic。invokedynamic使用了BSM（BootStrap Method），讲解起来很复杂，所以这个要单独分出来一篇文章去讲。这篇文章主要讨论前四个。 这些字节码使用的是visitMethodInsn，此方法的最后一个参数代表此方法是不是在一个接口内定义，而不是是否为接口抽象方法。(具体来说是常量池内CONSTANT_MethodRef和CONSTANT_InterfaceMethodRef的区别) invokevirtual输入：一个对象，传入参数 输出：与方法返回值有关 方法：visitMethodInsn 参数：方法所在的类，方法名，方法描述符，固定值false 使用范例： mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); 这个字节码用于调用实例方法：如果对象是子类的对象且子类复写了这个方法，则调用子类的方法；如果对象就是该类的直接对象或者对象所属子类没有复写这个方法，就调用现在类的方法。 在编译时，如果子类调用了父类的方法且子类没有实现此方法，那么方法所在的类要写为父类。如果使用super，要用invokespecial调用（下文）。 如果方法调用目标是静态的，在连接验证时会抛出IncompatibleClassChangeError。 如果方法调用目标是抽象的，并且在继承树上没有任何实现此方法的类，在调用时会抛出AbstractMethodError。 如果方法调用目标是抽象的，而继承树上由多个实现此方法的类，且这些方法都是可被选中成为调用目标的方法（比如一个类继承于一个抽象类，又实现了两个接口，两个接口中都有一个同样的default方法可作为抽象类中抽象方法的实现目标），这时此字节码会抛出IncompatibleClassChangeError。 如果方法调用目标是native的，且没有任何JNI连接查询到这个方法和哪个C函数相连接，这时这个字节码抛出UnsatisfiedLinkError。 invokespecial输入：一个对象，传入参数 输出：与方法返回值有关 方法：visitMethodInsn 参数：方法所在的类，方法名，方法描述符，固定值false 使用范例： mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false); invokespecial类似于invokevirtual，但不同的是，它和调用方法的对象的类型无关：它的方法调用对象就是字节码内部标定的方法，如果这个类找不到就寻找直接超类的方法，而不是像invokevirtual要考虑继承树所有的方法。 这个方法经常在构造函数中看到，因为无论什么类都需要有一个构造函数，而构造函数内部必须自动调用父类构造函数。 一个默认的构造函数类似于下面： public class Test &#123; public Test() &#123; super(); &#125; &#125; 在生成类时，如果没有自定义其他构造函数，就要加上这个默认构造函数： ClassWriter cw = new ClassWriter(0); cw.visit(V17, ACC_PUBLIC + ACC_SUPER, &quot;Test&quot;, null, &quot;java/lang/Object&quot;, null); MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null); mv.visitVarInsn(ALOAD, 0); // 加载自身(this) mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); // 调用父类构造函数 mv.visitInsn(RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); cw.visitEnd(); invokestatic输入：一个对象，传入参数 输出：与方法返回值有关 方法：visitMethodInsn 参数：方法所在的类，方法名，方法描述符，固定值false 使用范例： mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Math&quot;, &quot;sin&quot;, &quot;(D)D&quot;, false); invokestatic用于调用静态方法，如果调用目标不是个静态方法，抛出IncompatibleClassChangeError。 和invokevirtual一样，如果目标是个native方法而JNI找不到连接的C函数，该字节码抛出UnsatisfiedLinkError。 invokeinterface输入：一个对象，传入参数 输出：与方法返回值有关 方法：visitMethodInsn 参数：方法所在的类，方法名，方法描述符，固定值true 使用范例： mv.visitMethodInsn(INVOKEINTERFACE, &quot;java/util/Set&quot;, &quot;clear&quot;, &quot;()V&quot;, true); 这个字节码类似于invokevirtual，异常情况的处理也和它类似。它用于调用接口方法，而不是像invokevirtual的实例方法。 抛出异常的字节码：athrow输入：一个Throwable对象 输出：操作栈不变 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ATHROW); athrow负责将一个Throwable对象抛出。如果对象是null，那么就不会抛出这个null，而是抛出NullPointerException。 通常情况下，我们都是直接new一个Throwable对象然后直接抛出，就像这样： throw new Exception(&quot;error!&quot;); 翻译为字节码如下： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitTypeInsn(NEW, &quot;java/lang/Exception&quot;); mv.visitInsn(DUP); mv.visitLdcInsn(&quot;error!&quot;); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Exception&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitInsn(ATHROW); 同步字节码同步操作共有两个字节码，monitorenter和monitorexit，成套使用。 输入：一个对象 输出：无 方法：visitInsn 参数：无 使用范例： mv.visitInsn(MONITORENTER); mv.visitInsn(MONITOREXIT); 输入的对象必须是引用类型对象，不能是基本类型的值。 使用同步块时，代码类似这样： Object lock = new byte[0];//设0号位 synchronized(lock) &#123; //... &#125; 对应的字节码： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitInsn(ICONST_0); mv.visitIntInsn(NEWARRAY, T_BYTE); mv.visitVarInsn(ASTORE, 0); mv.visitVarInsn(ALOAD, 0); mv.visitInsn(MONITORENTER); //... mv.visitVarInsn(ALOAD, 0); mv.visitInsn(MONITOREXIT); monitorenter就是尝试加锁的操作。如果这个对象的监视器条目计数为0，此线程会把这个计数设置为1，这时此线程就是这个对象的监视器；如果不为0且线程不是该对象的监视器，线程会阻塞直到计数为0时重新尝试加锁；如果线程已经是这个对象的监视器，计数递增。 monitorexit就是释放锁的操作。如果线程是这个对象的监视器，计数递减，当计数减为0时该线程就不是这个对象的监视器了。如果线程不是这个对象的监视器，这个字节码会抛出IllegalMonitorStateException。 monitorenter可以和很多monitorexit一起出现，在一个方法的所有可能流程中的加锁次数和释放次数必须相同，否则在调用时会发生IllegalMonitorStateException。 对于同步方法（访问标志含有ACC_SYNCHRONIZED），不需要手动对自身对象或类加锁。JVM在调用方法前隐式加锁，在调用之后隐式释放。 应用：计算两数之积学到了这些字节码，接下来我们要试试用纯字节码解决这道简单的问题。 输入：两个双精度浮点数a,b 输出：一个保留5位小数部分的双精度浮点数，代表a*b 例： 3.22 6.11 输出： 19.67420 在Java代码下，我们可以这样写： // 这里不写main方法，而是写了一个静态的test方法用于后续调用 import java.util.Scanner; public class Test &#123; public static void test() &#123; Scanner scanner = new Scanner(System.in); double a = scanner.nextDouble(); double b = scanner.nextDouble(); System.out.printf(&quot;%.5f&quot;, a * b); &#125; &#125; 下面是用ASM生成的步骤： 首先还是创建类和方法，不再多说。 第一行，创建Scanner对象，这里用到的就是new。 // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitTypeInsn(NEW, &quot;java/util/Scanner&quot;); mv.visitInsn(DUP); mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;in&quot;, &quot;Ljava/io/InputStream;&quot;); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/util/Scanner&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/io/InputStream;)V&quot;, false); mv.visitVarInsn(ASTORE, 0); 第二行和第三行都是读取double，这里是调用了Scanner的nextDouble方法，这里只给第二行的例子： mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/util/Scanner&quot;, &quot;nextDouble&quot;, &quot;()D&quot;, false); mv.visitVarInsn(DSTORE, 1); 接下来是个重头戏。首先来看看PrintStream::printf的定义： public PrintStream printf(String format, Object ... args) 可以看到，args是个不定长参数，这怎么表示呢？ 在Java中，不定长参数都被解析为数组，也就是说，它在字节码中的表示其实是这样的： public PrintStream printf(String format, Object[] args) 现在我们需要传递的参数就是一个字符串和一个Object数组。可是double不是引用类型，这又要怎么办呢？ 在Java中，基本类型都有它们的“包装类”。double的包装类是java.lang.Double，通过Double::valueOf方法就可以把double值转变为Double对象，也就是装箱操作。在平常编写时，Java编译器会自动为我们添加装箱操作，也就是自动装箱。 经过这样的解析，最后这句话的Java代码表示就像这样： System.out.printf(&quot;%.5f&quot;, new Object[] &#123; Double.valueOf(a * b) &#125;); 其中Object[]是一个长度为1的数组，也就是先创建它然后将Double对象用aastore字节码放入就行。 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); // System.out mv.visitLdcInsn(&quot;%.5f&quot;); // printf的第一个参数 mv.visitInsn(ICONST_1); // Object[]的长度 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/Object&quot;); // 创建Object[] mv.visitInsn(DUP); // 复制一份数组，一份用于放入对象，一份用于传入方法 mv.visitInsn(ICONST_0); // 放入数组的位置，0 mv.visitVarInsn(DLOAD, 1); // 取出a mv.visitVarInsn(DLOAD, 3); // 取出b（3是因为double要占两个局部变量槽位！） mv.visitInsn(DMUL); // 计算 a * b mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Double&quot;, &quot;valueOf&quot;, &quot;(D)Ljava/lang/Double;&quot;, false); // 装箱 mv.visitInsn(AASTORE); // 放入数组 mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;printf&quot;, &quot;(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;&quot;, false); 最后写入return和visitMaxs，局部变量一共5个槽位，最大的操作栈大小是9： mv.visitInsn(RETURN); mv.visitMaxs(9, 5); 下面就可以实验了！ 3.22 6.11 19.67420 测试结果和预测一样！ 全部代码：https://paste.ubuntu.com/p/NXDfFpQ4y6/ 这篇专栏的内容结束了，下一篇：Java ASM详解：MethodVisitor与Opcode（三）标签，选择结构，循环结构，栈帧 这篇文章一共讲了34个字节码，从开始到现在一共讲了164个。 有错误在评论中指出。","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"JEP 412 Foreign Function & Memory (FFM) API 外部函数与内存API","slug":"JEP412 Foreign Function Memory FFM API外部函数与内存API","date":"2021-08-08T00:00:00.000Z","updated":"2021-08-30T11:30:21.000Z","comments":true,"path":"2021/08/08/JEP412 Foreign Function Memory FFM API外部函数与内存API/","link":"","permalink":"http://nickid2018.github.io/2021/08/08/JEP412%20Foreign%20Function%20Memory%20FFM%20API%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E5%AD%98API/","excerpt":"","text":"这篇专栏翻译自https://openjdk.java.net/jeps/412，”JEP 412: Foreign Function &amp; Memory API (Incubator)”，讲述了有关于Java 17中加入的FFM API。 前言引入一个可以让Java程序与Java运行时以外的代码和数据进行交换的API。通过高效的调用外部函数（即JVM外部的代码），并且通过安全地访问外部内存（即不是由JVM管理的内存），这套API能让Java程序调用本地库和操作本地数据的同时避免JNI的脆弱性和不安全性。 目标 易用性 - 将Java本地接口（JNI）替换为优越的，纯Java开发的模型 性能 - 提供与现有 API（如 JNI 和 sun.misc.Unsafe）相媲美（如果不是更好的话）的性能 通用性 - 提供操作不同类型的外部内存（如：本地内存，永久内存和堆内存）的方法，并且随着时间的推移，去适应其他的平台（如：32bit x86）和除C以外的语言（如：C++,Fortran）编写的外部函数 安全性 - 在默认情况下禁用不安全的操作，仅在从应用程序开发人员或最终用户明确选择后才能禁用它们 非目标 在此 API 之上重新实现JNI，或以任何方式修改JNI 在此 API 之上重新实现传统 Java API，例如：sun.misc.Unsafe类 提供从本地代码头文件中自动生成 Java 代码的工具，或者 更改与本地库交互的 Java 应用程序的包装和部署方式（例如，通过多平台 JAR 文件） 内容外部内存存储在Java运行时之外的内存的数据被称为堆外数据(off-heap data)。”heap”（堆）是Java对象生存（对象生命周期）的地方，也是垃圾回收（Garbage Collector，GC）处理的地方。访问堆外数据对于Tensorflow、Ignite、Lucene和Netty等Java库的性能至关重要，这主要是因为这避免了由垃圾回收引起的成本和不可预测性，并且这也允许程序通过mmap等将文件映射入内存中进行数据结构的序列化和反序列化。但是，Java平台到今天没有为访问堆外数据提供令人满意的解决方案。 ByteBuffer API（java.nio）允许创建直接缓冲区（direct buffer），这些缓冲区在堆外分配，但是它们的最大大小限制为2GB并且不能及时释放。这些和其他的限制都来源于一个事实：ByteBuffer API不仅被用于访问堆外内存，还被用于生产者/消费者之间批量数据的交换，如字符集的编码/解码和部分I/O操作。在这方面，它无法满足多年来提出的许多堆外内存增强请求。 sun.misc.Unsafe API暴露了堆内内存的访问操作，这对堆外内存也适用。使用它很高效，因为它的内存操作被定义在HotSpot JVM内部并且会被JIT编译器优化。但是，因为它可以访问任何内存位置，使用它是危险的。这意味着一个Java程序可以通过访问一个已经释放的内存位置使JVM崩溃。因为这个和其他的原因，使用Unsafe是强烈不被推荐的。 使用JNI调用本地库来访问堆外内存是可能的，但是因为它的效率开销（较高）而很少找到适用的地方：从Java到本地代码的速度要比直接访问内存的速度慢几个数量级，因为JNI方法调用并不能从常见的JIT优化（如内联）中获益。 总之，当访问堆外数据时，Java开发者就面临着两难的境地：他们是选择安全但效率不高的方式（ByteBuffer API）还是放弃安全转而选择性能（Unsafe API）？开发者需要的是一个Java支持的API，用于在JIT优化下从头到脚安全地访问堆外数据（即外部内存）。 外部函数从Java 1.1开始，JNI就已经支持本地代码的调用（即外部函数），但是因为很多原因它并不适合。 JNI涉及几个乏味的构件:Java API（本地方法）、源自Java API的C头文件（译注：即javah.exe的工作，当Java 10移除javah.exe后，这项工作由javac -h完成），以及调用感兴趣的本地库的C实现。Java开发人员必须跨多个工具链工作，以保持与平台相关的构件同步，当本地库快速发展时，这尤其繁重。 JNI只能与以一些语言（通常为C/C++）进行交互，这些库使用了JVM在构建中使用的操作系统和CPU的约定。本地方法不能被用于去调用一个由不同约定的语言编写的函数。 JNI没有协调Java类型系统和C类型系统。Java中的聚合数据是用对象表示的，但C中的聚合数据是用结构体表示的，因此传递给本地方法的任何Java对象都必须费力地由本地代码解包。例如，考虑一个Java中的记录（record，Java 16加入）类Person：将Person对象传递给本地方法将要求本地代码使用JNI的C API从对象中提取字段（例如，firstName和lastName）（译注：提取字段就是使用JNIEnv*的函数）。结果是，Java开发者们有些时候会把他们的数据转变成一个单独的对象（如：一个字节数组或一个direct ByteBuffer），但更常见的是，因为通过JNI传递Java对象很慢，他们就使用Unsafe API去分配堆外内存并且以long的形式将内存地址传递给本地方法（译注：比如LWJGL）——可悲的是这使得Java代码变得不安全！ 多年来，有许多框架填补JNI留下的空白，这其中包括JNA、JNR和JavaCPP。虽然这些框架通常被视为JNI的改进，但是情况依旧不理想，尤其是当与提供一流的本地代码交互的语言相比。比如，Python的ctypes包可以动态地将函数包装在本地库中而不用生成任何的粘合代码。其他语言，例如Rust，提供了可以从C/C++头文件中自动派生本地代码包装的工具。 总之，Java开发者应该有一个让他们能直接使用任何被认为对特定任务有用的本机库并且避免使用JNI带来的繁琐与沉闷的API。对于此的一个绝佳的抽象是方法句柄（Method Handle），它在Java 7被引入，用于支持在JVM上的快速动态语言（invokedynamic，inDy）。通过方法句柄公开本机代码将从根本上简化编写、构建和分发依赖于本机库的Java库的任务。此外，能够建模外部函数（即本机代码）和外部内存（即堆外数据）的API将为第三方本机交互框架提供坚实的基础。 描述外部函数与内存API（Foreign Function &amp; Memory API，下文简称为”FFM API”）定义了一系列类与接口以便于在库与应用程序中的客户端代码： 分配外部内存（MemorySegment，MemoryAddress和SegmentAllocator）,操作和访问结构化外部内存（MemoryLayout，MemoryHandles和MemoryAccess），管理外部资源的生命周期（ResourceScope）和调用外部函数（SymbolLookup和CLinker） FFM API定义在jdk.incubator.foreign模块下的jdk.incubator.foreign包内。 例子下面是一个简单的使用FFM API的例子，Java代码获得了一个C库函数radixsort的方法句柄，然后用它来对Java数组中的四个字符串进行排序（一些细节被省略了）： // 1. 在C库路径下寻找外部函数 MethodHandle radixSort = CLinker.getInstance().downcallHandle( CLinker.systemLookup().lookup(&quot;radixsort&quot;), ...); // 2. 分配堆内内存储存4个字符串 String[] javaStrings = &#123; &quot;mouse&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;car&quot; &#125;; // 3. 分配堆外内存储存4个指针 MemorySegment offHeap = MemorySegment.allocateNative( MemoryLayout.ofSequence(javaStrings.length, CLinker.C_POINTER), ...); // 4. 将字符串从堆内复制到堆外 for (int i = 0; i &lt; javaStrings.length; i++) &#123; // 分配一个堆外的字符串， 然后储存一个指向它的指针 MemorySegment cString = CLinker.toCString(javaStrings[i], newImplicitScope()); MemoryAccess.setAddressAtIndex(offHeap, i, cString.address()); &#125; // 5. 通过调用外部函数将堆外数据排序 radixSort.invoke(offHeap.address(), javaStrings.length, MemoryAddress.NULL, &#x27;\\0&#x27;); // 6. 将（已经排序后）的字符串数组从堆外复制到堆内 for (int i = 0; i &lt; javaStrings.length; i++) &#123; MemoryAddress cStringPtr = MemoryAccess.getAddressAtIndex(offHeap, i); javaStrings[i] = CLinker.toJavaStringRestricted(cStringPtr); &#125; assert Arrays.equals(javaStrings, new String[] &#123;&quot;car&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;mouse&quot;&#125;); // true 这段代码比任何使用JNI的解决方案都清晰得多，因为原本隐藏在本机方法调用后面的隐式转换和内存解引用现在直接用Java表示了。也可以使用现代Java语言特性；例如，流可以允许多个线程并行地在堆内和堆外内存之间复制数据。 内存段（Memory Segments）内存段是对位于堆外或堆内的连续内存区域进行建模的抽象。内存段可以为 本地段，在本地内存内从头开始分配（例如通过malloc），映射段，将映射包装在本地内存区域中（例如通过mmap），或者数组或缓冲区段，将现有的Java数组或字节缓冲区相关的内存分别包装 所有的内存段都提供了空间、时间和线程限制的保证，为了使内存解引用操作安全，这些保证都是强制的。例如，下面的代码在堆外分配了100个字节： MemorySegment segment = MemorySegment.allocateNative(100, newImplicitScope()); 段的空间边界决定了与段相关联的内存地址的范围。上面代码中段的边界由表示为MemoryAddress实例的基础地址b和以字节为单位的大小（100）定义，结果是地址范围从b到b + 99（包括b + 99）。 段的时间边界决定了段的生存期，也就是这个段什么时候会被释放。段的生存期和线程限制状态是通过ResourceScope抽象建模的，下面将对此进行讨论。上面代码中的资源作用域是一个新的隐式作用域，它确保当垃圾回收器认为MemorySegment对象不可达时才释放与此段相关的内存。隐式作用域还确保可以从多个线程访问内存段。 换句话说，上面的代码创建了一个行为与allocateDirect工厂分配的ByteBuffer的行为紧密匹配的段。FFM API还支持还支持确定性内存释放和其他线程限制选项，将在下面讨论。 解引用内存段与段关联的内存解引用是通过获取变量句柄来实现的，它是Java 9中引入的数据访问抽象模型。特别地，段是用内存访问变量句柄来解引用的。这种类型的变量句柄使用一对访问坐标： 以MemorySegment对象表示的坐标——也就是控制的内存要被解引用的段，和以long表示的坐标——也就是偏移量（offset），从段的基础地址到解引用开始的偏移量 内存访问变量句柄可以通过在MemoryHandles类中的工厂方法获取。例如，这段代码获取了可以将int写入本地内存段的内存访问变量句柄，并且使用它在连续的偏移下写入25个4字节的值（译注：指int为4字节）： MemorySegment segment = MemorySegment.allocateNative(100, newImplicitScope()); VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()); for (int i = 0; i &lt; 25; i++) &#123; intHandle.set(segment, /* 偏移 */ i * 4, /* 要写入的数据 */ i); &#125; 更高级的访问用法可以通过使用MemoryHandles类提供的一个或多个组合子方法来组合内存访问变量句柄来表达。使用这些客户端可以，例如，对给定的内存访问变量句柄进行重排序，删除一个或多个坐标，或插入新的坐标。这允许创建接受一个或多个逻辑索引到一个在堆外内存区域的多维数组中的内存访问变量句柄。 为了使FFM API更容易访问，MemoryAccess类提供了静态访问器来解引用内存段，而不需要构造内存访问变量句柄。例如，有一个访问器可以在给定偏移量的段中设置一个int值，允许上面的代码简化为： MemorySegment segment = MemorySegment.allocateNative(100, newImplicitScope()); for (int i = 0; i &lt; 25; i++) &#123; MemoryAccess.setIntAtOffset(segment, i * 4, i); &#125; 内存布局（Memory Layouts）为了减少对内存布局的繁琐计算(例如，上面例子中的i * 4)， MemoryLayout可以用更声明式的方式来描述内存段的内容。例如，上面例子中需要的本地内存段的布局可以用以下方式描述： SequenceLayout intArrayLayout = MemoryLayout.sequenceLayout(25, MemoryLayout.valueLayout(32, ByteOrder.nativeOrder())); 这将创建一个序列内存布局（sequence memory layout），内部由重复了25次的32比特值布局（一个描述了单一32字节值的布局）构成。给定一个内存布局，我们可以避免在代码中计算偏移量，并简化内存分配和创建内存访问变量句柄： MemorySegment segment = MemorySegment.allocateNative(intArrayLayout, newImplicitScope()); VarHandle indexedElementHandle = intArrayLayout.varHandle(int.class, PathElement.sequenceElement()); for (int i = 0; i &lt; intArrayLayout.elementCount().getAsLong(); i++) &#123; indexedElementHandle.set(segment, (long) i, i); &#125; intArrayLayout对象通过创建布局路径来驱动内存访问变量句柄的创建，该路径用于从复杂布局表达式中选择嵌套布局。intArrayLayout对象也驱动了本地内存段的分配，这个内存段基于来自于布局的大小和对齐信息。在之前的例子中的循环常数，也就是25，已经被序列布局的元素数量所替代。 资源作用域（Resource Scopes）在前面的例子中看到的所有内存段都使用了非确定性的释放：一旦内存段实例变得不可达，垃圾收集器就会释放与这些段相关的内存。我们说这样的段是隐式释放的。 在某些情况下，客户端可能希望控制何时发生内存释放。试想，例如，使用MemorySegment::map从一个文件中映射出一个很大的内存段。客户端可能更喜欢在段不再需要时释放（即取消映射）与段相关的内存，而不是等待垃圾收集器这样做，因为等待可能会对应用程序的性能产生不利影响。 内存段支持通过资源作用域的确定性释放。资源作用域对与一个或多个资源（如内存段）相关联的生命周期进行建模。新创建的资源作用域处于活动状态，这意味着可以安全地访问它管理的所有资源。在客户端请求时，可以关闭资源作用域，这意味着不再允许访问由该作用域管理的资源。因为ResourceScope类实现了AutoClosable接口，所以它可以使用try-with-resource语句： try (ResourceScope scope = ResourceScope.newConfinedScope()) &#123; MemorySegment s1 = MemorySegment.map(Path.of(&quot;someFile&quot;), 0, 100000, MapMode.READ_WRITE, scope); MemorySegment s2 = MemorySegment.allocateNative(100, scope); ... &#125; // 这两个内存段到这里被释放 这段代码创建了一个受限（confined）的资源作用域，并将其用于创建两个段：映射段（s1）和本地段（s2）。这两个段的生命周期与资源作用域的生命周期相关联，因此在try-with-resources语句完成后访问段（例如，使用内存访问变量句柄对它们进行解引用）将导致抛出一个运行时异常。 除了管理内存段的生命周期外，资源作用域还可以作为一种方法来控制哪些线程可以访问内存段。受限资源作用域只允许创建作用域的线程的访问，而共享资源作用域允许从任何线程访问。 资源作用域，无论是受限的还是共享的，都可能与java.lang.ref.Cleaner对象相关联，该对象负责执行隐式释放，以防在客户端调用close方法之前，资源作用域对象变得不可达。 一些称为隐式资源作用域的资源作用域不支持显式释放——调用close将失败。隐式资源作用域总是使用Cleaner来管理它们的资源。隐式作用域可以使用ResourceScope::newImplicitScope工厂创建，如前面的示例所示。 段分配器（Segment Allocators）当客户端使用堆外内存时，内存分配通常是一个瓶颈。FFM API包括一个SegmentAllocator抽象模型，它定义了分配和初始化内存段的操作。段分配器是通过SegmentAllocator接口中的工厂获得的。例如，下面的代码创建了一个基于区域（arena-based）的分配器，并使用它来分配一个内容是从Java int数组初始化的段： try (ResourceScope scope = ResourceScope.newConfinedScope()) &#123; SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope); for (int i = 0 ; i &lt; 100 ; i++) &#123; MemorySegment s = allocator.allocateArray(C_INT, new int[] &#123; 1, 2, 3, 4, 5 &#125;); ... &#125; ... &#125; // 所有分配的内存在此处被释放 这段代码创建一个受限的资源范围，然后创建与该范围相关联的无边界区域分配器（unbounded arena allocator）。这个分配器将分配特定大小的内存块，并通过返回预先分配的内存块的不同片（译注：也就是分配器先分配一定大小的块后，用户要求内存时按用户需求在内存块中取出相当长度的内存切片）来响应分配请求。如果一个内存块没有足够的空间来容纳一个新的分配请求，那么就分配一个新的内存块。如果与区域分配器相关联的资源作用域被关闭，所有与分配器创建的段相关联的内存（例如，在for循环体中）都会被以原子方式释放。这种用法结合了ResourceScope抽象提供的确定性释放的优点，以及更灵活和可伸缩的分配方案。在编写管理大量堆外内存段的代码时，它非常有用。 不安全的内存段到目前为止，我们已经看到了内存段、内存地址和内存布局。解引用操作只能在内存段上进行。由于内存段具有空间和时间边界，Java运行时总是可以确保与给定段相关联的内存被安全解引用。然而，在某些情况下，客户端可能只有MemoryAddress实例，这在与本机代码交互时经常发生。由于Java运行时无法知道与内存地址相关的空间和时间边界，因此FFM API禁止直接解引用内存地址。 为了解引用内存地址，客户端有两种选择： 如果已知地址位于一个内存段，客户端可以通过MemoryAddress::segmentOffset进行重新基准（rebase）操作。重新基准操作会重新定义地址相对于段的基本地址的偏移量，以产生一个新的可以应用于现有段上的偏移量——然后可以安全地对该段解引用。 或者，如果没有这样的段存在，那么客户端可以使用MemoryAddress::asSegment工厂不安全地创建一个。这个工厂有效地将新的空间和时间边界附加到一个原始的内存地址，以便允许解引用操作。该工厂返回的内存段是不安全的：一个原始内存地址可能与一个10字节长的内存区域相关联，但客户端可能意外地高估了该区域的大小，并创建了一个100字节长的不安全内存段。这可能会导致稍后试图对与不安全段关联的内存区域边界之外的内存的解引用，这可能会导致JVM崩溃，或者更糟的是，导致在无形中的内存损坏。因此，创建不安全的段被视为受限操作，默认情况下是禁用的（参见下面的详细内容）。 寻找外部函数任何对外部函数的支持的第一个组成部分都是加载本地库的机制。在JNI中，这是通过System::loadLibrary和System::load方法完成的，它们在内部映射到对dlopen或其等效函数的调用。使用这些方法加载的库总是与类加载器（即调用System方法的类加载器）相关联。库和类加载器之间的关联是至关重要的，因为它管理装入的库的生命周期：只有当类加载器不再可访问时，它的所有库才能被安全卸载。 FFM API没有提供加载本地库的新方法。开发者使用System::loadLibrary和System::load方法来加载将通过FFM API调用的本地库。库和类加载器之间的关联被保留，因此库将以与JNI相同的可预测方式卸载。 与JNI不同，FFM API提供了在加载的库中查找给定标识地址的功能。这种由SymbolLookup对象表示的功能对于将Java代码链接到外部函数至关重要（参见下面）。有两种方法可以获得SymbolLookup对象： SymbolLookup::loaderLookup返回一个包括本加载器内加载的所有库内部的标识的查找器 CLinker::systemLookup返回一个特定于平台的标识查找器，它能查找标准C库内的标识 给定一个标识查找器，客户端可以使用SymbolLookup::lookup(String)方法找到一个外部函数。如果指定的函数出现在标识查找器所包括的标识中，则该方法返回指向函数入口点的MemoryAddress。例如，下面的代码加载OpenGL库（使它与当前类加载器相关联），并找到它的glGetString函数的地址： System.loadLibrary(&quot;GL&quot;); SymbolLookup loaderLookup = SymbolLookup.loaderLookup(); MemoryAddress clangVersion = loaderLookup.lookup(&quot;glGetString&quot;).get(); 将Java代码链接到外部函数CLinker接口是Java代码与本地代码交互的核心。虽然CLinker专注于提供Java和C库之间的互操作，但接口中的概念已经足够通用，可以在未来支持其他非Java语言。该接口支持向下调用（downcall，从Java代码调用本地代码）和向上调用（upcall，从本地代码调用回Java代码）。 interface CLinker &#123; MethodHandle downcallHandle(MemoryAddress func, MethodType type, FunctionDescriptor function); MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope); &#125; 对于向下调用，downcallHandle方法接受外部函数的地址——通常是从库查找中获得的MemoryAddress——并将外部函数作为向下调用方法句柄公开。稍后，Java代码通过调用invokeExact方法调用downcall方法句柄，然后运行外部函数。传递给方法句柄的invokeExact方法的任何参数都会传递给外部函数。 对于上行调用，upcallStub方法接受一个方法句柄——通常是指一个Java方法句柄，而不是下行调用方法句柄——并将其转换为内存地址。稍后，当Java代码调用downcall方法句柄时，将内存地址作为参数传递。实际上，内存地址充当函数指针。（欲了解更多关于upcall的信息，请参阅下面） 假设我们想从Java向下调用定义在C标准库中的strlen函数： size_t strlen(const char *s); 一个暴露strlen的向下调用方法句柄可以像下面这样获取（关于MethodType和FunctionDescriptor的细节将会简短介绍）： MethodHandle strlen = CLinker.getInstance().downcallHandle( CLinker.systemLookup().lookup(&quot;strlen&quot;).get(), MethodType.methodType(long.class, MemoryAddress.class), FunctionDescriptor.of(C_LONG, C_POINTER) ); 调用向下调用方法句柄会执行strlen并且让结果在Java端可见。对于strlen的参数，我们使用一个helper方法将Java的字符串转变为堆外内存段并且传递这个段的地址： MemorySegment str = CLinker.toCString(&quot;Hello&quot;, newImplicitScope()); long len = strlen.invokeExact(str.address()); // 5 方法句柄在公开外部函数时工作得很好，因为JVM已经优化了方法句柄的调用，一直优化到本地代码。当方法句柄引用类文件中的方法时，调用方法句柄通常会导致目标方法被JIT编译；随后，JVM通过将控制转移到为目标方法生成的汇编代码来解释调用MethodHandle::invokeExact的Java字节码。因此，调用传统方法句柄已经几乎是外部调用；以C库中的函数为目标的downcall方法句柄只是一种更外部的方法句柄形式。方法句柄还具有一个名为签名多态性的属性，该属性允许基本类型参数的非装箱传入（译注：就是直接传int而不是Integer避免装箱/拆箱操作）。总之，方法句柄让CLinker以一种自然、有效和可扩展的方式公开外部函数。 在Java中描述C类型为了创建向下调用方法句柄，FFM API需要客户端提供对于目标C函数的两种签名：使用非透明的Java对象（MemoryAccess和MemorySegment）的高级别签名和使用透明的Java对象（MemoryLayout）的低级别签名。依次取每个签名： 高级别签名，即MethodType，用作向下调用方法句柄的类型。每个方法句柄都是强类型的，这意味着可以传递给它的invokeExact方法的参数的数量和类型是严格的。例如，为接受一个MemoryAddress参数而创建的方法句柄不能通过invokeExact(MemoryAddress, MemoryAddress)或通过invokeExact(“Hello”)调用。因此，MethodType描述了客户端在调用向下调用方法句柄时必须使用的Java签名。实际上，它是C函数的Java视图。 低级别签名，即FunctionDescriptor，包含MemoryLayout对象。这使CLinker能够精确地理解C函数的参数，以便它能够正确地安排它们，如下所述。客户端通常有MemoryLayout对象，以便解引用外部内存中的数据，这样的对象可以在这里作为外部函数签名重用。 例如，为接受int值并返回long值的C函数获取向下调用方法句柄时，downcallHandle方法需要以下MethodType和FunctionDescriptor参数： MethodType mtype = MethodType.methodType(long.class, int.class); FunctionDescriptor fdesc = FunctionDescriptor.of(C_LONG, C_INT); 这个例子的目标系统是Linux/x64和macOS/x64，其中Java类型long和int分别与预定义的CLinker布局C_LONG和C_INT关联。Java类型与内存布局的关联因平台而异：例如，在Windows/x64上，Java long与C_LONG_LONG布局相关联 译注：这里的原因是C中long的位数取决于系统，而long long为确定64位；在Java中，int确定32位而long为64位，为了确保数据的对齐需要调整布局 另一个例子，获取一个带有指针的void C函数的向下调用方法句柄需要以下MethodType和FunctionDescriptor： MethodType mtype = MethodType.methodType(void.class, MemoryAddress.class); FunctionDescriptor fdesc = FunctionDescriptor.ofVoid(C_POINTER); C语言中的所有指针类型在Java中都表示为MemoryAddress对象，对应的布局是C_POINTER，其大小取决于当前平台。客户端不会区分int*和char**，因为传递给CLinker的Java类型和内存布局包含足够的信息来正确地将Java参数传递给C函数 最后，与JNI不同的是，CLinker支持将结构化数据传递给外部函数。获取一个接受struct的无返回值C函数的向下调用方法句柄需要以下MethodType和FunctionDescriptor： MethodType mtype = MethodType.methodType(void.class, MemorySegment.class); MemoryLayout SYSTEMTIME = MemoryLayout.ofStruct( C_SHORT.withName(&quot;wYear&quot;), C_SHORT.withName(&quot;wMonth&quot;), C_SHORT.withName(&quot;wDayOfWeek&quot;), C_SHORT.withName(&quot;wDay&quot;), C_SHORT.withName(&quot;wHour&quot;), C_SHORT.withName(&quot;wMinute&quot;), C_SHORT.withName(&quot;wSecond&quot;), C_SHORT.withName(&quot;wMilliseconds&quot;) ); FunctionDescriptor fdesc = FunctionDescriptor.ofVoid(SYSTEMTIME); 对于高级别的MethodType签名，Java客户端总是使用不透明的类型MemorySegment，其中C函数需要一个按值传递的struct。对于低级别的FunctionDescriptor签名，与C结构类型相关联的内存布局必须是一个复合布局，它定义了C的struct中所有字段的子布局，包括可能由本地编译器插入的填充 如果C函数返回由低级别签名表示的按值struct，则必须在堆外分配一个新的内存段并返回给Java客户端。为了实现这一点，downcallHandle返回的方法句柄需要一个额外的SegmentAllocator参数，FFM API使用该参数分配内存段来保存C函数返回的struct。 为C函数打包Java参数不同语言之间的交互操作需要一个调用约定来指定一种语言中的代码如何调用另一种语言中的函数、如何传递参数以及如何接收任何结果。CLinker实现具有一些”开箱即用”的调用约定的知识：Linux/x64、Linux/AArch64、macOS/x64和Windows/x64。CLinker是用Java编写的，维护和扩展起来要比JNI容易得多，JNI的调用约定是硬连接到HotSpot的C++代码中的（译注：JNI的调用约定即JNIEnv*）。 考虑上面显示的SYSTEMTIME结构和布局的函数描述符（FunctionDescriptor）。根据运行JVM的操作系统和CPU的调用约定，当使用MemorySegment参数调用向下调用方法句柄时，CLinker使用函数描述符来推断结构体的字段应该如何传递给C函数。对于一个调用约定，CLinker可以安排分解传入的内存段，使用通用CPU寄存器传递前四个字段，并在C堆栈上传递其余字段。对于不同的调用约定，CLinker可以安排FFM API通过分配一个内存区域来间接传递结构体，将传入内存段的内容批量复制到该区域，并将指向该内存区域的指针传递给C函数。这种最低层次的参数打包是在幕后进行的，不需要任何客户端代码的监督。 向上调用有时，将Java代码作为函数指针传递给某个外部函数是很有用的。我们可以通过使用对上行调用的CLinker支持来实现这一点。在本节中，我们将逐块构建一个更复杂的示例，该示例演示了CLinker的全部功能，以及代码和数据跨Java/本地边界的完全双向互操作。 考虑标准C库中定义的以下函数： void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 为了从Java端调用qsort，我们首先需要创建向下调用方法句柄： MethodHandle qsort = CLinker.getInstance().downcallHandle( CLinker.systemLookup().lookup(&quot;qsort&quot;).get(), MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class), FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER) ); 和前面一样，我们使用C_LONG和long.class来映射C size_t类型，并且在第一个指针形式参数（数组指针）和最后一个形式参数（函数指针）上使用MemoryAddress.class。 qsort使用作为函数指针传递的自定义比较器函数compar对数组的内容进行排序。因此，要调用向下调用方法句柄，我们需要一个函数指针作为最后一个参数传递给方法句柄的invokeExact方法。CLinker::upcallStub通过使用现有的方法句柄帮助我们创建函数指针，如下所示。 首先，我们在Java中编写一个静态方法来比较两个long值，间接表示为MemoryAddress对象： class Qsort &#123; static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) &#123; return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue()) - MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue()); &#125; &#125; 接着，我们创建一个指向Java比较方法的MethodHandle： MethodHandle comparHandle = MethodHandles.lookup() .findStatic(Qsort.class, &quot;qsortCompare&quot;, MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)); 之后，现在我们有了Java比较器的方法句柄，我们可以使用CLinker::upcallStub创建函数指针。就像向下调用一样，我们使用CLinker类中的布局来描述函数指针的签名： MemoryAddress comparFunc = CLinker.getInstance().upcallStub(comparHandle, FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER), newImplicitScope()); ); 我们终于有了一个内存地址，comparFunc，它指向一个方法存根，可以用来调用我们的Java比较方法，所以现在我们有了调用qsort向下调用句柄所需的所有东西： MemorySegment array = MemorySegment.allocateNative(4 * 10, newImplicitScope()); array.copyFrom(MemorySegment.ofArray(new int[] &#123; 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 &#125;)); qsort.invokeExact(array.address(), 10L, 4L, comparFunc); int[] sorted = array.toIntArray(); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 这段代码创建了一个堆外数组，将Java数组的内容复制到其中，然后将数组连同我们从CLinker获得的比较器函数（指针）传递给qsort句柄。调用之后，堆外数组的内容将根据我们用Java编写的比较器函数进行排序。然后从段中提取一个新的Java数组，其中包含已排序的元素。 安全基本上，Java代码和本机代码之间的任何交互都可能危及Java平台的完整性。链接到预编译库中的C函数本质上是不可靠的，因为Java运行时不能保证函数的签名符合Java代码的期望，甚至不能保证C库中的标识是真正的函数。此外，如果链接了一个合适的函数，实际上调用该函数可能会导致如分段错误的底层故障，最终导致VM崩溃。Java运行时无法阻止此类故障，Java代码也无法捕获此类故障。 使用JNI函数的本地代码尤其危险。这样的代码可以在没有命令行标志（例如--add-open）的情况下，通过使用getStaticField和callVirtualMethod等函数访问JDK内部。它还可以在final字段初始化很久之后更改它们的值。它允许本地代码绕过应用于Java代码的检查，这会破坏JDK中的每个边界和假设。换句话说，JNI本质上就是不安全的。 JNI不能被禁用，因此无法确保Java代码不会调用使用危险的JNI函数的本地代码。这是对平台完整性的一种风险，应用程序开发人员和最终用户几乎看不到这种风险，因为这些函数99%的使用通常来自夹在应用程序和JDK之间的第三、第四和第五方库。 大多数FFM API的设计是安全的。过去需要使用JNI和本地代码的许多场景都可以通过调用不会危及Java平台的FFM API中的方法来实现。例如，JNI的一个主要用例——灵活的内存分配——是由一个简单的方法MemorySegment::allocateNative支持的，该方法不涉及本机代码，并且总是返回由Java运行时管理的内存。一般来说，使用FFM API的Java代码不会使JVM崩溃。 然而，FFM API的一部分本身就是不安全的。当与CLinker交互时，Java代码可以通过指定与底层C函数不兼容的参数类型来请求向下调用方法句柄。在Java中调用向下调用方法句柄会导致与在JNI中调用本机方法时相同的结果——VM崩溃或未定义的行为。FFM API也可以产生不安全的段，即内存段的空间和时间边界是用户提供的，这种段不能由Java运行时验证（参见上文的MemoryAddress::asSegment）。 FFM API中的不安全方法不会带来与JNI函数相同的风险：例如，它们不能更改Java对象中的final字段的值。另一方面，FFM API中的不安全方法很容易从Java代码中调用。由于这个原因，FFM API中不安全方法的使用受到限制：默认情况下，不安全方法的访问是禁用的，调用这些方法会抛出一个IllegalAccessException异常。要使某些模块M中的代码能够访问不安全的方法，请在命令行中指定java --enable-native-access=M。（在以逗号分隔的列表中指定多个模块；指定ALL-UNNAMED以允许类路径上的所有代码访问不安全方法）FFM API的大多数方法都是安全的，Java代码可以使用这些方法，不管是否给出了—enable-native-access。 我们在这里不建议限制JNI的任何方面。在Java中仍然可以调用本地方法，本地代码也可以调用不安全的JNI函数。然而，在未来的版本中，我们可能会以某种方式限制JNI。例如，不安全的JNI函数（如newDirectByteBuffer）可能会在默认情况下被禁用，就像FFM API中的不安全方法一样。更广泛地说，JNI机制是如此的危险，以至于我们希望库在安全和不安全的操作中偏向于纯Java的FFM API，这样我们就可以在默认情况下禁用所有JNI。这与使平台成为“开箱即用”的安全平台的更广泛的Java路线图一致，要求终端用户选择不安全的行为，如破坏强封装或链接到未知代码。 我们不建议以任何方式去修改sun.misc.Unsafe。FFM API对堆外内存的支持是对sun.misc.Unsafe中的malloc和free，即allocateMemory, setMemory, copyMemory，和freeMemory的一个很好的替代方案。我们希望需要非堆存储的库和应用程序采用FFM API，以便及时地弃用并最终删除这些sun.misc.Unsafe方法。 选择继续使用java.nio.ByteBuffer，sun.misc.Unsafe，JNI和其他第三方框架。 风险和假设创建一个API以既安全又高效的方式访问外部内存是一项艰巨的任务。由于前几节中描述的空间和时间检查需要在每次访问时执行，因此JIT编译器能够优化这些检查是至关重要的，例如，将它们提升到热循环之外。JIT实现可能需要做一些工作，以确保API的使用与ByteBuffer和Unsafe等现有API的使用一样有效和可优化。JIT实现还需要确保从API中检索到的本地方法句柄的使用至少与使用现有JNI本地方法一样有效和可优化。 依赖 外部函数和内存API可以用来访问非易失性内存，已经可以通过JEP 352（非易失性映射字节缓冲区，Non-Volatile Mapped Byte Buffers，Java 14引入）用一种更通用和更有效的方式访问 这里描述的工作可能会使后续工作能够提供一个工具，jextract，它从给定本地库的头文件开始，机械地生成与该库交互操作所需的本机方法句柄。这将进一步减少使用Java本地库的开销","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"JEP","slug":"JEP","permalink":"http://nickid2018.github.io/tags/JEP/"}]},{"title":"Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算","slug":"Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算","date":"2021-04-07T00:00:00.000Z","updated":"2021-08-29T00:00:00.000Z","comments":true,"path":"2021/04/07/Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算/","link":"","permalink":"http://nickid2018.github.io/2021/04/07/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BF%90%E7%AE%97/","excerpt":"","text":"前文我们说到了很多Visitor，它们用于给类中定义类型，添加字段，附上注释。但是对于一个语言来说，最重要的那一部分我们还没有说到——那就是：方法。 方法定义在ClassVisitor中，我们看到了有一个方法名为visitMethod，参数是(int，String，String，String，String[])，按照参数列表的顺序，它们分别指访问标志，方法名，方法描述符，泛型签名和抛出异常列表，返回一个MethodVisitor。（关于方法描述符，请看此系列的第一篇；关于访问标志，请看第二篇） 对于方法名，有下面的规则： 1.方法名不能是关键字或保留字（goto） 2.方法名不能以数字开头 3.可以为&lt;init&gt;和&lt;clinit&gt; 其中，&lt;init&gt;是构造函数，一个类可以有不止一个构造函数。而&lt;clinit&gt;每个类最多有一个，并且方法描述符必须为()V，它在类初始化阶段被JVM调用。（包括调用这个类的成员和Class.forName，但不包括Class.forName的initialize参数为false时的调用） 若方法名不正确，在尝试加载这个类的时候会抛出java.lang.ClassFormatError: Illegal method name。 抛出异常列表中，所有的类名称都为全限定名。 操作栈（Operand Stack）操作栈是一个方法被调用时JVM分配出来的一个栈空间，它用于存储方法内加载的数据和进行字节码指令操作。当JVM接收到一个字节码指令（例如iadd），就会取出栈顶的几项元素（对于iadd来说，就是栈顶的两项），在进行操作之后，将计算或获得的数据放回栈顶（比如iadd计算栈顶两个int的加和之后会放回加和数字）。 对于普通的对象，只会占用一个栈元素。但对于long或double这种对象，会占用两个栈元素。这有关于之后要介绍的visitMaxs。 如果一个字节码需要超过了现在操作栈内的元素数量的元素，那么在调用生成的方法时会抛出java.lang.VerifyError: Unable to pop operand off an empty stack。 如果一个字节码需要的类型与现在操作栈中元素类型不同，那么在调用生成的方法时抛出java.lang.VerifyError: Register &lt;slot&gt; contains wrong type或java.lang.VerifyError: Bad type on operand stack。 在之后的讲解中，我们会大量的使用这个名词，在接下来的编写中，操作栈的变化将会像下面这样写： 输入：XXX YYY 输出：ZZZ 局部变量表（Local Variable Table）局部变量表在方法调用中分配的另一个空间，用于存储现在方法内所有的局部变量，表中的数据可以被编号为0-n，叫Slot。普通的元素只会占用一个Slot，但long和double这种数据会占用两个。关于这个的详细使用，请看下面的xload和xstore的字节码介绍。 当这个方法为静态方法时，局部变量表会将参数列表中的变量按顺序放入局部变量表中。 当这个方法不是静态方法，局部变量表的0位是this，之后才会将参数列表变量依次放入表中。 如果局部变量表大小超过了256，那么字节码将会发生变化，xload、xstore等都会受到影响（需要以wide字节码辅助才能进行正常的局部变量读取写入）。但是ASM9中不提供wide字节码，因为MethodWriter中有ASM库自己的处理，所以在用户层编写ASM是无影响的。 MethodVisitor的方法在说完操作栈的概念之后，我们来看看MethodVisitor中都定义了哪些有关于字节码和执行的方法。 下面这些方法第一个参数都为字节码。 visitInsn(int)：访问一个零参数要求的字节码指令，如ACONST_NULL visitIntInsn(int, int)：访问一个需要零操作栈要求但需要有一个int参数的字节码指令，如BIPUSH visitVarInsn(int, int)：访问一个有关于局部变量的字节码指令，如ALOAD visitTypeInsn(int, String)：访问一个有关于类型的字节码指令，如CHECKCAST visitFieldInsn(int, String, String, String)：访问一个有关于字段的字节码，如PUTFIELD visitMethodInsn(int, String, String, String, boolean)：访问一个有关于方法调用的字节码，如INVOKESPECIAL visitJumpInsn(int, Label)：访问跳转字节码，如IFEQ 之后，是一些被包装好的字节码访问方法，这些方法都基于最基本的字节码指令，但是不需要我们自己用上面提到的那些方法直接调用字节码。 visitInvokeDynamicInsn(String, String, Handle, Object...)：基于INVOKEDYNAMIC，动态方法调用，会在lambda表达式和方法引用里面说到 visitLdcInsn(Object)：基于LDC、LDC_W和LDC2_W，将一个常量加载到操作栈用（详细见下文） visitIincInsn(int, int)：基于IINC、IINC_W，自增/减表达式 visitTableSwitchInsn(int, int, Label, Label...)：基于TABLESWITCH，用于进行table-switch操作 visitLookupSwitchInsn(Label, int[], Label[])：基于LOOKUPSWITCH，用于进行lookup-switch操作 visitMultiANewArrayInsn(String, int)：基于MULTIANEWARRAY，用于创建多重维度数组，如int[][] 在下文说到它们时，会以下面的方式表达： 方法：visitXXXInsn 参数：XXX YYY ZZZ 到这里，所有有关于字节码指令的方法就结束了。块级结构的方法会在下一篇说。 最后，说一下每个方法都要在最后调用的方法：visitMaxs(int, int)。它第一个参数是操作栈的最大大小，第二个是局部变量的个数。如果你调用这个方法时局部变量数量写小了，就会在生成方法调用时抛出java.lang.ClassFormatError: Arguments can&#39;t fit into locals，如果操作栈大小写小了，在生成方法调用时会抛出java.lang.VerifyError: Stack size too large 那么下面，我们将逐系列逐条讲解所有的字节码。这篇专栏先讲基本的操作栈加载存储等操作、常量获取和运算操作。 注意：接下来的x可以为a（针对对象）、i（针对int）、l（针对long）、f（针对float）、d（针对double）、b（针对byte）、c（针对char）、s（针对short），它代表了操作对象的类型。有些时候没有针对于byte和short的专用字节码，这是因为在JVM中，byte和short在被计算时会被强制拉长为int，所以它们使用的和int一样。char和int能互相转换。boolean类似，它们也需要使用int的字节码，而且boolean值的false就是int值0，而true就是int值1。 字节码介绍啥事都不干的字节码：nop输入：无 输出：无 方法：visitInsn 参数：无 使用范例： mv.visitInsn(NOP); 这个字节码啥都不干，在实际开发中可以当做代码插入点使用。 加载字节码：xload与xload_nx=a/i/l/f/d 输入：无 输出：某一对象或基本数据类型数据 方法：visitVarInsn 参数：加载对象的位置 使用范例： mv.visitVarInsn(ALOAD, 5); mv.visitVarInsn(FLOAD, 3); // 在javap反汇编中，此处变为fload_3 如果在调用此字节码时对应位置没有初始化变量（原先为参数或已经用xstore进行值的放入被视为该位置被初始化），在生成方法调用时会抛出java.lang.VerifyError: Accessing value from uninitialized register &lt;slot&gt;。 如果要进行加载的对象位置小于等于3，可以用对应的xload_n版本代替（注意，ASM9的Opcodes中已经不存在xload_n版本的字节码常量，但是在javap反汇编时可以看到此条），例如aload_2。 存储字节码：xstore与xstore_nx=a/i/l/f/d;n=0,1,2,3 输入：某一对象或基本类型数据 输出：无 方法：visitVarInsn 参数：存储对象的位置 使用范例： mv.visitVarInsn(ASTORE, 4); mv.visitVarInsn(ISTORE, 1); // 在javap反汇编中，此处变为istore_1 存储对象的位置规则与加载相同。与加载规则不同的是，xstore可以指定到一个未初始化的位置，并将这个位置初始化。有意思的一点是，你可以不遵循初始化位置的连续性，也就是说，假如2、3位置都未初始化，你可以通过xstore将对象放入3中并初始化它，这时位置2变为了未定义的状态，它在被xload加载时都会抛出java.lang.VerifyError: Register &lt;slot&gt; contains wrong type，即使你用的加载指令与放入指令类型相同。这时你只能通过另一次xstore将对象放入位置2，才能使这个位置类型固定。 和xload一样，xstore也有xstore_n版本，但ASM9已经不支持直接写入它们了。 返回字节码：(x)returnx=a/i/l/f/d 输入：某一对象或基本类型数据 输出：清空操作栈并返回 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ARETURN); mv.visitInsn(RETURN); // 无返回，用于void方法 返回字节码是每个方法必有的，包括void无返回值方法。如果一个方法没有写任何的返回字节码指令，在调用这个生成的方法时就会抛出java.lang.VerifyError: Falling off the end of the code。 返回字节码无视操作栈内剩余的所有值，只会将栈顶元素返回，并清除操作栈。 在这个方法为同步方法的前提下，所在线程不是已经锁定的监视器对象所有者时，这条指令会抛出IllegalMonitorStateException。这种情况在普通状况下根本无法发生，只有当这个同步方法上在其同步对象上使用了monitorexit却没有使用monitorenter时可能发生。 复制栈顶字节码：dup家族方法：visitInsn 参数：无 使用范例： mv.visitInsn(DUP); 每种字节码的解析： 1. DUP 输入：...v1 输出：...v1 v1 2. DUP_X1 输入：...v2 v1 输出：...v1 v2 v1 3. DUP_X2 输入：...v3 v2 v1 输出：...v1 v3 v2 v1 4. DUP2 输入：...v2 v1 输出：...v2 v1 v2 v1 5. DUP2_X1 输入：...v3 v2 v1 输出：...v2 v1 v3 v2 v1 6. DUP2_X2 输入：...v4 v3 v2 v1 输出：...v2 v1 v4 v3 v2 v1 这个字节码是用于复制栈顶元素并插入到栈中的字节码，可以节省xload和xstore的使用量。在这里，…指栈顶下的其他元素。 DUP家族的名称规律是：DUP后紧接着的数字代表了复制数量，Xn代表插入到栈顶下第几层。 弹出栈顶字节码：pop，pop2输入：一（pop）或两（pop2）个元素 输出：弹出栈顶一（pop）或两（pop2）个元素 方法：visitInsn 参数：无 使用范例： mv.visitInsn(POP); mv.visitInsn(POP2); 这个字节码也是用于操作操作栈的。它的使用情况举一个例子：调用了一个有返回值的方法但返回值我们不需要，就可以采用POP。 交换元素字节码：swap输入：两个元素 输出：交换栈顶两个元素 方法：visitInsn 参数：无 使用范例： mv.visitInsn(SWAP); 这个字节码可以交换栈顶的两个操作数。 常量池常量读取字节码：ldc（ldc_w, ldc2_w）输入：无 输出：从常量池读取出的数据 方法：visitLdcInsn 参数：常量值（见下文） [在JVM中，此处是常量池中对应常量的序号，长度分为三种，由三种LDC指令决定] 使用范例： mv.visitLdcInsn(&quot;helloworld&quot;); mv.visitLdcInsn(20.0f); // 注意，此处自动装箱成为Float mv.visitLdcInsn(Type.getType(&quot;I&quot;)); // 类型 常量池（Constant Pool）中，含有以下几种数据：整数Integer、浮点数Float、字符串字面值常量String、类的引用Type、句柄Handle或动态常量值ConstantDynamic，所以LDC值可能有这些。 在JVM中，如果常量值是Integer或Float，就会直接将它们放到操作栈顶；如果为String，将String类的引用放到操作栈顶；若为Type，将对应的类型初始化，并将其Class实例引用放到操作栈顶；对于Handle，将java.lang.invoke.MethodHandle/MethodType的引用至于操作栈顶。 在解析类型的引用期间（Type），这条指令可能会抛出有关于类加载的异常；同样的，解析有关于句柄（Handle）的时候也有可能抛出和句柄有关的异常。 空值常量字节码：aconst_null输入：无 输出：常量值null 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ACONST_NULL); 当程序中使用了null，就可以用这个字节码。 普通数字常量字节码：xconst_nx=i/l/f/d;对于iconst，n=m1,0,1,2,3,4,5;对于lconst、dconst，n=0,1;对于fconst，n=0,1,2 输入：无 输出：数字常量值，类型与字节码有关 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ICONST_M1); // -1 mv.visitInsn(FCONST_0); // +0.0f mv.visitInsn(LCONST_1); // 1L 当数字较小时，获得数字常量可以不使用LDC，可以直接用这些字节码代替（节省常量池空间）。 整数常量字节码：bipush和sipush输入：无 输出：数字常量值 方法：visitIntInsn 参数：某一具体整数 对于bipush，数字属于byte范围（-128~127） 对于sipush，数字属于short范围（-32768~32767） 使用范例： mv.visitIntInsn(BIPUSH, 27); // 27 mv.visitIntInsn(SIPUSH, -2700); // -2700 当一个数字没有超过这两个字节码规定的范围，我们都可以使用这两个字节码获取整数常量。在编译中，属于这个范围的数字都是用它们进行获取整数（除非是-1~5），而更大/小的整数都是用LDC。 说完了基本的加载存储常量指令，下面来看看程序的最基本功能：计算。 取反运算字节码：xnegx=i/l/f/d 输入：数字 输出：数字的相反数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(INEG); mv.visitInsn(DNEG); 这个字节码用于计算取反（-x）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于整数（int和long），计算规则就是(~x)+1，当它们处于MIN_VALUE时，取反结果仍为MIN_VALUE。 对于浮点数（double和float），这个字节码运算为： 取反与从零减去不等价，若x为+0.0，0.0-x结果为+0.0，而-x为-0.0 若数字为NaN（Not A Number，float的0x7fc00000或double的0x7ff8000000000000L），结果也为NaN 若数字为无穷大（float正0x7f800000负0xff800000，double正0x7ff0000000000000L负0xfff0000000000000L），结果为相反符号的无穷大 若数字为0，结果为相反符号的0 加法运算字节码：xaddx=i/l/f/d 输入：加数1 加数2 输出：数字的和 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IADD); mv.visitInsn(DADD); 这个字节码用于计算加法（a+b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于浮点数（double和float），这个字节码运算为： 如果两个数都为NaN，结果是NaN。 如果两个数为相反符号的无穷大，和为NaN 同一符号的无穷大结果是该符号的无穷大 有限值与无穷大的和还是无穷大 相反符号的两个0（+0.0和-0.0）结果为+0.0 相同符号的两个0和为该符号的0 0与非零值的和为非零值 符号相反，绝对值相等的有限值和为+0.0 若不属于上面的情况，结果将以IEEE 754舍入到最近可表示的浮点值。如果结果太大无法表示为浮点数（超过最大表示范围“溢出”，也就是绝对值超过float的3.4028235e+38f或double的1.7976931348623157e+308），结果为对应符号的无穷大；如果结果太小无法表示为浮点数（超过最小表示范围“下溢”，也就是绝对值小于float的1.4e-45f或double的4.9e-324），结果是对应符号的0。 减法运算字节码：xsubx=i/l/f/d 输入：被减数 减数 输出：两数字之差 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ISUB); mv.visitInsn(DSUB); 这个字节码用于计算减法（a-b），等价于a+(-b)。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 浮点数运算法则请同时参照xadd与xneg。 乘法运算字节码：xmulx=i/l/f/d 输入：乘数1 乘数2 输出：两数字之积 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IMUL); mv.visitInsn(DMUL); 这个字节码用于计算乘法（a*b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于浮点数（double和float），这个字节码运算为： 两个数字中有一个是NaN，结果为NaN 无穷大乘以一个0，结果为NaN 无穷大与有限值相乘，结果为无穷大，符号取决于两个数字的符号是否相同，相同为正，相反为负 其余情况为IEEE 754规定，在xadd那里有完整说明 除法运算字节码：xdivx=i/l/f/d 输入：被除数 除数 输出：两数字之商 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IDIV); mv.visitInsn(DDIV); 这个字节码用于计算除法（a/b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于整数（int和long），这个字节码只会保留商的整数部分。如果除数为0，这个字节码会抛出java.lang.ArithmeticException: / by zero 对于浮点数（double和float），这个字节码运算为： 两个数字中有一个是NaN，结果为NaN 无穷大除以无穷大，结果为NaN 无穷大除以有限值，结果为无穷大，符号取决于两个数字的符号（规则见xmul） 有限值除以无穷大，结果为0，符号同上 0除以0为NaN 0除以有限值为0，符号同上 有限值除以0为无穷大，符号同上 其余情况为IEEE 754规定，在xadd那里有完整说明 取余运算字节码：xremx=i/l/f/d 输入：被除数 除数 输出：余数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IREM); mv.visitInsn(DREM); 这个字节码用于计算取余操作（a%b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于浮点数（double和float），这个字节码运算为： 两个数字中有一个是NaN，结果为NaN 符号取决于被除数 被除数为无穷大或除数为0，结果为NaN 被除数为有限值而除数为无穷大，结果为被除数 被除数为0，结果为0 其余情况为IEEE 754规定，在xadd那里有完整说明 自增字节码：iinc（iinc_w）输入：无 输出：无 方法：visitIincInsn 参数：对象位置，自增大小（int范围） 使用范例： mv.visitIincInsn(0, 200); mv.visitIincInsn(1, -40); 自增字节码是适用于int的字节码，在以下情境中会用到: i++或i—或++i或—i i+=x或i-=x 自增字节码可以使用负数。 按位且运算字节码：xandx=i/l 输入：整数1 整数2 输出：按位且的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IAND); 这个字节码用于计算按位且操作（a&amp;b）。 按位或运算字节码：xorx=i/l 输入：整数1 整数2 输出：按位或的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LOR); 这个字节码用于计算按位或操作（a|b）。 按位异或运算字节码：xxorx=i/l 输入：整数1 整数2 输出：按位异或的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LXOR); 这个字节码用于计算按位或操作（a^b）。 同时，这个字节码还可以用于计算按位取反（这也是JVM的实现）：~x=x^(-1)。 mv.visitVarInsn(ILOAD, 0); mv.visitInsn(ICONST_M1); mv.visitInsn(IXOR); 按位左移运算字节码：xshlx=i/l 输入：整数 左移位数 输出：按位左移的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LSHL); 这个字节码用于计算按位左移操作（a&lt;&lt;b）。如果左移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行左移操作。 按位右移运算字节码：xshrx=i/l 输入：整数 右移位数 输出：按位右移的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ISHR); 这个字节码用于计算按位右移操作（a&gt;&gt;b）。如果右移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行右移操作。 按位无符号右移运算字节码：xushrx=i/l 输入：整数 右移位数 输出：按位无符号右移的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LUSHR); 这个字节码用于计算按位无符号右移操作（a&gt;&gt;&gt;b）。如果右移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行无符号右移操作。 运算字节码说完之后，最后，来看看数字转换的字节码。 转换为float的字节码：x2fx=i/l/d 输入：数字 输出：转换为float的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(I2F); 转换为float采取了IEEE 754的取值规律，详见xadd。虽然对于int，float转换是由低级拓宽范围，但是由于float值不能取到所有int可表示的数字（float仅有24位精确数字，其他为指数和符号位），所以此转换仍然不精确。 转换为double的字节码：x2dx=i/l/f 输入：数字 输出：转换为double的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(F2D); 转换为double采取了IEEE 754的取值规律，详见xadd。对于int，这种转换是完全精确的。对于float，如果这个方法是FP-Strict，也就是采取了ACC_STRICT修饰（Java中的strictfp），这个计算就是精确的；如果不是，这个计算可能进行舍入。对于long，由于double值不能取到long表示的所有数字（double仅有53位精确数字，其他为指数和符号位），所以计算不精确。 转换为int的字节码：x2ix=d/l/f 输入：数字 输出：转换为int的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(F2I); 由于int在四种数字中级别最低，long转换为它时都有可能丢失精度（甚至符号位），float和double会使用IEEE 754“向零舍入”。特殊情况下，如果浮点数的NaN转换为int，值为0；如果浮点数超出int最大范围，则为相应符号下的最大值。 转换为long的字节码：x2lx=i/f/d 输入：数字 输出：转换为long的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(D2L); 由于long级别大于int，int转换为long不丢失精度。在浮点数下，long与int的转换规则类似。 int转换为其他基本类型的字节码：i2xx=b/c/s 输入：数字 输出：转换为byte/char/short的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(I2B); 这三个字节码能分别将int缩小转换为byte（-128~127）、short（-32768~32767）和char（0~65535）。由于是缩小变换，可能丢失精度甚至符号位。 下面是使用例子：计算平方和Java代码如下： public static double computeSquare2(int x1, int x2)&#123; return x1 * x1 + x2 * x2; &#125; 使用ASM写入，如下： ClassWriter cw = new ClassWriter(ASM9); cw.visit(V1_8, ACC_PUBLIC, &quot;TestClass&quot;, null, &quot;java/lang/Object&quot;, null); MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;computeSquare2&quot;, &quot;(II)D&quot;, null, null); mv.visitVarInsn(ILOAD, 0); mv.visitInsn(DUP); mv.visitInsn(IMUL); mv.visitVarInsn(ILOAD, 1); mv.visitInsn(DUP); mv.visitInsn(IMUL); mv.visitInsn(IADD); mv.visitInsn(I2D); mv.visitInsn(DRETURN); mv.visitMaxs(3, 2); mv.visitEnd(); cw.visitEnd(); 将生成的类加载并调用，以参数100和21传入，结果为10441.0。 这篇博客到这里就结束了，下一期：Java ASM详解：MethodVisitor与Opcode（二）类、数组与调用 这篇文章一共讲了130个字节码呢~","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：ASM库使用","slug":"Java ASM详解：ASM库使用","date":"2021-02-13T00:00:00.000Z","updated":"2021-08-30T12:23:13.000Z","comments":true,"path":"2021/02/13/Java ASM详解：ASM库使用/","link":"","permalink":"http://nickid2018.github.io/2021/02/13/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AASM%E5%BA%93%E4%BD%BF%E7%94%A8/","excerpt":"","text":"几个月之后，终于来到了ASM的第二篇专栏（指直接咕了半年） 这篇专栏主要说一说ASM库怎么用，电脑端观看更佳。 读取的起源：ClassReaderClassReader位于org.objectweb.asm包下（基础类都在这个包），它是读取字节码的开始，通过它我们才能进行字节码解析。 首先是构造函数： public ClassReader(byte[] classFile) public ClassReader(byte[] classFileBuffer, int classFileOffset, int classFileLength) ClassReader(byte[] classFileBuffer, int classFileOffset, boolean checkClassVersion) public ClassReader(InputStream inputStream) throws IOException public ClassReader(String className) throws IOException 这几种构造函数都是以传入数据为目标的：前两个，根据传入的byte数组（第二个指定了偏移量和长度）解析类；倒数第二个，通过InputStream传入；倒数第一个，根据类的全限定名获得对象；中间的则是不开放的API，可以忽略。下面是使用的例子： ClassReader reader = new ClassReader(&quot;com/github/nickid2018/asm/TestClass&quot;); ClassReader reader2 = new ClassReader(classBytes, 0, 3370); ClassReader reader3 = new ClassReader(inputStreamClassFile); 说完了对象的构建，下面是它的用法。它最重要的方法是accept，其余的方法基本用不上（都内部自己用的） public void accept(ClassVisitor classVisitor, int parsingOptions) public void accept(ClassVisitor classVisitor, Attribute[] attributePrototypes, int parsingOptions) 先抛开Attribute[]这个参数，这个以后可能会说。第一个参数ClassVisitor是你要传入的访问器：ASM整体是Visitor设计模式。最后一个参数int是代表读取模式，它有4个基本取值，这些值可以被or（|）连接： 常量值 读取方式 SKIP_CODE 跳过代码属性 SKIP_DEBUG 跳过源文件、局部变量表、局部变量类型表、方法参数列表、行号 SKIP_FRAME 跳过帧（visitFrame），帧是JVM验证类阶段使用的数据 EXPANDS_FRAMES 扩展堆栈映射帧 下面是例子： ClassVisitor cv = ...; classReader.accept(cv, 0); classReader.accept(cv, ClassWriter.SKIP_CODE); 关于ClassReader的使用到这里差不多结束了，下面先讲一下访问标志，然后再说ClassVisitor等类。 访问标志（Access Flag）访问标志是用于JVM访问类、字段、方法检查和调用的一个int。这些标志既包含了我们常见的public这种访问限定符，还包含了static、final这种修饰符，除此之外还有声明类为接口的interface，为枚举的enum。 完整的访问标志如下表（省略了前缀ACC_）： Access Flag 常量值 修饰目标 用途 PUBLIC 0x0001 class, field, method 访问限定，公开 PRIVATE 0x0002 class, field, method 访问限定，私密 PROTECTED 0x0004 class, field, method 访问限定，受保护 STATIC 0x0008 field, method 静态 FINAL 0x0010 class, field, method, parameter 对于类为不可继承，对于其他为不可修改 SUPER 0x0020 class 调用invokespecial时会特殊处理超类方法 SYNCHRONIZED 0x0020 method 同步方法 OPEN 0x0020 module 指示模块为开放的 TRANSITIVE 0x0020 module requires 指示依赖于此模块的所有模块都隐式依赖此模块 VOLATILE 0x0040 field volatile字段，在内存中不会缓存 BRIDGE 0x0040 method “桥”方法，由编译器生成 STATIC_PHASE 0x0040 module requires 指示模块在编译时必须但运行时可选 VARARGS 0x0080 method 方法使用@SafeVarargs注解，与static或final连用 TRANSIENT 0x0080 field 被默认序列化忽略 NATIVE 0x0100 method 本地方法（JNI） INTERFACE 0x0200 class 声明类为接口，与abstract连用 ABSTRACT 0x0400 class, method 定义抽象类或抽象方法 STRICT 0x0800 method 严格浮点数定义（strictfp），可能在Java 17失效（？） SYNTHETIC 0x1000 class, field, method, parameter, module * 既不属于显性声明也不属于隐式声明，通常是编译器优化生成 ANNOTATION 0x2000 class 注解类型，与interface、abstract连用 ENUM 0x4000 class(?) field inner 枚举类或枚举字段 MANDATED 0x8000 field, method, parameter, module, module * 隐式声明的数据 MODULE 0x8000 class 声明这个类是模块定义类 JVM定义的Access Flags，真正我们能用到的不多，详见https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25 ASM自己也有定义Access Flag，由于JVM定义的有效位只有16位，所以这两个标志不会与JVM的访问标志冲突，但是这些标志在写入类之前必须清除（用&amp;操作即可） Access Flag 常量值 修饰目标 用途 RECORD 0x10000 class 记录类型（record） DEPRECATED 0x20000 class, field, method 弃用，要和@Deprecated连用 这些常量可以用or叠加修饰，如果访问标志不合法（比如吧ACC_PUBLIC和ACC_PRIVATE用or联系起来当了访问标志），在ASM写入时是不会报错的，但是在JVM试图加载这个类的时候可能会抛出ClassFormatError。 解析类的信息：ClassVisitorClassVisitor是一个抽象类，它的构造函数仅需要ASM API版本（在Opcodes中可以找到，1-9），或者再加上另一个ClassVisitor用于一起解析，下面是一个模板： public ClassParser(int api) &#123; super(api); &#125; public ClassParser() &#123; super(ASM9); &#125; 当这个Visitor被传入accept之后，ClassReader会以下面的顺序调用： visit [ visitSource ] [ visitModule ][ visitNestHost ][ visitPermittedSubclass ][ visitOuterClass ] ( visitAnnotation | visitTypeAnnotation | visitAttribute )* ( visitNestMember | visitInnerClass | visitRecordComponent | visitField | visitMethod )* visitEnd 不够清晰？那么下面简单说一下流程： 首先访问类的信息（visit），传入的是类文件的版本（version，从V1_1到V16）、访问标志（access），类的全限定名（name），泛型签名（signature，可能为空），父类全限定名（无指定为java/lang/Object），实现接口列表（全限定名，可为空） 之后访问注解信息（visitAnnotation），传入的是注解描述符（descriptor，这里可能包含有@Repeatable的注解类型，所以这里不是全限定名）和可见性（visible，@Retention定义的作用范围，为CLASS传入false，为RUNTIME传入true，为SOURCE不会写入类文件），该方法返回AnnotationVisitor。 同时，访问泛型注解信息（visitTypeAnnotation），传入的是注解引用类型（typeRef，可能为TypeReference定义的几个值：CLASS_TYPE_PARAMETER \\&lt;以泛型类的类型参数为目标的类型引用的类型，常量值0>，CLASS_EXTENDS \\&lt;以泛型类的超类或它实现的接口之一为目标的类型引用的类型，常量值16>，CLASS_TYPE_PARAMETER_BOUND \\&lt;以泛型类的类型参数的绑定为目标的类型引用的类型，常量值17>），泛型类引用路径（可为空），注解描述符和可见性，返回AnnotationVisitor。 接着，访问字段、方法和内部类。 字段调用visitField方法，传入访问标志，字段名，描述符，泛型签名和默认值，返回FieldVisitor。 方法调用visitMethod方法，传入访问标志，方法名，描述符，泛型签名和异常列表（全限定名），返回MethodVisitor。 内部类调用visitInnerClass方法，传入内部类全限定名，外部类全限定名，内部类名称（不带包路径，也就是没有“.”的名称，如果这个写错了IDE无法识别到这个类，但是不影响调用），和访问标志（这个和类声明定义的标志不同，可以有static，这样类里面就不会带有this$0）。内部类调用指的不只是类中定义了内部类，还包括引用到了其他类的内部类。 当所有信息都访问结束，调用visitEnd。 这里的内容只是简单介绍了一下，具体的下文和接下来几篇专栏会写。 解析注解信息：AnnotationVisitorAnnotationVisitor用于解析注解信息，除了最后会调用的visitEnd外，其他都与注解类型本身定义的方法返回值有关。下面是不同的类型： visit方法：传入注解方法名称和值，值必须是基本类型（基本数字、char及其数组，String和类） visitArray方法：传入注解方法名称，返回另一个AnnotationVisitor。这个新的Visitor会被传入数组内的值，所有的name传入都为null。注意：visit一个基本数字或char数组等价于使用visitArray，但是在ClassReader解析中不会调用visitArray而是直接调用visit。 visitAnnotation方法：传入注解方法名称和值的描述符，返回的是值的AnnotationVisitor。 visitEnum方法：传入注解方法名、值的描述符和枚举名称。 对于带有@Repeatable注解的注解类型，在Java使用反射时会返回容器注解，也就是在普通编写时有两种等价的编写方式。在ASM中，这两种方式也等价，写入按照第一种处理： @T.Ts(value = &#123; @T(value = &quot;ss&quot;), @T(value = &quot;dd&quot;) &#125;) public class A &#123; ... &#125; @T(value = &quot;ss&quot;) @T(value = &quot;dd&quot;) public class A &#123; ... &#125; 对于带有@Repeatable注解的注解类型，这两种使用方式在反射和ASM中完全等价（T.Ts是T的注解容器） 解析字段：FieldVisitorFieldVisitor的构成比较简单，除了visitEnd在最后调用外，比较常用的就是visitAnnotation和visitTypeAnnotation。这些方法的使用都和ClassVisitor的使用差不多，唯一的不同是visitTypeAnnotation的注解引用类型必为FIELD（常量值19） 到此简单的解析就讲完了。什么？还差一个MethodVisitor？这是我们之后要说的重要内容，所以这里不会提到它。接下来，是应用ASM的例子。 使用范例：解析一个类解析一个类需要从文章最开始说的ClassReader写起，它能将一个类的字节码解析并且进行Visitor模式调用。在下面的范例中，我们将尝试读取一个类的名称、字段和注解。 首先是一个测试类的编写，之后用javac编译。 package com.github.nickid2018.asm; public class TestClass &#123; @Deprecated public String string; public static int integer; &#125; 接着，我们尝试读取这个类的信息，因为测试类和运行ASM的类在同一个项目之下，可以用它的全限定名初始化ClassReader。 ClassReader reader = new ClassReader(&quot;com/github/nickid2018/asm/TestClass&quot;); 之后我们需要继承三个Visitor：ClassVisitor、FieldVisitor和AnnotationVisitor。我们只需要一些信息，所以不需要将它们的所有方法进行覆盖。 创建一个ClassParser继承ClassVisitor，选择要覆盖的方法。在访问类的时候，我们只需要类名，所以需要覆盖visit；又因为需要解析字段，我们还需要覆盖visitField，并且将我们的字段访问器作为返回值。 @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; super(version, access, name, signature, superName, interfaces); System.out.println(&quot;类名: &quot; + name); &#125; @Override public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) &#123; System.out.println(&quot;字段: &quot; + name + &quot; 描述符: &quot; + descriptor); return new FieldParser(); &#125; 创建FieldParser继承FieldVisitor解析字段。在读取字段时，我们还需要读取字段中的注解，所以需要覆盖visitAnnotation，返回我们自己的AnnotationVisitor。 @Override public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) &#123; System.out.println(&quot;注解: &quot; + descriptor + &quot; 可见性: &quot; + visible); return new AnnotationParser(); &#125; 由于@Deprecated不具有任何的注解方法，我们创建的AnnotationParser可以不覆盖任何方法。 这些访问器写完之后，就要递呈给ClassReader开始解析，代码如下： ClassParser cv = new ClassParser(); reader.accept(cv, 0); 现在，我们的解析程序就完成了。运行结果如下： 类名: com/github/nickid2018/asm/TestClass 字段: string 描述符: Ljava/lang/String; 注解: Ljava/lang/Deprecated; 可见性: true 字段: integer 描述符: I 代码样例：https://paste.ubuntu.com/p/8d6jN8jVzr/ 使用范例：生成一个类生成类我们用到的是ClassWriter，它本质上就是ClassVisitor，我们只要用可以构建类的数据按照刚才的格式传给它就能生成对应的类。 它的构造函数有两个，一个只传入一个int，它的值可为三个数：0、COMPUTE_MAXS和COMPUTE_FRAMES。那两个常量值是自动计算方法visitMaxs和visitFrame的，对于现在来说还用不到。另一个构造函数还需要传入ClassReader，这是下一部分可能用到的。 首先确定我们要构建产生的类： package com.github.nickid2018.asm; public class WillGenerate &#123; @Deprecated public static final int HELLO = 0; private String hi; &#125; 首先创建ClassWriter实例： ClassWriter cw = new ClassWriter(0); 接着，创建类，用到的正是visit方法。由于没有指定父类，这个类的父类将被强行指定为java/lang/Object，接口、抽象类、注解类型也如此。这个类没有实现任何接口，所以interfaces可以传null。同理，它没有泛型，所以泛型的signature为null。访问标志是public，再加上super，整体下来就是这句： cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, &quot;com/github/nickid2018/asm/WillGenerate&quot;, null, &quot;java/lang/Object&quot;,null); 接下来我们需要创建默认构造函数。javac编译时会把没有定义构造函数的普通类加入默认的构造函数。这种构造函数里面包括了父类构造函数调用和本身的非基本类型字段赋值。如果没有非基本类型字段赋值，那么它的代码就像这样： public WillGenerate() &#123; super(); &#125; 由于这篇专栏主要是有关于类、字段、注解的解析，方法的解析暂时先不讲，所以这里只给出它的写入代码，不做讲解。 public static void writeDefaultInit(ClassWriter cw) &#123; MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null); mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); mv.visitInsn(RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); &#125; 接下来写入HELLO这个字段。它的访问标志是public+static+final，由于它是弃用的，它也可以加上deprecated这个ASM自己定义的Access Flag。它的类型是int，所以描述符是I。没有泛型，所以signature为null。有默认值，为0。所以它的写入像这样： FieldVisitor fv = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC + ACC_DEPRECATED, &quot;HELLO&quot;, &quot;I&quot;, null, (Integer) 0); 保留这个FieldVisitor，因为它还具有一个注解@Deprecated。注解类型的描述符为Ljava/lang/Deprecated;。又因为@Deprecated的作用范围是RUNTIME，所以可见性为true，代码如下： AnnotationVisitor av = fv.visitAnnotation(&quot;Ljava/lang/Deprecated;&quot;, true); 这时，这个字段就写入信息就完成了，调用visitEnd。 av.visitEnd(); fv.visitEnd(); 下面写hi这个字段，和上面的差不多，直接给代码： fv = cw.visitField(ACC_PRIVATE, &quot;hi&quot;, &quot;Ljava/lang/String;&quot;, null, null); fv.visitEnd(); 这时候类的所有信息都已经写完了，调用ClassWriter的visitEnd。 cw.visitEnd(); 接下来调用ClassWriter的toByteArray获得字节码信息，写入到文件中就能得到类。 运行之后调用反编译器的结果： package com.github.nickid2018.asm; public class WillGenerate &#123; @Deprecated public static final int HELLO = 0; private String hi; &#125; 代码样例：https://paste.ubuntu.com/p/cqfDPVZbsH/ 使用范例：修改一个类修改类需要ClassReader和ClassWriter互相配合。利用ClassVisitor等进行数据的转移和修改。 接下来用ASM改一下我们的TestClass。 public class TestClass &#123; // 改为抽象类 @Deprecated public String string; // 重命名为str public static int integer; // 加上final和默认值10 &#125; 首先，创建ClassReader和ClassWriter。 ClassWriter cw = new ClassWriter(0); ClassReader cr = new ClassReader(&quot;com/github/nickid2018/asm/TestClass&quot;); 之后在我们的ClassParser里面改一下，传入一个ClassWriter，使用父类的第二个构造函数：以int，ClassVisitor为参数的构造函数。这样，ClassReader传入的信息可以直接写到ClassWriter里面，我们只需要修改我们所需要的方法就可以达到修改的效果，而不用将所有ClassVisitor的方法实现。 public ClassParser(ClassWriter cw) &#123; super(ASM9, cw); &#125; 接下来解决第一个修改：改为抽象类。这个我们可以在visit里面修改，将原先的访问标志加一个abstract就好。 @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; super.visit(version, access + ACC_ABSTRACT, name, signature, superName, interfaces); &#125; 第二个修改是重命名字段。这个在visitField里面判断就行，像下面一样： if (name.equals(&quot;string&quot;)) return super.visitField(access, &quot;str&quot;, descriptor, signature, value); 第三个就是修改为final和加默认值，也是在visitField里面改动： if (name.equals(&quot;integer&quot;)) return super.visitField(access + ACC_FINAL, name, descriptor, signature, (Integer) 10); 最后用accept传入ClassParser，输出文件就是改好的类文件。 cr.accept(new ClassParser(cw), 0); 生成之后，用反编译器看一下结果。 package com.github.nickid2018.asm; public abstract class TestClass &#123; @Deprecated public String str; public static final int integer = 10; &#125; 代码样例：https://paste.ubuntu.com/p/yXVvdJs3WH/ 这篇专栏到这里就结束了，下一期专栏：MethodVisitor和Opcode（一） 如果文章中有任何错误，可以在评论区留言，我将会修正错误。 如果使用ASM中有问题，可以在下面评论。","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解： 基础知识","slug":"Java ASM详解：基础知识","date":"2020-07-23T00:00:00.000Z","updated":"2021-08-29T00:00:00.000Z","comments":true,"path":"2020/07/23/Java ASM详解：基础知识/","link":"","permalink":"http://nickid2018.github.io/2020/07/23/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"ASM是什么，字节码又是什么 ASM是一个Java字节码分析、创建和修改的开源应用框架。它可以动态生成二进制格式的stub类或其他代理类，或者在类被Java虚拟机装入内存之前，动态修改类。在ASM中提供了诸多的API用于对类的内容进行字节码操作的方法。与传统的BCEL和SERL不同，在ASM中提供了更为优雅和灵活的操作字节码的方式 这是ASM官网上给出的没用解释，一句话概括：ASM是一个修改，分析Java类文件的框架。先抛开ASM框架的基本定义，先来看看字节码是什么 字节码（Byte-code）是一种包含执行程序，由一序列 op 代码/数据对组成的二进制文件 又是一段废话。从这里可以的知，字节码是一种介于翻译语言和底层语言的东西，与底层语言（C/C++）相比较你可以从它这里知道程序的运行方式，而与翻译语言（JavaScript）对比来看，你又无法从字节码中轻易看出什么。但是由于字节码的这个特性，我们得以修改它，操纵它，并且我们还可以反编译它。 官网：https://asm.ow2.io/ 添加ASM库依赖首先，是有关于ASM的Maven依赖&lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-all&lt;/artifactId&gt; &lt;version&gt;6.0_BETA&lt;/version&gt; &lt;/dependency&gt; 或者 &lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-commons&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-tree&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-analysis&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt; &lt;/dependency&gt; 如果使用第一种，那么你最高能依赖的版本是6.0_BETA。而第二种是现在仍在持续更新的，它相当于把原先的asm-all库分开成为不同的部分，但是基本的asm库是必须的。 这个库以后会详细讲述，这里先说几个强有力的工具。 帮助学习ASM的工具ASMifier: 自动生成ASM代码ASM库中有不少实用类，为了了解晦涩难懂的ASM代码，可以用ASMifier来进行解析。这是一个可执行类，你可以通过java.exe运行它。 注意：在9.0已经没有这个类了 运行方法：下载ASM的jar（比如asm-all-6.0_beta.jar）或者从你的.m2文件夹（asm-all）里面找到它，然后运行： java -classpath asm-all-6.0_BETA.jar org.objectweb.asm.util.ASMifier DemoDump.class 你会得到这样的输出： javap.exe: Java自带的字节码解析工具javap是你在安装JDK时就有的一个程序文件，是JDK的原生字节码解析工具，关于它的使用因篇幅有限不再细说，可以参考这篇文章 https://www.cnblogs.com/frinder6/articles/5440173.html Eclipse插件: Enhanced Class Decompiler这个插件是反编译器，可以在你没有库的源代码时反编译出源代码进行调试。当然，这个也可以作为你ASM程序的结果测试方案，通常反编译结果会很贴近于源代码，如果相差很大可以换一种方式反编译。 ASM中经常会用到的名词类(型)的不同名称 类的二进制名称/类全名/简单名称 这个三个名称是等价的，也就是我们平常说的类名，例如 java.lang.Thread java.lang.Thread$UncaughtExceptionHandler这样的名称。 全限定名 这个名称是用于class文件中的名称，其实就是将二进制名称的所有”.”换为”/“，这个名称只有非数组引用类型才有。例如 java/lang/Thread java/io/IOException。 类型描述符 类型描述符是有关于class文件内定义字段等的类型的名称。 类型描述符 原始类型的描述符一一对应 原始类型的描述符都对应相应的一个字母，具体来说是这样的： byte -&gt; B short -&gt; S int -&gt; I long -&gt; J float -&gt; F double -&gt; D char -&gt; C void -&gt; V boolean -&gt; Z 非数组的引用类型为 L+全限定名+; 数组引用类型为 [+数组内类型的描述符 例子: java.lang.Thread -&gt; Ljava/lang/Thread; java.lang.Object[] -&gt; [Ljava/lang/Object; int[][] -&gt; [[I 方法描述符了解类名称和类型描述符，下面讲一下方法描述符（其实类型描述符和方法描述符统称描述符） 方法描述符是class文件中保存参数类型列表和返回值类型的方式，在各种方法调用的操作码里面都会涉及到。 规则： 格式为 ( + 参数列表 + ) + 返回值 所有类型名称都为类型描述符 参数列表中不需要逗号分隔 下面是抽象含义下的具体例子（省略了参数名称，只保留了参数类型）： void a(int,int,int) -&gt; (III)V String s(double[],boolean) -&gt; ([DZ)Ljava/lang/String; int[] i(Object) -&gt; (Ljava/lang/Object;)[I void t() -&gt; ()V 操作码(OpCode)Opcode是用于JVM解释运行Java程序的关键。每一个Opcode都有自己独特的含义与操作，如0x60，助记符iadd，将两个int相加。 有一点要注意：操作码其实就是一个数字，我们平时经常看到的iadd，invokestatic并不是操作码，而是助记符。 而Java中字节码的名称也与操作码有关，因为每个操作码都是用一个字节，所以叫字节码。 每一个字节用来表示一个指令，理论上可以有 256 个操作码。 对于ASM库来说，所有的Opcode都存储于org.objectweb.asm.Opcodes里面，其中还有包括它们在什么方法中作用的注释。 有关于所有操作码的网页：https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html 这是ASM系列的第一篇，之后会持续更新。 bilibili专栏同步： https://www.bilibili.com/read/cv6875366","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"},{"name":"JEP","slug":"JEP","permalink":"http://nickid2018.github.io/tags/JEP/"}]}