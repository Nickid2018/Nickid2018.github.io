{"meta":{"title":"Nickid2018的博客","subtitle":"","description":"","author":"Nickid2018","url":"http://Nickid2018.github.io","root":"/"},"pages":[],"posts":[{"title":"JEP 412 Foreign Function & Memory (FFM) API 外部函数与内存API","slug":"JEP-412-Foreign-Function-Memory-FFM-API-外部函数与内存API","date":"2021-08-08T00:00:00.000Z","updated":"2021-08-30T11:30:21.000Z","comments":true,"path":"2021/08/08/JEP-412-Foreign-Function-Memory-FFM-API-外部函数与内存API/","link":"","permalink":"http://nickid2018.github.io/2021/08/08/JEP-412-Foreign-Function-Memory-FFM-API-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E5%AD%98API/","excerpt":"","text":"这篇专栏翻译自https://openjdk.java.net/jeps/412，”JEP 412: Foreign Function &amp; Memory API (Incubator)”，讲述了有关于Java 17中加入的FFM API。 前言引入一个可以让Java程序与Java运行时以外的代码和数据进行交换的API。通过高效的调用外部函数（即JVM外部的代码），并且通过安全地访问外部内存（即不是由JVM管理的内存），这套API能让Java程序调用本地库和操作本地数据的同时避免JNI的脆弱性和不安全性。 历史（略，请参照英文文档）目标 易用性 - 将Java本地接口（JNI）替换为优越的，纯Java开发的模型 性能 - 提供与现有 API（如 JNI 和 sun.misc.Unsafe）相媲美（如果不是更好的话）的性能 通用性 - 提供操作不同类型的外部内存（如：本地内存，永久内存和堆内存）的方法，并且随着时间的推移，去适应其他的平台（如：32bit x86）和除C以外的语言（如：C++,Fortran）编写的外部函数 安全性 - 在默认情况下禁用不安全的操作，仅在从应用程序开发人员或最终用户明确选择后才能禁用它们 非目标 在此 API 之上重新实现JNI，或以任何方式修改JNI 在此 API 之上重新实现传统 Java API，例如：sun.misc.Unsafe类 提供从本地代码头文件中自动生成 Java 代码的工具，或者 更改与本地库交互的 Java 应用程序的包装和部署方式（例如，通过多平台 JAR 文件） 动机（略，请参照英文文档）外部内存存储在Java运行时之外的内存的数据被称为堆外数据(off-heap data)。”heap”（堆）是Java对象生存（对象生命周期）的地方，也是垃圾回收（Garbage Collector，GC）处理的地方。访问堆外数据对于Tensorflow、Ignite、Lucene和Netty等Java库的性能至关重要，这主要是因为这避免了由垃圾回收引起的成本和不可预测性，并且这也允许程序通过mmap等将文件映射入内存中进行数据结构的序列化和反序列化。但是，Java平台到今天没有为访问堆外数据提供令人满意的解决方案。 ByteBuffer API（java.nio）允许创建直接缓冲区（direct buffer），这些缓冲区在堆外分配，但是它们的最大大小限制为2GB并且不能及时释放。这些和其他的限制都来源于一个事实：ByteBuffer API不仅被用于访问堆外内存，还被用于生产者/消费者之间批量数据的交换，如字符集的编码/解码和部分I/O操作。在这方面，它无法满足多年来提出的许多堆外内存增强请求。 sun.misc.Unsafe API暴露了堆内内存的访问操作，这对堆外内存也适用。使用它很高效，因为它的内存操作被定义在HotSpot JVM内部并且会被JIT编译器优化。但是，因为它可以访问任何内存位置，使用它是危险的。这意味着一个Java程序可以通过访问一个已经释放的内存位置使JVM崩溃。因为这个和其他的原因，使用Unsafe是强烈不被推荐的。 使用JNI调用本地库来访问堆外内存是可能的，但是因为它的效率开销（较高）而很少找到适用的地方：从Java到本地代码的速度要比直接访问内存的速度慢几个数量级，因为JNI方法调用并不能从常见的JIT优化（如内联）中获益。 总之，当访问堆外数据时，Java开发者就面临着两难的境地：他们是选择安全但效率不高的方式（ByteBuffer API）还是放弃安全转而选择性能（Unsafe API）？开发者需要的是一个Java支持的API，用于在JIT优化下从头到脚安全地访问堆外数据（即外部内存）。 外部函数从Java 1.1开始，JNI就已经支持本地代码的调用（即外部函数），但是因为很多原因它并不适合。 JNI涉及几个乏味的构件:Java API（本地方法）、源自Java API的C头文件（译注：即javah.exe的工作，当Java 10移除javah.exe后，这项工作由javac -h完成），以及调用感兴趣的本地库的C实现。Java开发人员必须跨多个工具链工作，以保持与平台相关的构件同步，当本地库快速发展时，这尤其繁重。 JNI只能与以一些语言（通常为C/C++）进行交互，这些库使用了JVM在构建中使用的操作系统和CPU的约定。本地方法不能被用于去调用一个由不同约定的语言编写的函数。 JNI没有协调Java类型系统和C类型系统。Java中的聚合数据是用对象表示的，但C中的聚合数据是用结构体表示的，因此传递给本地方法的任何Java对象都必须费力地由本地代码解包。例如，考虑一个Java中的记录（record，Java 16加入）类Person：将Person对象传递给本地方法将要求本地代码使用JNI的C API从对象中提取字段（例如，firstName和lastName）（译注：提取字段就是使用JNIEnv*的函数）。结果是，Java开发者们有些时候会把他们的数据转变成一个单独的对象（如：一个字节数组或一个direct ByteBuffer），但更常见的是，因为通过JNI传递Java对象很慢，他们就使用Unsafe API去分配堆外内存并且以long的形式将内存地址传递给本地方法（译注：比如LWJGL）——可悲的是这使得Java代码变得不安全！ 多年来，有许多框架填补JNI留下的空白，这其中包括JNA、JNR和JavaCPP。虽然这些框架通常被视为JNI的改进，但是情况依旧不理想，尤其是当与提供一流的本地代码交互的语言相比。比如，Python的ctypes包可以动态地将函数包装在本地库中而不用生成任何的粘合代码。其他语言，例如Rust，提供了可以从C/C++头文件中自动派生本地代码包装的工具。 总之，Java开发者应该有一个让他们能直接使用任何被认为对特定任务有用的本机库并且避免使用JNI带来的繁琐与沉闷的API。对于此的一个绝佳的抽象是方法句柄（Method Handle），它在Java 7被引入，用于支持在JVM上的快速动态语言（invokedynamic，inDy）。通过方法句柄公开本机代码将从根本上简化编写、构建和分发依赖于本机库的Java库的任务。此外，能够建模外部函数（即本机代码）和外部内存（即堆外数据）的API将为第三方本机交互框架提供坚实的基础。 描述外部函数与内存API（Foreign Function &amp; Memory API，下文简称为”FFM API”）定义了一系列类与接口以便于在库与应用程序中的客户端代码： 分配外部内存（MemorySegment，MemoryAddress和SegmentAllocator）,操作和访问结构化外部内存（MemoryLayout，MemoryHandles和MemoryAccess），管理外部资源的生命周期（ResourceScope）和调用外部函数（SymbolLookup和CLinker） FFM API定义在jdk.incubator.foreign模块下的jdk.incubator.foreign包内。 例子下面是一个简单的使用FFM API的例子，Java代码获得了一个C库函数radixsort的方法句柄，然后用它来对Java数组中的四个字符串进行排序（一些细节被省略了）： 1234567891011121314151617181920212223// 1. 在C库路径下寻找外部函数MethodHandle radixSort = CLinker.getInstance().downcallHandle( CLinker.systemLookup().lookup(&quot;radixsort&quot;), ...);// 2. 分配堆内内存储存4个字符串String[] javaStrings = &#123; &quot;mouse&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;car&quot; &#125;;// 3. 分配堆外内存储存4个指针MemorySegment offHeap = MemorySegment.allocateNative( MemoryLayout.ofSequence(javaStrings.length, CLinker.C_POINTER), ...);// 4. 将字符串从堆内复制到堆外for (int i = 0; i &lt; javaStrings.length; i++) &#123; // 分配一个堆外的字符串， 然后储存一个指向它的指针 MemorySegment cString = CLinker.toCString(javaStrings[i], newImplicitScope()); MemoryAccess.setAddressAtIndex(offHeap, i, cString.address());&#125;// 5. 通过调用外部函数将堆外数据排序radixSort.invoke(offHeap.address(), javaStrings.length, MemoryAddress.NULL, &#x27;\\0&#x27;);// 6. 将（已经排序后）的字符串数组从堆外复制到堆内for (int i = 0; i &lt; javaStrings.length; i++) &#123; MemoryAddress cStringPtr = MemoryAccess.getAddressAtIndex(offHeap, i); javaStrings[i] = CLinker.toJavaStringRestricted(cStringPtr);&#125;assert Arrays.equals(javaStrings, new String[] &#123;&quot;car&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;mouse&quot;&#125;); // true 这段代码比任何使用JNI的解决方案都清晰得多，因为原本隐藏在本机方法调用后面的隐式转换和内存解引用现在直接用Java表示了。也可以使用现代Java语言特性；例如，流可以允许多个线程并行地在堆内和堆外内存之间复制数据。 内存段（Memory Segments）内存段是对位于堆外或堆内的连续内存区域进行建模的抽象。内存段可以为 本地段，在本地内存内从头开始分配（例如通过malloc），映射段，将映射包装在本地内存区域中（例如通过mmap），或者数组或缓冲区段，将现有的Java数组或字节缓冲区相关的内存分别包装 所有的内存段都提供了空间、时间和线程限制的保证，为了使内存解引用操作安全，这些保证都是强制的。例如，下面的代码在堆外分配了100个字节： 1MemorySegment segment = MemorySegment.allocateNative(100, newImplicitScope()); 段的空间边界决定了与段相关联的内存地址的范围。上面代码中段的边界由表示为MemoryAddress实例的基础地址b和以字节为单位的大小（100）定义，结果是地址范围从b到b + 99（包括b + 99）。 段的时间边界决定了段的生存期，也就是这个段什么时候会被释放。段的生存期和线程限制状态是通过ResourceScope抽象建模的，下面将对此进行讨论。上面代码中的资源作用域是一个新的隐式作用域，它确保当垃圾回收器认为MemorySegment对象不可达时才释放与此段相关的内存。隐式作用域还确保可以从多个线程访问内存段。 换句话说，上面的代码创建了一个行为与allocateDirect工厂分配的ByteBuffer的行为紧密匹配的段。FFM API还支持还支持确定性内存释放和其他线程限制选项，将在下面讨论。 解引用内存段与段关联的内存解引用是通过获取变量句柄来实现的，它是Java 9中引入的数据访问抽象模型。特别地，段是用内存访问变量句柄来解引用的。这种类型的变量句柄使用一对访问坐标： 以MemorySegment对象表示的坐标——也就是控制的内存要被解引用的段，和以long表示的坐标——也就是偏移量（offset），从段的基础地址到解引用开始的偏移量 内存访问变量句柄可以通过在MemoryHandles类中的工厂方法获取。例如，这段代码获取了可以将int写入本地内存段的内存访问变量句柄，并且使用它在连续的偏移下写入25个4字节的值（译注：指int为4字节）： 12345MemorySegment segment = MemorySegment.allocateNative(100, newImplicitScope());VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());for (int i = 0; i &lt; 25; i++) &#123; intHandle.set(segment, /* 偏移 */ i * 4, /* 要写入的数据 */ i);&#125; 更高级的访问用法可以通过使用MemoryHandles类提供的一个或多个组合子方法来组合内存访问变量句柄来表达。使用这些客户端可以，例如，对给定的内存访问变量句柄进行重排序，删除一个或多个坐标，或插入新的坐标。这允许创建接受一个或多个逻辑索引到一个在堆外内存区域的多维数组中的内存访问变量句柄。 为了使FFM API更容易访问，MemoryAccess类提供了静态访问器来解引用内存段，而不需要构造内存访问变量句柄。例如，有一个访问器可以在给定偏移量的段中设置一个int值，允许上面的代码简化为： 1234MemorySegment segment = MemorySegment.allocateNative(100, newImplicitScope());for (int i = 0; i &lt; 25; i++) &#123; MemoryAccess.setIntAtOffset(segment, i * 4, i);&#125; 内存布局（Memory Layouts）为了减少对内存布局的繁琐计算(例如，上面例子中的i * 4)， MemoryLayout可以用更声明式的方式来描述内存段的内容。例如，上面例子中需要的本地内存段的布局可以用以下方式描述： 123SequenceLayout intArrayLayout = MemoryLayout.sequenceLayout(25, MemoryLayout.valueLayout(32, ByteOrder.nativeOrder())); 这将创建一个序列内存布局（sequence memory layout），内部由重复了25次的32比特值布局（一个描述了单一32字节值的布局）构成。给定一个内存布局，我们可以避免在代码中计算偏移量，并简化内存分配和创建内存访问变量句柄： 123456MemorySegment segment = MemorySegment.allocateNative(intArrayLayout, newImplicitScope());VarHandle indexedElementHandle = intArrayLayout.varHandle(int.class, PathElement.sequenceElement());for (int i = 0; i &lt; intArrayLayout.elementCount().getAsLong(); i++) &#123; indexedElementHandle.set(segment, (long) i, i);&#125; intArrayLayout对象通过创建布局路径来驱动内存访问变量句柄的创建，该路径用于从复杂布局表达式中选择嵌套布局。intArrayLayout对象也驱动了本地内存段的分配，这个内存段基于来自于布局的大小和对齐信息。在之前的例子中的循环常数，也就是25，已经被序列布局的元素数量所替代。 资源作用域（Resource Scopes）在前面的例子中看到的所有内存段都使用了非确定性的释放：一旦内存段实例变得不可达，垃圾收集器就会释放与这些段相关的内存。我们说这样的段是隐式释放的。 在某些情况下，客户端可能希望控制何时发生内存释放。试想，例如，使用MemorySegment::map从一个文件中映射出一个很大的内存段。客户端可能更喜欢在段不再需要时释放（即取消映射）与段相关的内存，而不是等待垃圾收集器这样做，因为等待可能会对应用程序的性能产生不利影响。 内存段支持通过资源作用域的确定性释放。资源作用域对与一个或多个资源（如内存段）相关联的生命周期进行建模。新创建的资源作用域处于活动状态，这意味着可以安全地访问它管理的所有资源。在客户端请求时，可以关闭资源作用域，这意味着不再允许访问由该作用域管理的资源。因为ResourceScope类实现了AutoClosable接口，所以它可以使用try-with-resource语句： 123456try (ResourceScope scope = ResourceScope.newConfinedScope()) &#123; MemorySegment s1 = MemorySegment.map(Path.of(&quot;someFile&quot;), 0, 100000, MapMode.READ_WRITE, scope); MemorySegment s2 = MemorySegment.allocateNative(100, scope); ...&#125; // 这两个内存段到这里被释放 这段代码创建了一个受限（confined）的资源作用域，并将其用于创建两个段：映射段（s1）和本地段（s2）。这两个段的生命周期与资源作用域的生命周期相关联，因此在try-with-resources语句完成后访问段（例如，使用内存访问变量句柄对它们进行解引用）将导致抛出一个运行时异常。 除了管理内存段的生命周期外，资源作用域还可以作为一种方法来控制哪些线程可以访问内存段。受限资源作用域只允许创建作用域的线程的访问，而共享资源作用域允许从任何线程访问。 资源作用域，无论是受限的还是共享的，都可能与java.lang.ref.Cleaner对象相关联，该对象负责执行隐式释放，以防在客户端调用close方法之前，资源作用域对象变得不可达。 一些称为隐式资源作用域的资源作用域不支持显式释放——调用close将失败。隐式资源作用域总是使用Cleaner来管理它们的资源。隐式作用域可以使用ResourceScope::newImplicitScope工厂创建，如前面的示例所示。 段分配器（Segment Allocators）当客户端使用堆外内存时，内存分配通常是一个瓶颈。FFM API包括一个SegmentAllocator抽象模型，它定义了分配和初始化内存段的操作。段分配器是通过SegmentAllocator接口中的工厂获得的。例如，下面的代码创建了一个基于区域（arena-based）的分配器，并使用它来分配一个内容是从Java int数组初始化的段： 12345678try (ResourceScope scope = ResourceScope.newConfinedScope()) &#123; SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope); for (int i = 0 ; i &lt; 100 ; i++) &#123; MemorySegment s = allocator.allocateArray(C_INT, new int[] &#123; 1, 2, 3, 4, 5 &#125;); ... &#125; ...&#125; // 所有分配的内存在此处被释放 这段代码创建一个受限的资源范围，然后创建与该范围相关联的无边界区域分配器（unbounded arena allocator）。这个分配器将分配特定大小的内存块，并通过返回预先分配的内存块的不同片（译注：也就是分配器先分配一定大小的块后，用户要求内存时按用户需求在内存块中取出相当长度的内存切片）来响应分配请求。如果一个内存块没有足够的空间来容纳一个新的分配请求，那么就分配一个新的内存块。如果与区域分配器相关联的资源作用域被关闭，所有与分配器创建的段相关联的内存（例如，在for循环体中）都会被以原子方式释放。这种用法结合了ResourceScope抽象提供的确定性释放的优点，以及更灵活和可伸缩的分配方案。在编写管理大量堆外内存段的代码时，它非常有用。 不安全的内存段到目前为止，我们已经看到了内存段、内存地址和内存布局。解引用操作只能在内存段上进行。由于内存段具有空间和时间边界，Java运行时总是可以确保与给定段相关联的内存被安全解引用。然而，在某些情况下，客户端可能只有MemoryAddress实例，这在与本机代码交互时经常发生。由于Java运行时无法知道与内存地址相关的空间和时间边界，因此FFM API禁止直接解引用内存地址。 为了解引用内存地址，客户端有两种选择： 如果已知地址位于一个内存段，客户端可以通过MemoryAddress::segmentOffset进行重新基准（rebase）操作。重新基准操作会重新定义地址相对于段的基本地址的偏移量，以产生一个新的可以应用于现有段上的偏移量——然后可以安全地对该段解引用。 或者，如果没有这样的段存在，那么客户端可以使用MemoryAddress::asSegment工厂不安全地创建一个。这个工厂有效地将新的空间和时间边界附加到一个原始的内存地址，以便允许解引用操作。该工厂返回的内存段是不安全的：一个原始内存地址可能与一个10字节长的内存区域相关联，但客户端可能意外地高估了该区域的大小，并创建了一个100字节长的不安全内存段。这可能会导致稍后试图对与不安全段关联的内存区域边界之外的内存的解引用，这可能会导致JVM崩溃，或者更糟的是，导致在无形中的内存损坏。因此，创建不安全的段被视为受限操作，默认情况下是禁用的（参见下面的详细内容）。 寻找外部函数任何对外部函数的支持的第一个组成部分都是加载本地库的机制。在JNI中，这是通过System::loadLibrary和System::load方法完成的，它们在内部映射到对dlopen或其等效函数的调用。使用这些方法加载的库总是与类加载器（即调用System方法的类加载器）相关联。库和类加载器之间的关联是至关重要的，因为它管理装入的库的生命周期：只有当类加载器不再可访问时，它的所有库才能被安全卸载。 FFM API没有提供加载本地库的新方法。开发者使用System::loadLibrary和System::load方法来加载将通过FFM API调用的本地库。库和类加载器之间的关联被保留，因此库将以与JNI相同的可预测方式卸载。 与JNI不同，FFM API提供了在加载的库中查找给定标识地址的功能。这种由SymbolLookup对象表示的功能对于将Java代码链接到外部函数至关重要（参见下面）。有两种方法可以获得SymbolLookup对象： SymbolLookup::loaderLookup返回一个包括本加载器内加载的所有库内部的标识的查找器 CLinker::systemLookup返回一个特定于平台的标识查找器，它能查找标准C库内的标识 给定一个标识查找器，客户端可以使用SymbolLookup::lookup(String)方法找到一个外部函数。如果指定的函数出现在标识查找器所包括的标识中，则该方法返回指向函数入口点的MemoryAddress。例如，下面的代码加载OpenGL库（使它与当前类加载器相关联），并找到它的glGetString函数的地址： 123System.loadLibrary(&quot;GL&quot;);SymbolLookup loaderLookup = SymbolLookup.loaderLookup();MemoryAddress clangVersion = loaderLookup.lookup(&quot;glGetString&quot;).get(); 将Java代码链接到外部函数CLinker接口是Java代码与本地代码交互的核心。虽然CLinker专注于提供Java和C库之间的互操作，但接口中的概念已经足够通用，可以在未来支持其他非Java语言。该接口支持向下调用（downcall，从Java代码调用本地代码）和向上调用（upcall，从本地代码调用回Java代码）。 12345678interface CLinker &#123; MethodHandle downcallHandle(MemoryAddress func, MethodType type, FunctionDescriptor function); MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);&#125; 对于向下调用，downcallHandle方法接受外部函数的地址——通常是从库查找中获得的MemoryAddress——并将外部函数作为向下调用方法句柄公开。稍后，Java代码通过调用invokeExact方法调用downcall方法句柄，然后运行外部函数。传递给方法句柄的invokeExact方法的任何参数都会传递给外部函数。 对于上行调用，upcallStub方法接受一个方法句柄——通常是指一个Java方法句柄，而不是下行调用方法句柄——并将其转换为内存地址。稍后，当Java代码调用downcall方法句柄时，将内存地址作为参数传递。实际上，内存地址充当函数指针。（欲了解更多关于upcall的信息，请参阅下面） 假设我们想从Java向下调用定义在C标准库中的strlen函数： 1size_t strlen(const char *s); 一个暴露strlen的向下调用方法句柄可以像下面这样获取（关于MethodType和FunctionDescriptor的细节将会简短介绍）： 12345MethodHandle strlen = CLinker.getInstance().downcallHandle( CLinker.systemLookup().lookup(&quot;strlen&quot;).get(), MethodType.methodType(long.class, MemoryAddress.class), FunctionDescriptor.of(C_LONG, C_POINTER)); 调用向下调用方法句柄会执行strlen并且让结果在Java端可见。对于strlen的参数，我们使用一个helper方法将Java的字符串转变为堆外内存段并且传递这个段的地址： 12MemorySegment str = CLinker.toCString(&quot;Hello&quot;, newImplicitScope());long len = strlen.invokeExact(str.address()); // 5 方法句柄在公开外部函数时工作得很好，因为JVM已经优化了方法句柄的调用，一直优化到本地代码。当方法句柄引用类文件中的方法时，调用方法句柄通常会导致目标方法被JIT编译；随后，JVM通过将控制转移到为目标方法生成的汇编代码来解释调用MethodHandle::invokeExact的Java字节码。因此，调用传统方法句柄已经几乎是外部调用；以C库中的函数为目标的downcall方法句柄只是一种更外部的方法句柄形式。方法句柄还具有一个名为签名多态性的属性，该属性允许基本类型参数的非装箱传入（译注：就是直接传int而不是Integer避免装箱/拆箱操作）。总之，方法句柄让CLinker以一种自然、有效和可扩展的方式公开外部函数。 在Java中描述C类型为了创建向下调用方法句柄，FFM API需要客户端提供对于目标C函数的两种签名：使用非透明的Java对象（MemoryAccess和MemorySegment）的高级别签名和使用透明的Java对象（MemoryLayout）的低级别签名。依次取每个签名： 高级别签名，即MethodType，用作向下调用方法句柄的类型。每个方法句柄都是强类型的，这意味着可以传递给它的invokeExact方法的参数的数量和类型是严格的。例如，为接受一个MemoryAddress参数而创建的方法句柄不能通过invokeExact(MemoryAddress, MemoryAddress)或通过invokeExact(“Hello”)调用。因此，MethodType描述了客户端在调用向下调用方法句柄时必须使用的Java签名。实际上，它是C函数的Java视图。 低级别签名，即FunctionDescriptor，包含MemoryLayout对象。这使CLinker能够精确地理解C函数的参数，以便它能够正确地安排它们，如下所述。客户端通常有MemoryLayout对象，以便解引用外部内存中的数据，这样的对象可以在这里作为外部函数签名重用。 例如，为接受int值并返回long值的C函数获取向下调用方法句柄时，downcallHandle方法需要以下MethodType和FunctionDescriptor参数： 12MethodType mtype = MethodType.methodType(long.class, int.class);FunctionDescriptor fdesc = FunctionDescriptor.of(C_LONG, C_INT); 这个例子的目标系统是Linux/x64和macOS/x64，其中Java类型long和int分别与预定义的CLinker布局C_LONG和C_INT关联。Java类型与内存布局的关联因平台而异：例如，在Windows/x64上，Java long与C_LONG_LONG布局相关联 译注：这里的原因是C中long的位数取决于系统，而long long为确定64位；在Java中，int确定32位而long为64位，为了确保数据的对齐需要调整布局 另一个例子，获取一个带有指针的void C函数的向下调用方法句柄需要以下MethodType和FunctionDescriptor： 12MethodType mtype = MethodType.methodType(void.class, MemoryAddress.class);FunctionDescriptor fdesc = FunctionDescriptor.ofVoid(C_POINTER); C语言中的所有指针类型在Java中都表示为MemoryAddress对象，对应的布局是C_POINTER，其大小取决于当前平台。客户端不会区分int*和char**，因为传递给CLinker的Java类型和内存布局包含足够的信息来正确地将Java参数传递给C函数 最后，与JNI不同的是，CLinker支持将结构化数据传递给外部函数。获取一个接受struct的无返回值C函数的向下调用方法句柄需要以下MethodType和FunctionDescriptor： 12345678MethodType mtype = MethodType.methodType(void.class, MemorySegment.class);MemoryLayout SYSTEMTIME = MemoryLayout.ofStruct( C_SHORT.withName(&quot;wYear&quot;), C_SHORT.withName(&quot;wMonth&quot;), C_SHORT.withName(&quot;wDayOfWeek&quot;), C_SHORT.withName(&quot;wDay&quot;), C_SHORT.withName(&quot;wHour&quot;), C_SHORT.withName(&quot;wMinute&quot;), C_SHORT.withName(&quot;wSecond&quot;), C_SHORT.withName(&quot;wMilliseconds&quot;));FunctionDescriptor fdesc = FunctionDescriptor.ofVoid(SYSTEMTIME); 对于高级别的MethodType签名，Java客户端总是使用不透明的类型MemorySegment，其中C函数需要一个按值传递的struct。对于低级别的FunctionDescriptor签名，与C结构类型相关联的内存布局必须是一个复合布局，它定义了C的struct中所有字段的子布局，包括可能由本地编译器插入的填充 如果C函数返回由低级别签名表示的按值struct，则必须在堆外分配一个新的内存段并返回给Java客户端。为了实现这一点，downcallHandle返回的方法句柄需要一个额外的SegmentAllocator参数，FFM API使用该参数分配内存段来保存C函数返回的struct。 为C函数打包Java参数不同语言之间的交互操作需要一个调用约定来指定一种语言中的代码如何调用另一种语言中的函数、如何传递参数以及如何接收任何结果。CLinker实现具有一些”开箱即用”的调用约定的知识：Linux/x64、Linux/AArch64、macOS/x64和Windows/x64。CLinker是用Java编写的，维护和扩展起来要比JNI容易得多，JNI的调用约定是硬连接到HotSpot的C++代码中的（译注：JNI的调用约定即JNIEnv*）。 考虑上面显示的SYSTEMTIME结构和布局的函数描述符（FunctionDescriptor）。根据运行JVM的操作系统和CPU的调用约定，当使用MemorySegment参数调用向下调用方法句柄时，CLinker使用函数描述符来推断结构体的字段应该如何传递给C函数。对于一个调用约定，CLinker可以安排分解传入的内存段，使用通用CPU寄存器传递前四个字段，并在C堆栈上传递其余字段。对于不同的调用约定，CLinker可以安排FFM API通过分配一个内存区域来间接传递结构体，将传入内存段的内容批量复制到该区域，并将指向该内存区域的指针传递给C函数。这种最低层次的参数打包是在幕后进行的，不需要任何客户端代码的监督。 向上调用有时，将Java代码作为函数指针传递给某个外部函数是很有用的。我们可以通过使用对上行调用的CLinker支持来实现这一点。在本节中，我们将逐块构建一个更复杂的示例，该示例演示了CLinker的全部功能，以及代码和数据跨Java/本地边界的完全双向互操作。 考虑标准C库中定义的以下函数： 12void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 为了从Java端调用qsort，我们首先需要创建向下调用方法句柄： 123456MethodHandle qsort = CLinker.getInstance().downcallHandle( CLinker.systemLookup().lookup(&quot;qsort&quot;).get(), MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class), FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER)); 和前面一样，我们使用C_LONG和long.class来映射C size_t类型，并且在第一个指针形式参数（数组指针）和最后一个形式参数（函数指针）上使用MemoryAddress.class。 qsort使用作为函数指针传递的自定义比较器函数compar对数组的内容进行排序。因此，要调用向下调用方法句柄，我们需要一个函数指针作为最后一个参数传递给方法句柄的invokeExact方法。CLinker::upcallStub通过使用现有的方法句柄帮助我们创建函数指针，如下所示。 首先，我们在Java中编写一个静态方法来比较两个long值，间接表示为MemoryAddress对象： 12345678class Qsort &#123; static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) &#123; return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue()) - MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue()); &#125;&#125; 接着，我们创建一个指向Java比较方法的MethodHandle： 123456MethodHandle comparHandle = MethodHandles.lookup() .findStatic(Qsort.class, &quot;qsortCompare&quot;, MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)); 之后，现在我们有了Java比较器的方法句柄，我们可以使用CLinker::upcallStub创建函数指针。就像向下调用一样，我们使用CLinker类中的布局来描述函数指针的签名： 1234567MemoryAddress comparFunc = CLinker.getInstance().upcallStub(comparHandle, FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER), newImplicitScope());); 我们终于有了一个内存地址，comparFunc，它指向一个方法存根，可以用来调用我们的Java比较方法，所以现在我们有了调用qsort向下调用句柄所需的所有东西： 1234MemorySegment array = MemorySegment.allocateNative(4 * 10, newImplicitScope());array.copyFrom(MemorySegment.ofArray(new int[] &#123; 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 &#125;));qsort.invokeExact(array.address(), 10L, 4L, comparFunc);int[] sorted = array.toIntArray(); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 这段代码创建了一个堆外数组，将Java数组的内容复制到其中，然后将数组连同我们从CLinker获得的比较器函数（指针）传递给qsort句柄。调用之后，堆外数组的内容将根据我们用Java编写的比较器函数进行排序。然后从段中提取一个新的Java数组，其中包含已排序的元素。 安全基本上，Java代码和本机代码之间的任何交互都可能危及Java平台的完整性。链接到预编译库中的C函数本质上是不可靠的，因为Java运行时不能保证函数的签名符合Java代码的期望，甚至不能保证C库中的标识是真正的函数。此外，如果链接了一个合适的函数，实际上调用该函数可能会导致如分段错误的底层故障，最终导致VM崩溃。Java运行时无法阻止此类故障，Java代码也无法捕获此类故障。 使用JNI函数的本地代码尤其危险。这样的代码可以在没有命令行标志（例如--add-open）的情况下，通过使用getStaticField和callVirtualMethod等函数访问JDK内部。它还可以在final字段初始化很久之后更改它们的值。它允许本地代码绕过应用于Java代码的检查，这会破坏JDK中的每个边界和假设。换句话说，JNI本质上就是不安全的。 JNI不能被禁用，因此无法确保Java代码不会调用使用危险的JNI函数的本地代码。这是对平台完整性的一种风险，应用程序开发人员和最终用户几乎看不到这种风险，因为这些函数99%的使用通常来自夹在应用程序和JDK之间的第三、第四和第五方库。 大多数FFM API的设计是安全的。过去需要使用JNI和本地代码的许多场景都可以通过调用不会危及Java平台的FFM API中的方法来实现。例如，JNI的一个主要用例——灵活的内存分配——是由一个简单的方法MemorySegment::allocateNative支持的，该方法不涉及本机代码，并且总是返回由Java运行时管理的内存。一般来说，使用FFM API的Java代码不会使JVM崩溃。 然而，FFM API的一部分本身就是不安全的。当与CLinker交互时，Java代码可以通过指定与底层C函数不兼容的参数类型来请求向下调用方法句柄。在Java中调用向下调用方法句柄会导致与在JNI中调用本机方法时相同的结果——VM崩溃或未定义的行为。FFM API也可以产生不安全的段，即内存段的空间和时间边界是用户提供的，这种段不能由Java运行时验证（参见上文的MemoryAddress::asSegment）。 FFM API中的不安全方法不会带来与JNI函数相同的风险：例如，它们不能更改Java对象中的final字段的值。另一方面，FFM API中的不安全方法很容易从Java代码中调用。由于这个原因，FFM API中不安全方法的使用受到限制：默认情况下，不安全方法的访问是禁用的，调用这些方法会抛出一个IllegalAccessException异常。要使某些模块M中的代码能够访问不安全的方法，请在命令行中指定java --enable-native-access=M。（在以逗号分隔的列表中指定多个模块；指定ALL-UNNAMED以允许类路径上的所有代码访问不安全方法）FFM API的大多数方法都是安全的，Java代码可以使用这些方法，不管是否给出了–enable-native-access。 我们在这里不建议限制JNI的任何方面。在Java中仍然可以调用本地方法，本地代码也可以调用不安全的JNI函数。然而，在未来的版本中，我们可能会以某种方式限制JNI。例如，不安全的JNI函数（如newDirectByteBuffer）可能会在默认情况下被禁用，就像FFM API中的不安全方法一样。更广泛地说，JNI机制是如此的危险，以至于我们希望库在安全和不安全的操作中偏向于纯Java的FFM API，这样我们就可以在默认情况下禁用所有JNI。这与使平台成为“开箱即用”的安全平台的更广泛的Java路线图一致，要求终端用户选择不安全的行为，如破坏强封装或链接到未知代码。 我们不建议以任何方式去修改sun.misc.Unsafe。FFM API对堆外内存的支持是对sun.misc.Unsafe中的malloc和free，即allocateMemory, setMemory, copyMemory，和freeMemory的一个很好的替代方案。我们希望需要非堆存储的库和应用程序采用FFM API，以便及时地弃用并最终删除这些sun.misc.Unsafe方法。 选择继续使用java.nio.ByteBuffer，sun.misc.Unsafe，JNI和其他第三方框架。 风险和假设创建一个API以既安全又高效的方式访问外部内存是一项艰巨的任务。由于前几节中描述的空间和时间检查需要在每次访问时执行，因此JIT编译器能够优化这些检查是至关重要的，例如，将它们提升到热循环之外。JIT实现可能需要做一些工作，以确保API的使用与ByteBuffer和Unsafe等现有API的使用一样有效和可优化。JIT实现还需要确保从API中检索到的本地方法句柄的使用至少与使用现有JNI本地方法一样有效和可优化。 依赖 外部函数和内存API可以用来访问非易失性内存，已经可以通过JEP 352（非易失性映射字节缓冲区，Non-Volatile Mapped Byte Buffers，Java 14引入）用一种更通用和更有效的方式访问 这里描述的工作可能会使后续工作能够提供一个工具，jextract，它从给定本地库的头文件开始，机械地生成与该库交互操作所需的本机方法句柄。这将进一步减少使用Java本地库的开销","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"}]},{"title":"Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算","slug":"Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算","date":"2021-04-07T00:00:00.000Z","updated":"2021-08-29T00:00:00.000Z","comments":true,"path":"2021/04/07/Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算/","link":"","permalink":"http://nickid2018.github.io/2021/04/07/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BF%90%E7%AE%97/","excerpt":"","text":"前文我们说到了很多Visitor，它们用于给类中定义类型，添加字段，附上注释。但是对于一个语言来说，最重要的那一部分我们还没有说到——那就是：方法。 一.方法定义 在ClassVisitor中，我们看到了有一个方法名为visitMethod，参数是(int，String，String，String，String[])，按照参数列表的顺序，它们分别指访问标志，方法名，方法描述符，泛型签名和抛出异常列表，返回一个MethodVisitor。（关于方法描述符，请看此系列的第一篇；关于访问标志，请看第二篇） 对于方法名，有下面的规则： 1.方法名不能是关键字或保留字（goto） 2.方法名不能以数字开头 3.可以为&lt;init&gt;和&lt;clinit&gt; 其中，&lt;init&gt;是构造函数，一个类可以有不止一个构造函数。而&lt;clinit&gt;每个类最多有一个，并且方法描述符必须为()V，它在类初始化阶段被JVM调用。（包括调用这个类的成员和Class.forName，但不包括Class.forName的initialize参数为false时的调用） 若方法名不正确，在尝试加载这个类的时候会抛出java.lang.ClassFormatError: Illegal method name。 抛出异常列表中，所有的类名称都为全限定名。 二.操作栈（Operand Stack） 操作栈是一个方法被调用时JVM分配出来的一个栈空间，它用于存储方法内加载的数据和进行字节码指令操作。当JVM接收到一个字节码指令（例如iadd），就会取出栈顶的几项元素（对于iadd来说，就是栈顶的两项），在进行操作之后，将计算或获得的数据放回栈顶（比如iadd计算栈顶两个int的加和之后会放回加和数字）。 对于普通的对象，只会占用一个栈元素。但对于long或double这种对象，会占用两个栈元素。这有关于之后要介绍的visitMaxs。 如果一个字节码需要超过了现在操作栈内的元素数量的元素，那么在调用生成的方法时会抛出java.lang.VerifyError: Unable to pop operand off an empty stack。 如果一个字节码需要的类型与现在操作栈中元素类型不同，那么在调用生成的方法时抛出java.lang.VerifyError: Register &lt;slot&gt; contains wrong type或java.lang.VerifyError: Bad type on operand stack。 在之后的讲解中，我们会大量的使用这个名词，在接下来的编写中，操作栈的变化将会像下面这样写： 12输入：XXX YYY输出：ZZZ 三.局部变量表（Local Variable Table） 局部变量表在方法调用中分配的另一个空间，用于存储现在方法内所有的局部变量，表中的数据可以被编号为0-n，叫Slot。普通的元素只会占用一个Slot，但long和double这种数据会占用两个。关于这个的详细使用，请看下面的xload和xstore的字节码介绍。 当这个方法为静态方法时，局部变量表会将参数列表中的变量按顺序放入局部变量表中。 当这个方法不是静态方法，局部变量表的0位是this，之后才会将参数列表变量依次放入表中。 如果局部变量表大小超过了256，那么字节码将会发生变化，xload、xstore等都会受到影响（需要以wide字节码辅助才能进行正常的局部变量读取写入）。但是ASM9中不提供wide字节码，因为MethodWriter中有ASM库自己的处理，所以在用户层编写ASM是无影响的。 四.MethodVisitor的方法 在说完操作栈的概念之后，我们来看看MethodVisitor中都定义了哪些有关于字节码和执行的方法。 下面这些方法第一个参数都为字节码。 visitInsn(int)：访问一个零参数要求的字节码指令，如ACONST_NULL visitIntInsn(int, int)：访问一个需要零操作栈要求但需要有一个int参数的字节码指令，如BIPUSH visitVarInsn(int, int)：访问一个有关于局部变量的字节码指令，如ALOAD visitTypeInsn(int, String)：访问一个有关于类型的字节码指令，如CHECKCAST visitFieldInsn(int, String, String, String)：访问一个有关于字段的字节码，如PUTFIELD visitMethodInsn(int, String, String, String, boolean)：访问一个有关于方法调用的字节码，如INVOKESPECIAL visitJumpInsn(int, Label)：访问跳转字节码，如IFEQ 之后，是一些被包装好的字节码访问方法，这些方法都基于最基本的字节码指令，但是不需要我们自己用上面提到的那些方法直接调用字节码。 visitInvokeDynamicInsn(String, String, Handle, Object...)：基于INVOKEDYNAMIC，动态方法调用，会在lambda表达式和方法引用里面说到 visitLdcInsn(Object)：基于LDC、LDC_W和LDC2_W，将一个常量加载到操作栈用（详细见下文） visitIincInsn(int, int)：基于IINC、IINC_W，自增/减表达式 visitTableSwitchInsn(int, int, Label, Label...)：基于TABLESWITCH，用于进行table-switch操作 visitLookupSwitchInsn(Label, int[], Label[])：基于LOOKUPSWITCH，用于进行lookup-switch操作 visitMultiANewArrayInsn(String, int)：基于MULTIANEWARRAY，用于创建多重维度数组，如int[][] 在下文说到它们时，会以下面的方式表达： 12方法：visitXXXInsn参数：XXX YYY ZZZ 到这里，所有有关于字节码指令的方法就结束了。块级结构的方法会在下一篇说。 最后，说一下每个方法都要在最后调用的方法：visitMaxs(int, int)。它第一个参数是操作栈的最大大小，第二个是局部变量的个数。如果你调用这个方法时局部变量数量写小了，就会在生成方法调用时抛出java.lang.ClassFormatError: Arguments can&#39;t fit into locals，如果操作栈大小写小了，在生成方法调用时会抛出java.lang.VerifyError: Stack size too large 那么下面，我们将逐系列逐条讲解所有的字节码。这篇专栏先讲基本的操作栈加载存储等操作、常量获取和运算操作。 注意：接下来的x可以为a（针对对象）、i（针对int）、l（针对long）、f（针对float）、d（针对double）、b（针对byte）、c（针对char）、s（针对short），它代表了操作对象的类型。有些时候没有针对于byte和short的专用字节码，这是因为在JVM中，byte和short在被计算时会被强制拉长为int，所以它们使用的和int一样。char和int能互相转换。boolean类似，它们也需要使用int的字节码，而且boolean值的false就是int值0，而true就是int值1。 [啥事都不干的字节码：nop] 123456输入：无输出：无方法：visitInsn参数：无使用范例： mv.visitInsn(NOP); 这个字节码啥都不干，在实际开发中可以当做代码插入点使用。 [加载字节码：xload与xload_n] x=a/i/l/f/d 1234567输入：无输出：某一对象或基本数据类型数据方法：visitVarInsn参数：加载对象的位置使用范例： mv.visitVarInsn(ALOAD, 5); mv.visitVarInsn(FLOAD, 3); // 在javap反汇编中，此处变为fload_3 如果在调用此字节码时对应位置没有初始化变量（原先为参数或已经用xstore进行值的放入被视为该位置被初始化），在生成方法调用时会抛出java.lang.VerifyError: Accessing value from uninitialized register &lt;slot&gt;。 如果要进行加载的对象位置小于等于3，可以用对应的xload_n版本代替（注意，ASM9的Opcodes中已经不存在xload_n版本的字节码常量，但是在javap反汇编时可以看到此条），例如aload_2。 [存储字节码：xstore与xstore_n] x=a/i/l/f/d;n=0,1,2,3 1234567输入：某一对象或基本类型数据输出：无方法：visitVarInsn参数：存储对象的位置使用范例： mv.visitVarInsn(ASTORE, 4); mv.visitVarInsn(ISTORE, 1); // 在javap反汇编中，此处变为istore_1 存储对象的位置规则与加载相同。与加载规则不同的是，xstore可以指定到一个未初始化的位置，并将这个位置初始化。有意思的一点是，你可以不遵循初始化位置的连续性，也就是说，假如2、3位置都未初始化，你可以通过xstore将对象放入3中并初始化它，这时位置2变为了未定义的状态，它在被xload加载时都会抛出java.lang.VerifyError: Register &lt;slot&gt; contains wrong type，即使你用的加载指令与放入指令类型相同。这时你只能通过另一次xstore将对象放入位置2，才能使这个位置类型固定。 和xload一样，xstore也有xstore_n版本，但ASM9已经不支持直接写入它们了。 [返回字节码：(x)return] x=a/i/l/f/d 1234567输入：某一对象或基本类型数据输出：清空操作栈并返回方法：visitInsn参数：无使用范例： mv.visitInsn(ARETURN); mv.visitInsn(RETURN); // 无返回，用于void方法 返回字节码是每个方法必有的，包括void无返回值方法。如果一个方法没有写任何的返回字节码指令，在调用这个生成的方法时就会抛出java.lang.VerifyError: Falling off the end of the code。 返回字节码无视操作栈内剩余的所有值，只会将栈顶元素返回，并清除操作栈。 在这个方法为同步方法的前提下，所在线程不是已经锁定的监视器对象所有者时，这条指令会抛出IllegalMonitorStateException。这种情况在普通状况下根本无法发生，只有当这个同步方法上在其同步对象上使用了monitorexit却没有使用monitorenter时可能发生。 [复制栈顶字节码：dup家族] 123456789101112131415161718192021222324方法：visitInsn参数：无使用范例： mv.visitInsn(DUP);每种字节码的解析：1. DUP输入：...v1输出：...v1 v12. DUP_X1输入：...v2 v1输出：...v1 v2 v13. DUP_X2输入：...v3 v2 v1输出：...v1 v3 v2 v14. DUP2输入：...v2 v1输出：...v2 v1 v2 v15. DUP2_X1输入：...v3 v2 v1输出：...v2 v1 v3 v2 v16. DUP2_X2输入：...v4 v3 v2 v1输出：...v2 v1 v4 v3 v2 v1 这个字节码是用于复制栈顶元素并插入到栈中的字节码，可以节省xload和xstore的使用量。在这里，…指栈顶下的其他元素。 DUP家族的名称规律是：DUP后紧接着的数字代表了复制数量，Xn代表插入到栈顶下第几层。 [弹出栈顶字节码：pop，pop2] 1234567输入：一（pop）或两（pop2）个元素输出：弹出栈顶一（pop）或两（pop2）个元素方法：visitInsn参数：无使用范例： mv.visitInsn(POP); mv.visitInsn(POP2); 这个字节码也是用于操作操作栈的。它的使用情况举一个例子：调用了一个有返回值的方法但返回值我们不需要，就可以采用POP。 [交换元素字节码：swap] 123456输入：两个元素输出：交换栈顶两个元素方法：visitInsn参数：无使用范例： mv.visitInsn(SWAP); 这个字节码可以交换栈顶的两个操作数。 [常量池常量读取字节码：ldc（ldc_w, ldc2_w）] 12345678输入：无输出：从常量池读取出的数据方法：visitLdcInsn参数：常量值（见下文） [在JVM中，此处是常量池中对应常量的序号，长度分为三种，由三种LDC指令决定]使用范例： mv.visitLdcInsn(&quot;helloworld&quot;); mv.visitLdcInsn(20.0f); // 注意，此处自动装箱成为Float mv.visitLdcInsn(Type.getType(&quot;I&quot;)); // 类型 常量池（Constant Pool）中，含有以下几种数据：整数Integer、浮点数Float、字符串字面值常量String、类的引用Type、句柄Handle或动态常量值ConstantDynamic，所以LDC值可能有这些。 在JVM中，如果常量值是Integer或Float，就会直接将它们放到操作栈顶；如果为String，将String类的引用放到操作栈顶；若为Type，将对应的类型初始化，并将其Class实例引用放到操作栈顶；对于Handle，将java.lang.invoke.MethodHandle/MethodType的引用至于操作栈顶。 在解析类型的引用期间（Type），这条指令可能会抛出有关于类加载的异常；同样的，解析有关于句柄（Handle）的时候也有可能抛出和句柄有关的异常。 [空值常量字节码：aconst_null] 123456输入：无输出：常量值null方法：visitInsn参数：无使用范例： mv.visitInsn(ACONST_NULL); 当程序中使用了null，就可以用这个字节码。 [普通数字常量字节码：xconst_n] x=i/l/f/d;对于iconst，n=m1,0,1,2,3,4,5;对于lconst、dconst，n=0,1;对于fconst，n=0,1,2 12345678输入：无输出：数字常量值，类型与字节码有关方法：visitInsn参数：无使用范例： mv.visitInsn(ICONST_M1); // -1 mv.visitInsn(FCONST_0); // +0.0f mv.visitInsn(LCONST_1); // 1L 当数字较小时，获得数字常量可以不使用LDC，可以直接用这些字节码代替（节省常量池空间）。 [整数常量字节码：bipush和sipush] 123456789输入：无输出：数字常量值方法：visitIntInsn参数：某一具体整数 对于bipush，数字属于byte范围（-128~127） 对于sipush，数字属于short范围（-32768~32767）使用范例： mv.visitIntInsn(BIPUSH, 27); // 27 mv.visitIntInsn(SIPUSH, -2700); // -2700 当一个数字没有超过这两个字节码规定的范围，我们都可以使用这两个字节码获取整数常量。在编译中，属于这个范围的数字都是用它们进行获取整数（除非是-1~5），而更大/小的整数都是用LDC。 说完了基本的加载存储常量指令，下面来看看程序的最基本功能：计算。 [取反运算字节码：xneg] x=i/l/f/d 1234567输入：数字输出：数字的相反数方法：visitInsn参数：无使用范例： mv.visitInsn(INEG); mv.visitInsn(DNEG); 这个字节码用于计算取反（-x）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于整数（int和long），计算规则就是(~x)+1，当它们处于MIN_VALUE时，取反结果仍为MIN_VALUE。 对于浮点数（double和float），这个字节码运算为： 取反与从零减去不等价，若x为+0.0，0.0-x结果为+0.0，而-x为-0.0 若数字为NaN（Not A Number，float的0x7fc00000或double的0x7ff8000000000000L），结果也为NaN 若数字为无穷大（float正0x7f800000负0xff800000，double正0x7ff0000000000000L负0xfff0000000000000L），结果为相反符号的无穷大 若数字为0，结果为相反符号的0 [加法运算字节码：xadd] x=i/l/f/d 1234567输入：加数1 加数2输出：数字的和方法：visitInsn参数：无使用范例： mv.visitInsn(IADD); mv.visitInsn(DADD); 这个字节码用于计算加法（a+b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于浮点数（double和float），这个字节码运算为： 如果两个数都为NaN，结果是NaN。 如果两个数为相反符号的无穷大，和为NaN 同一符号的无穷大结果是该符号的无穷大 有限值与无穷大的和还是无穷大 相反符号的两个0（+0.0和-0.0）结果为+0.0 相同符号的两个0和为该符号的0 0与非零值的和为非零值 符号相反，绝对值相等的有限值和为+0.0 若不属于上面的情况，结果将以IEEE 754舍入到最近可表示的浮点值。如果结果太大无法表示为浮点数（超过最大表示范围“溢出”，也就是绝对值超过float的3.4028235e+38f或double的1.7976931348623157e+308），结果为对应符号的无穷大；如果结果太小无法表示为浮点数（超过最小表示范围“下溢”，也就是绝对值小于float的1.4e-45f或double的4.9e-324），结果是对应符号的0。 [减法运算字节码：xsub] x=i/l/f/d 1234567输入：被减数 减数输出：两数字之差方法：visitInsn参数：无使用范例： mv.visitInsn(ISUB); mv.visitInsn(DSUB); 这个字节码用于计算减法（a-b），等价于a+(-b)。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 浮点数运算法则请同时参照xadd与xneg。 [乘法运算字节码：xmul] x=i/l/f/d 1234567输入：乘数1 乘数2输出：两数字之积方法：visitInsn参数：无使用范例： mv.visitInsn(IMUL); mv.visitInsn(DMUL); 这个字节码用于计算乘法（a*b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于浮点数（double和float），这个字节码运算为： 两个数字中有一个是NaN，结果为NaN 无穷大乘以一个0，结果为NaN 无穷大与有限值相乘，结果为无穷大，符号取决于两个数字的符号是否相同，相同为正，相反为负 其余情况为IEEE 754规定，在xadd那里有完整说明 [除法运算字节码：xdiv] x=i/l/f/d 1234567输入：被除数 除数输出：两数字之商方法：visitInsn参数：无使用范例： mv.visitInsn(IDIV); mv.visitInsn(DDIV); 这个字节码用于计算除法（a/b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于整数（int和long），这个字节码只会保留商的整数部分。如果除数为0，这个字节码会抛出java.lang.ArithmeticException: / by zero 对于浮点数（double和float），这个字节码运算为： 两个数字中有一个是NaN，结果为NaN 无穷大除以无穷大，结果为NaN 无穷大除以有限值，结果为无穷大，符号取决于两个数字的符号（规则见xmul） 有限值除以无穷大，结果为0，符号同上 0除以0为NaN 0除以有限值为0，符号同上 有限值除以0为无穷大，符号同上 其余情况为IEEE 754规定，在xadd那里有完整说明 [取余运算字节码：xrem] x=i/l/f/d 1234567输入：被除数 除数输出：余数方法：visitInsn参数：无使用范例： mv.visitInsn(IREM); mv.visitInsn(DREM); 这个字节码用于计算取余操作（a%b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于浮点数（double和float），这个字节码运算为： 两个数字中有一个是NaN，结果为NaN 符号取决于被除数 被除数为无穷大或除数为0，结果为NaN 被除数为有限值而除数为无穷大，结果为被除数 被除数为0，结果为0 其余情况为IEEE 754规定，在xadd那里有完整说明 [自增字节码：iinc（iinc_w）] 1234567输入：无输出：无方法：visitIincInsn参数：对象位置，自增大小（int范围）使用范例： mv.visitIincInsn(0, 200); mv.visitIincInsn(1, -40); 自增字节码是适用于int的字节码，在以下情境中会用到: i++或i–或++i或–i i+=x或i-=x 自增字节码可以使用负数。 [按位且运算字节码：xand] x=i/l 123456输入：整数1 整数2输出：按位且的整数方法：visitInsn参数：无使用范例： mv.visitInsn(IAND); 这个字节码用于计算按位且操作（a&amp;b）。 [按位或运算字节码：xor] x=i/l 123456输入：整数1 整数2输出：按位或的整数方法：visitInsn参数：无使用范例： mv.visitInsn(LOR); 这个字节码用于计算按位或操作（a|b）。 [按位异或运算字节码：xxor] x=i/l 123456输入：整数1 整数2输出：按位异或的整数方法：visitInsn参数：无使用范例： mv.visitInsn(LXOR); 这个字节码用于计算按位或操作（a^b）。 同时，这个字节码还可以用于计算按位取反（这也是JVM的实现）：~x=x^(-1)。 123mv.visitVarInsn(ILOAD, 0);mv.visitInsn(ICONST_M1);mv.visitInsn(IXOR); [按位左移运算字节码：xshl] x=i/l 123456输入：整数 左移位数输出：按位左移的整数方法：visitInsn参数：无使用范例： mv.visitInsn(LSHL); 这个字节码用于计算按位左移操作（a&lt;&lt;b）。如果左移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行左移操作。 [按位右移运算字节码：xshr] x=i/l 123456输入：整数 右移位数输出：按位右移的整数方法：visitInsn参数：无使用范例： mv.visitInsn(ISHR); 这个字节码用于计算按位右移操作（a&gt;&gt;b）。如果右移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行右移操作。 [按位无符号右移运算字节码：xushr] x=i/l 123456输入：整数 右移位数输出：按位无符号右移的整数方法：visitInsn参数：无使用范例： mv.visitInsn(LUSHR); 这个字节码用于计算按位无符号右移操作（a&gt;&gt;&gt;b）。如果右移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行无符号右移操作。 运算字节码说完之后，最后，来看看数字转换的字节码。 [转换为float的字节码：x2f] x=i/l/d 123456输入：数字输出：转换为float的数字方法：visitInsn参数：无使用范例： mv.visitInsn(I2F); 转换为float采取了IEEE 754的取值规律，详见xadd。虽然对于int，float转换是由低级拓宽范围，但是由于float值不能取到所有int可表示的数字（float仅有24位精确数字，其他为指数和符号位），所以此转换仍然不精确。 [转换为double的字节码：x2d] x=i/l/f 123456输入：数字输出：转换为double的数字方法：visitInsn参数：无使用范例： mv.visitInsn(F2D); 转换为double采取了IEEE 754的取值规律，详见xadd。对于int，这种转换是完全精确的。对于float，如果这个方法是FP-Strict，也就是采取了ACC_STRICT修饰（Java中的strictfp），这个计算就是精确的；如果不是，这个计算可能进行舍入。对于long，由于double值不能取到long表示的所有数字（double仅有53位精确数字，其他为指数和符号位），所以计算不精确。 [转换为int的字节码：x2i] x=d/l/f 123456输入：数字输出：转换为int的数字方法：visitInsn参数：无使用范例： mv.visitInsn(F2I); 由于int在四种数字中级别最低，long转换为它时都有可能丢失精度（甚至符号位），float和double会使用IEEE 754“向零舍入”。特殊情况下，如果浮点数的NaN转换为int，值为0；如果浮点数超出int最大范围，则为相应符号下的最大值。 [转换为long的字节码：x2l] x=i/f/d 123456输入：数字输出：转换为long的数字方法：visitInsn参数：无使用范例： mv.visitInsn(D2L); 由于long级别大于int，int转换为long不丢失精度。在浮点数下，long与int的转换规则类似。 [int转换为其他基本类型的字节码：i2x] x=b/c/s 123456输入：数字输出：转换为byte/char/short的数字方法：visitInsn参数：无使用范例： mv.visitInsn(I2B); 这三个字节码能分别将int缩小转换为byte（-128~127）、short（-32768~32767）和char（0~65535）。由于是缩小变换，可能丢失精度甚至符号位。 [下面是使用例子：计算平方和] Java代码如下： 123public static double computeSquare2(int x1, int x2)&#123; return x1 * x1 + x2 * x2;&#125; 使用ASM写入，如下： 123456789101112131415ClassWriter cw = new ClassWriter(ASM9);cw.visit(V1_8, ACC_PUBLIC, &quot;TestClass&quot;, null, &quot;java/lang/Object&quot;, null);MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;computeSquare2&quot;, &quot;(II)D&quot;, null, null);mv.visitVarInsn(ILOAD, 0);mv.visitInsn(DUP);mv.visitInsn(IMUL);mv.visitVarInsn(ILOAD, 1);mv.visitInsn(DUP);mv.visitInsn(IMUL);mv.visitInsn(IADD);mv.visitInsn(I2D);mv.visitInsn(DRETURN);mv.visitMaxs(3, 2);mv.visitEnd();cw.visitEnd(); 将生成的类加载并调用，以参数100和21传入，结果为10441.0。 这篇博客到这里就结束了，下一期：Java ASM详解：MethodVisitor与Opcode（二）类、数组与调用 这篇文章一共讲了130个字节码呢~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"}]},{"title":"Java ASM详解： 基础知识","slug":"Java ASM详解：基础知识","date":"2021-03-07T00:00:00.000Z","updated":"2021-08-29T00:00:00.000Z","comments":true,"path":"2021/03/07/Java ASM详解：基础知识/","link":"","permalink":"http://nickid2018.github.io/2021/03/07/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"首先第一个问题：ASM是什么，字节码又是什么 ASM是一个Java字节码分析、创建和修改的开源应用框架。它可以动态生成二进制格式的stub类或其他代理类，或者在类被Java虚拟机装入内存之前，动态修改类。在ASM中提供了诸多的API用于对类的内容进行字节码操作的方法。与传统的BCEL和SERL不同，在ASM中提供了更为优雅和灵活的操作字节码的方式 这是ASM官网上给出的没用解释，一句话概括：ASM是一个修改，分析Java类文件的框架。先抛开ASM框架的基本定义，先来看看字节码是什么 字节码（Byte-code）是一种包含执行程序，由一序列 op 代码/数据对组成的二进制文件 又是一段废话。从这里可以的知，字节码是一种介于翻译语言和底层语言的东西，与底层语言（C/C++）相比较你可以从它这里知道程序的运行方式，而与翻译语言（JavaScript）对比来看，你又无法从字节码中轻易看出什么。但是由于字节码的这个特性，我们得以修改它，操纵它，并且我们还可以反编译它。 官网：https://asm.ow2.io/ 添加ASM库依赖 首先，是有关于ASM的Maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-all&lt;/artifactId&gt; &lt;version&gt;6.0_BETA&lt;/version&gt;&lt;/dependency&gt; 或者 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-commons&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-tree&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-analysis&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt;&lt;/dependency&gt; 如果使用第一种，那么你最高能依赖的版本是6.0_BETA。而第二种是现在仍在持续更新的，它相当于把原先的asm-all库分开成为不同的部分，但是基本的asm库是必须的。 这个库以后会详细讲述，这里先说几个强有力的工具。 帮助学习ASM的工具 1.ASMifier: 自动生成ASM代码 ASM库中有不少实用类，为了了解晦涩难懂的ASM代码，可以用ASMifier来进行解析。这是一个可执行类，你可以通过java.exe运行它。 注意：在9.0已经没有这个类了 运行方法：下载ASM的jar（比如asm-all-6.0_beta.jar）或者从你的.m2文件夹（asm-all）里面找到它，然后运行： 1java -classpath asm-all-6.0_BETA.jar org.objectweb.asm.util.ASMifier DemoDump.class 你会得到这样的输出： 2.javap.exe: Java自带的字节码解析工具 javap是你在安装JDK时就有的一个程序文件，是JDK的原生字节码解析工具，关于它的使用因篇幅有限不再细说，可以参考这篇文章 https://www.cnblogs.com/frinder6/articles/5440173.html 3.Eclipse插件: Enhanced Class Decompiler 这个插件是反编译器，可以在你没有库的源代码时反编译出源代码进行调试。当然，这个也可以作为你ASM程序的结果测试方案，通常反编译结果会很贴近于源代码，如果相差很大可以换一种方式反编译。 下面是有关于以后经常会用到的名词，这些对于学习ASM都极其重要。 类(型)的不同名称 类的二进制名称/类全名/简单名称 这个三个名称是等价的，也就是我们平常说的类名，例如 java.lang.Thread java.lang.Thread$UncaughtExceptionHandler这样的名称。 全限定名 这个名称是用于class文件中的名称，其实就是将二进制名称的所有”.”换为”/“，这个名称只有非数组引用类型才有。例如 java/lang/Thread java/io/IOException。 字段描述符 字段描述符是有关于class文件内定义字段等的类型的名称，它遵循以下规则： 1.原始类型的描述符一一对应 原始类型的描述符都对应相应的一个字母，具体来说是这样的： 123456789byte -&gt; Bshort -&gt; Sint -&gt; Ilong -&gt; Jfloat -&gt; Fdouble -&gt; Dchar -&gt; Cvoid -&gt; Vboolean -&gt; Z 2.非数组的引用类型为 L+全限定名+; 3.数组引用类型为 [+数组内类型的描述符 例子: 123java.lang.Thread -&gt; Ljava/lang/Thread;java.lang.Object[] -&gt; [Ljava/lang/Object;int[][] -&gt; [[I 方法描述符 了解类名称和字段描述符，下面讲一下方法描述符（其实字段描述符和方法描述符统称描述符） 方法描述符是class文件中保存参数类型列表和返回值类型的方式，在各种方法调用的操作码里面都会涉及到。 规则： 格式为 ( + 参数列表 + ) + 返回值 所有类型名称都为字段描述符 参数列表中不需要逗号分隔 下面是抽象含义下的具体例子（省略了参数名称，只保留了参数类型）： 1234void a(int,int,int) -&gt; (III)VString s(double[],boolean) -&gt; ([DZ)Ljava/lang/String;int[] i(Object) -&gt; (Ljava/lang/Object;)[Ivoid t() -&gt; ()V 操作码(OpCode) Opcode是用于JVM解释运行Java程序的关键。每一个Opcode都有自己独特的含义与操作，如0x60，助记符iadd，将两个int相加。 有一点要注意：操作码其实就是一个数字，我们平时经常看到的iadd，invokestatic并不是操作码，而是助记符。 而Java中字节码的名称也与操作码有关，因为每个操作码都是用一个字节，所以叫字节码。 每一个字节用来表示一个指令，理论上可以有 256 个操作码。 对于ASM库来说，所有的Opcode都存储于org.objectweb.asm.Opcodes里面，其中还有包括它们在什么方法中作用的注释。 有关于所有操作码的网页：https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html 这是ASM系列的第一篇，之后会持续更新。 bilibili专栏同步： https://www.bilibili.com/read/cv6875366","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"}]},{"title":"Java ASM详解：ASM库使用","slug":"Java-ASM详解：ASM库使用","date":"2021-02-13T00:00:00.000Z","updated":"2021-08-30T12:23:13.000Z","comments":true,"path":"2021/02/13/Java-ASM详解：ASM库使用/","link":"","permalink":"http://nickid2018.github.io/2021/02/13/Java-ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AASM%E5%BA%93%E4%BD%BF%E7%94%A8/","excerpt":"","text":"几个月之后，终于来到了ASM的第二篇专栏（指直接咕了半年） 这篇专栏主要说一说ASM库怎么用，电脑端观看更佳。 一.读取的起源：ClassReaderClassReader位于org.objectweb.asm包下（基础类都在这个包），它是读取字节码的开始，通过它我们才能进行字节码解析。 首先是构造函数： 12345public ClassReader(byte[] classFile)public ClassReader(byte[] classFileBuffer, int classFileOffset, int classFileLength)ClassReader(byte[] classFileBuffer, int classFileOffset, boolean checkClassVersion)public ClassReader(InputStream inputStream) throws IOExceptionpublic ClassReader(String className) throws IOException 这几种构造函数都是以传入数据为目标的：前两个，根据传入的byte数组（第二个指定了偏移量和长度）解析类；倒数第二个，通过InputStream传入；倒数第一个，根据类的全限定名获得对象；中间的则是不开放的API，可以忽略。下面是使用的例子： 123ClassReader reader = new ClassReader(&quot;com/github/nickid2018/asm/TestClass&quot;);ClassReader reader2 = new ClassReader(classBytes, 0, 3370);ClassReader reader3 = new ClassReader(inputStreamClassFile); 说完了对象的构建，下面是它的用法。它最重要的方法是accept，其余的方法基本用不上（都内部自己用的） 12public void accept(ClassVisitor classVisitor, int parsingOptions)public void accept(ClassVisitor classVisitor, Attribute[] attributePrototypes, int parsingOptions) 先抛开Attribute[]这个参数，这个以后可能会说。第一个参数ClassVisitor是你要传入的访问器：ASM整体是Visitor设计模式。最后一个参数int是代表读取模式，它有4个基本取值，这些值可以被or（|）连接： 常量值 读取方式 SKIP_CODE 跳过代码属性 SKIP_DEBUG 跳过源文件、局部变量表、局部变量类型表、方法参数列表、行号 SKIP_FRAME 跳过帧（visitFrame），帧是JVM验证类阶段使用的数据 EXPANDS_FRAMES 扩展堆栈映射帧 下面是例子： 123ClassVisitor cv = ...;classReader.accept(cv, 0);classReader.accept(cv, ClassWriter.SKIP_CODE); 关于ClassReader的使用到这里差不多结束了，下面先讲一下访问标志，然后再说ClassVisitor等类。 二.访问标志（Access Flag）访问标志是用于JVM访问类、字段、方法检查和调用的一个int。这些标志既包含了我们常见的public这种访问限定符，还包含了static、final这种修饰符，除此之外还有声明类为接口的interface，为枚举的enum。 完整的访问标志如下表（省略了前缀ACC_）： Access Flag 常量值 修饰目标 用途 PUBLIC 0x0001 class, field, method 访问限定，公开 PRIVATE 0x0002 class, field, method 访问限定，私密 PROTECTED 0x0004 class, field, method 访问限定，受保护 STATIC 0x0008 field, method 静态 FINAL 0x0010 class, field, method, parameter 对于类为不可继承，对于其他为不可修改 SUPER 0x0020 class 调用invokespecial时会特殊处理超类方法 SYNCHRONIZED 0x0020 method 同步方法 OPEN 0x0020 module 指示模块为开放的 TRANSITIVE 0x0020 module requires 指示依赖于此模块的所有模块都隐式依赖此模块 VOLATILE 0x0040 field volatile字段，在内存中不会缓存 BRIDGE 0x0040 method “桥”方法，由编译器生成 STATIC_PHASE 0x0040 module requires 指示模块在编译时必须但运行时可选 VARARGS 0x0080 method 方法使用@SafeVarargs注释，与static或final连用 TRANSIENT 0x0080 field 被默认序列化忽略 NATIVE 0x0100 method 本地方法（JNI） INTERFACE 0x0200 class 声明类为接口，与abstract连用 ABSTRACT 0x0400 class, method 定义抽象类或抽象方法 STRICT 0x0800 method 严格浮点数定义（strictfp），可能在Java 17失效（？） SYNTHETIC 0x1000 class, field, method, parameter, module * 既不属于显性声明也不属于隐式声明，通常是编译器优化生成 ANNOTATION 0x2000 class 注释类型，与interface、abstract连用 ENUM 0x4000 class(?) field inner 枚举类或枚举字段 MANDATED 0x8000 field, method, parameter, module, module * 隐式声明的数据 MODULE 0x8000 class 声明这个类是模块定义类 JVM定义的Access Flags，真正我们能用到的不多，详见https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25 ASM自己也有定义Access Flag，由于JVM定义的有效位只有16位，所以这两个标志不会与JVM的访问标志冲突，但是这些标志在写入类之前必须清除（用&amp;操作即可） Access Flag 常量值 修饰目标 用途 RECORD 0x10000 class 记录类型（record） DEPRECATED 0x20000 class, field, method 弃用，要和@Deprecated连用 这些常量可以用or叠加修饰，如果访问标志不合法（比如吧ACC_PUBLIC和ACC_PRIVATE用or联系起来当了访问标志），在ASM写入时是不会报错的，但是在JVM试图加载这个类的时候可能会抛出ClassFormatError。 三.解析类的信息：ClassVisitorClassVisitor是一个抽象类，它的构造函数仅需要ASM API版本（在Opcodes中可以找到，1-9），或者再加上另一个ClassVisitor用于一起解析，下面是一个模板： 1234567public ClassParser(int api) &#123; super(api);&#125;public ClassParser() &#123; super(ASM9);&#125; 当这个Visitor被传入accept之后，ClassReader会以下面的顺序调用： 1visit [ visitSource ] [ visitModule ][ visitNestHost ][ visitPermittedSubclass ][ visitOuterClass ] ( visitAnnotation | visitTypeAnnotation | visitAttribute )* ( visitNestMember | visitInnerClass | visitRecordComponent | visitField | visitMethod )* visitEnd 不够清晰？那么下面简单说一下流程： 首先访问类的信息（visit），传入的是类文件的版本（version，从V1_1到V16）、访问标志（access），类的全限定名（name），泛型签名（signature，可能为空），父类全限定名（无指定为java/lang/Object），实现接口列表（全限定名，可为空） 之后访问注释信息（visitAnnotation），传入的是注释描述符（descriptor，这里可能包含有@Repeatable的注释类型，所以这里不是全限定名）和可见性（visible，@Retention定义的作用范围，为CLASS传入false，为RUNTIME传入true，为SOURCE不会写入类文件），该方法返回AnnotationVisitor。 同时，访问泛型注释信息（visitTypeAnnotation），传入的是注释引用类型（typeRef，可能为TypeReference定义的几个值：CLASS_TYPE_PARAMETER &lt;以泛型类的类型参数为目标的类型引用的类型，常量值0&gt;，CLASS_EXTENDS &lt;以泛型类的超类或它实现的接口之一为目标的类型引用的类型，常量值16&gt;，CLASS_TYPE_PARAMETER_BOUND &lt;以泛型类的类型参数的绑定为目标的类型引用的类型，常量值17&gt;），泛型类引用路径（可为空），注释描述符和可见性，返回AnnotationVisitor。 接着，访问字段、方法和内部类。 字段调用visitField方法，传入访问标志，字段名，描述符，泛型签名和默认值，返回FieldVisitor。 方法调用visitMethod方法，传入访问标志，方法名，描述符，泛型签名和异常列表（全限定名），返回MethodVisitor。 内部类调用visitInnerClass方法，传入内部类全限定名，外部类全限定名，内部类名称（不带包路径，也就是没有“.”的名称，如果这个写错了IDE无法识别到这个类，但是不影响调用），和访问标志（这个和类声明定义的标志不同，可以有static，这样类里面就不会带有this$0）。内部类调用指的不只是类中定义了内部类，还包括引用到了其他类的内部类。 当所有信息都访问结束，调用visitEnd。 这里的内容只是简单介绍了一下，具体的下文和接下来几篇专栏会写。 四.解析注释信息：AnnotationVisitorAnnotationVisitor用于解析注释信息，除了最后会调用的visitEnd外，其他都与注释类型本身定义的方法返回值有关。下面是不同的类型： visit方法：传入注释方法名称和值，值必须是基本类型（基本数字、char及其数组，String和类） visitArray方法：传入注释方法名称，返回另一个AnnotationVisitor。这个新的Visitor会被传入数组内的值，所有的name传入都为null。注意：visit一个基本数字或char数组等价于使用visitArray，但是在ClassReader解析中不会调用visitArray而是直接调用visit。 visitAnnotation方法：传入注释方法名称和值的描述符，返回的是值的AnnotationVisitor。 visitEnum方法：传入注释方法名、值的描述符和枚举名称。 对于带有@Repeatable注释的注释类型，在Java使用反射时会返回容器注释，也就是在普通编写时有两种等价的编写方式。在ASM中，这两种方式也等价，写入按照第一种处理： 123456@T.Ts(value = &#123; @T(value = &quot;ss&quot;), @T(value = &quot;dd&quot;) &#125;)public class A &#123; ... &#125;@T(value = &quot;ss&quot;)@T(value = &quot;dd&quot;)public class A &#123; ... &#125; 对于带有@Repeatable注释的注释类型，这两种使用方式在反射和ASM中完全等价（T.Ts是T的注释容器） 五.解析字段：FieldVisitorFieldVisitor的构成比较简单，除了visitEnd在最后调用外，比较常用的就是visitAnnotation和visitTypeAnnotation。这些方法的使用都和ClassVisitor的使用差不多，唯一的不同是visitTypeAnnotation的注释引用类型必为FIELD（常量值19） 到此简单的解析就讲完了。什么？还差一个MethodVisitor？这是我们之后要说的重要内容，所以这里不会提到它。接下来，是应用ASM的例子。 六.使用范例：解析一个类解析一个类需要从文章最开始说的ClassReader写起，它能将一个类的字节码解析并且进行Visitor模式调用。在下面的范例中，我们将尝试读取一个类的名称、字段和注释。 首先是一个测试类的编写，之后用javac编译。 12345678package com.github.nickid2018.asm;public class TestClass &#123; @Deprecated public String string; public static int integer;&#125; 接着，我们尝试读取这个类的信息，因为测试类和运行ASM的类在同一个项目之下，可以用它的全限定名初始化ClassReader。 1ClassReader reader = new ClassReader(&quot;com/github/nickid2018/asm/TestClass&quot;); 之后我们需要继承三个Visitor：ClassVisitor、FieldVisitor和AnnotationVisitor。我们只需要一些信息，所以不需要将它们的所有方法进行覆盖。 创建一个ClassParser继承ClassVisitor，选择要覆盖的方法。在访问类的时候，我们只需要类名，所以需要覆盖visit；又因为需要解析字段，我们还需要覆盖visitField，并且将我们的字段访问器作为返回值。 1234567891011@Overridepublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; super(version, access, name, signature, superName, interfaces); System.out.println(&quot;类名: &quot; + name);&#125;@Overridepublic FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) &#123; System.out.println(&quot;字段: &quot; + name + &quot; 描述符: &quot; + descriptor); return new FieldParser();&#125; 创建FieldParser继承FieldVisitor解析字段。在读取字段时，我们还需要读取字段中的注释，所以需要覆盖visitAnnotation，返回我们自己的AnnotationVisitor。 12345@Overridepublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) &#123; System.out.println(&quot;注释: &quot; + descriptor + &quot; 可见性: &quot; + visible); return new AnnotationParser();&#125; 由于@Deprecated不具有任何的注释方法，我们创建的AnnotationParser可以不覆盖任何方法。 这些访问器写完之后，就要递呈给ClassReader开始解析，代码如下： 12ClassParser cv = new ClassParser();reader.accept(cv, 0); 现在，我们的解析程序就完成了。运行结果如下： 1234类名: com/github/nickid2018/asm/TestClass字段: string 描述符: Ljava/lang/String;注释: Ljava/lang/Deprecated; 可见性: true字段: integer 描述符: I 代码样例：https://paste.ubuntu.com/p/8d6jN8jVzr/ 七.使用范例：生成一个类生成类我们用到的是ClassWriter，它本质上就是ClassVisitor，我们只要用可以构建类的数据按照刚才的格式传给它就能生成对应的类。 它的构造函数有两个，一个只传入一个int，它的值可为三个数：0、COMPUTE_MAXS和COMPUTE_FRAMES。那两个常量值是自动计算方法visitMaxs和visitFrame的，对于现在来说还用不到。另一个构造函数还需要传入ClassReader，这是下一部分可能用到的。 首先确定我们要构建产生的类： 12345678package com.github.nickid2018.asm;public class WillGenerate &#123; @Deprecated public static final int HELLO = 0; private String hi;&#125; 首先创建ClassWriter实例： 1ClassWriter cw = new ClassWriter(0); 接着，创建类，用到的正是visit方法。由于没有指定父类，这个类的父类将被强行指定为java/lang/Object，接口、抽象类、注释类型也如此。这个类没有实现任何接口，所以interfaces可以传null。同理，它没有泛型，所以泛型的signature为null。访问标志是public，再加上super，整体下来就是这句： 1cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, &quot;com/github/nickid2018/asm/WillGenerate&quot;, null, &quot;java/lang/Object&quot;,null); 接下来我们需要创建默认构造函数。javac编译时会把没有定义构造函数的普通类加入默认的构造函数。这种构造函数里面包括了父类构造函数调用和本身的非基本类型字段赋值。如果没有非基本类型字段赋值，那么它的代码就像这样： 123public WillGenerate() &#123; super();&#125; 由于这篇专栏主要是有关于类、字段、注释的解析，方法的解析暂时先不讲，所以这里只给出它的写入代码，不做讲解。 12345678public static void writeDefaultInit(ClassWriter cw) &#123; MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null); mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); mv.visitInsn(RETURN); mv.visitMaxs(1, 1); mv.visitEnd();&#125; 接下来写入HELLO这个字段。它的访问标志是public+static+final，由于它是弃用的，它也可以加上deprecated这个ASM自己定义的Access Flag。它的类型是int，所以描述符是I。没有泛型，所以signature为null。有默认值，为0。所以它的写入像这样： 1FieldVisitor fv = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC + ACC_DEPRECATED, &quot;HELLO&quot;, &quot;I&quot;, null, (Integer) 0); 保留这个FieldVisitor，因为它还具有一个注释@Deprecated。注释类型的描述符为Ljava/lang/Deprecated;。又因为@Deprecated的作用范围是RUNTIME，所以可见性为true，代码如下： 1AnnotationVisitor av = fv.visitAnnotation(&quot;Ljava/lang/Deprecated;&quot;, true); 这时，这个字段就写入信息就完成了，调用visitEnd。 12av.visitEnd();fv.visitEnd(); 下面写hi这个字段，和上面的差不多，直接给代码： 12fv = cw.visitField(ACC_PRIVATE, &quot;hi&quot;, &quot;Ljava/lang/String;&quot;, null, null);fv.visitEnd(); 这时候类的所有信息都已经写完了，调用ClassWriter的visitEnd。 1cw.visitEnd(); 接下来调用ClassWriter的toByteArray获得字节码信息，写入到文件中就能得到类。 运行之后调用反编译器的结果： 123456789package com.github.nickid2018.asm;public class WillGenerate&#123; @Deprecated public static final int HELLO = 0; private String hi;&#125; 代码样例：https://paste.ubuntu.com/p/cqfDPVZbsH/ 八.使用范例：修改一个类修改类需要ClassReader和ClassWriter互相配合。利用ClassVisitor等进行数据的转移和修改。 接下来用ASM改一下我们的TestClass。 123456public class TestClass &#123; // 改为抽象类 @Deprecated public String string; // 重命名为str public static int integer; // 加上final和默认值10&#125; 首先，创建ClassReader和ClassWriter。 12ClassWriter cw = new ClassWriter(0);ClassReader cr = new ClassReader(&quot;com/github/nickid2018/asm/TestClass&quot;); 之后在我们的ClassParser里面改一下，传入一个ClassWriter，使用父类的第二个构造函数：以int，ClassVisitor为参数的构造函数。这样，ClassReader传入的信息可以直接写到ClassWriter里面，我们只需要修改我们所需要的方法就可以达到修改的效果，而不用将所有ClassVisitor的方法实现。 123public ClassParser(ClassWriter cw) &#123; super(ASM9, cw);&#125; 接下来解决第一个修改：改为抽象类。这个我们可以在visit里面修改，将原先的访问标志加一个abstract就好。 1234@Overridepublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; super.visit(version, access + ACC_ABSTRACT, name, signature, superName, interfaces);&#125; 第二个修改是重命名字段。这个在visitField里面判断就行，像下面一样： 12if (name.equals(&quot;string&quot;)) return super.visitField(access, &quot;str&quot;, descriptor, signature, value); 第三个就是修改为final和加默认值，也是在visitField里面改动： 12if (name.equals(&quot;integer&quot;)) return super.visitField(access + ACC_FINAL, name, descriptor, signature, (Integer) 10); 最后用accept传入ClassParser，输出文件就是改好的类文件。 1cr.accept(new ClassParser(cw), 0); 生成之后，用反编译器看一下结果。 123456789package com.github.nickid2018.asm;public abstract class TestClass&#123; @Deprecated public String str; public static final int integer = 10;&#125; 代码样例：https://paste.ubuntu.com/p/yXVvdJs3WH/ 这篇专栏到这里就结束了，下一期专栏：MethodVisitor和Opcode（一） 如果文章中有任何错误，可以在评论区留言，我将会修正错误。 如果使用ASM中有问题，可以在下面评论。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"}]}