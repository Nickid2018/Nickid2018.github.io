{"meta":{"title":"Nickid2018的博客","subtitle":"","description":"","author":"Nickid2018","url":"http://Nickid2018.github.io","root":"/"},"pages":[{"title":"","date":"2021-11-04T06:49:51.730Z","updated":"2021-11-04T06:49:51.730Z","comments":true,"path":"about/index.html","permalink":"http://nickid2018.github.io/about/index.html","excerpt":"","text":"啊，关于这个界面暂时不会存在的（"},{"title":"休闲小游戏","date":"2021-11-09T17:19:34.000Z","updated":"2021-11-23T08:00:33.373Z","comments":true,"path":"games/index.html","permalink":"http://nickid2018.github.io/games/index.html","excerpt":"","text":"2048小游戏寻找美队"},{"title":"2048小游戏","date":"2021-11-09T17:19:34.000Z","updated":"2021-11-10T09:42:59.448Z","comments":true,"path":"games/2048.html","permalink":"http://nickid2018.github.io/games/2048.html","excerpt":"","text":"// Colors of numbers colors = { 2 : '#B4E2E4', 4 : '#A3BBE1', 8 : '#9C99E3', 16 : '#AB92E6', 32 : '#BE8EE8', 64 : '#D079E3', 128 : '#C666BC', 256 : '#C54B8A', 512 : '#C14360', 1024 : '#DF4E4E', 2048 : '#CA764F', 4096 : '#D5A359', 8192 : '#CDD15A', 16384 : '#9EC851', 32768 : '#8DDA5D', 65536 : '#369944', 131072: '#114514' }; // Game Table function init() { gameTable = new Array(); prevTable = new Array(); availableSlots = new Array(); { // Fill for (i = 0; i < 4; i++) { gameTable[i] = new Array(); prevTable[i] = new Array(); for(j = 0; j < 4; j++) { gameTable[i][j] = 0; prevTable[i][j] = 0; } } for (i = 0; i < 16; i++) availableSlots[i] = i; } maxValue = 0; spawnRandomValue(); spawnRandomValue(); score = 0; if(ctx != null) { document.getElementById(\"currentScore\").innerHTML = \"现在得分：\" + score; document.getElementById(\"maxValue\").innerHTML = \"最大值：\" + maxValue; } } ctx = null; maxValue = 0; init(); function spawnRandomValue() { var spawnIndex = parseInt(Math.random() * availableSlots.length); var spawnAt = availableSlots[spawnIndex]; var number = (Math.random() > 0.95 ? 4 : 2); gameTable[parseInt(spawnAt / 4)][parseInt(spawnAt % 4)] = number; var tmpSlots = availableSlots; availableSlots = tmpSlots.slice(0, spawnAt).concat(tmpSlots.slice(spawnAt + 1, tmpSlots.length)); spawnData = { slot : spawnAt, data : number }; maxValue = Math.max(maxValue, number); } function checkContinue() { if(availableSlots.length > 0) return true; for(i = 0; i < 4; i++) for(j = 0; j < 4; j++) if((i != 3 && gameTable[i][j] == gameTable[i + 1][j]) || (j != 3 && gameTable[i][j] == gameTable[i][j + 1])) return true; return false; } function getPosition(direction, rowCount, columnCount) { if(direction == 0) // UP return columnCount * 4 + rowCount; else if (direction == 1) // DOWN return (3 - columnCount) * 4 + rowCount; else if (direction == 2) // LEFT return rowCount * 4 + columnCount; else if (direction == 3) //RIGHT return rowCount * 4 + 3 - columnCount; } function getNumber(direction, rowCount, columnCount) { if(direction == 0) // UP return gameTable[columnCount][rowCount]; else if (direction == 1) // DOWN return gameTable[3 - columnCount][rowCount]; else if (direction == 2) // LEFT return gameTable[rowCount][columnCount]; else if (direction == 3) // RIGHT return gameTable[rowCount][3 - columnCount]; } function setNumber(direction, rowCount, columnCount, number) { if(direction == 0) // UP gameTable[columnCount][rowCount] = number; else if (direction == 1) // DOWN gameTable[3 - columnCount][rowCount] = number; else if (direction == 2) // LEFT gameTable[rowCount][columnCount] = number; else if (direction == 3) // RIGHT gameTable[rowCount][3 - columnCount] = number; } // Rendering data ... stayData = new Array(); moveData = new Array(); spawnData = null; function move(direction) { if(direction > 3 || direction < 0){ alert(\"Error in moving!\"); return; } for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) prevTable[i][j] = gameTable[i][j]; availableSlots = new Array(); for (i = 0; i < 4; i++) { var prevElement = -1; var numberQueue = new Array(); for(j = 0; j < 4; j++) { var number = getNumber(direction, i, j); if(number == prevElement) { score += (numberQueue[numberQueue.length - 1] *= 2); moveData.push({ from : getPosition(direction, i, j), to : getPosition(direction, i, numberQueue.length - 1), data : number }); prevElement = -1; } else if (number != 0) { numberQueue[numberQueue.length] = number; prevElement = number; if(j == numberQueue.length - 1) stayData.push({ slot : getPosition(direction, i, j), data : number }); else moveData.push({ from : getPosition(direction, i, j), to : getPosition(direction, i, numberQueue.length - 1), data : number }); } } for(j = 0; j < 4; j++) { if(j >= numberQueue.length) { availableSlots.push(getPosition(direction, i, j)); setNumber(direction, i, j, 0); } else { setNumber(direction, i, j, numberQueue[j]); maxValue = Math.max(maxValue, numberQueue[j]); } } } availableSlots.sort(); var moveSuccess = false; for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) moveSuccess |= prevTable[i][j] != gameTable[i][j]; if (moveSuccess){ spawnRandomValue(); checkContinue(); } return moveSuccess; } // Rendering moveAnimation = false; timeStampStartAnimation = -1; function renderSingleElement(posStartX, posStartY, number, ctx) { ctx.fillStyle = colors[number] == null ? 'white' : colors[number]; ctx.beginPath(); ctx.moveTo(posStartX, posStartY + 1); ctx.arcTo(posStartX, posStartY, posStartX + 1, posStartY, 1); ctx.lineTo(posStartX + 21, posStartY); ctx.arcTo(posStartX + 22, posStartY, posStartX + 22, posStartY + 1, 1); ctx.lineTo(posStartX + 22, posStartY + 21); ctx.arcTo(posStartX + 22, posStartY + 22, posStartX + 21, posStartY + 22, 1); ctx.lineTo(posStartX + 1, posStartY + 22); ctx.arcTo(posStartX, posStartY + 22, posStartX, posStartY + 21, 1); ctx.closePath(); ctx.fill(); ctx.fillStyle = colors[number] == null ? 'black' : 'white'; ctx.font = \"12px consolas\"; ctx.textAlign = \"center\"; ctx.textBaseline = \"middle\"; ctx.fillText(number + \"\", posStartX + 11, posStartY + 11, 20); } function renderAnimation(ctx) { var timeNow = new Date().getTime(); if (timeNow - timeStampStartAnimation > 200) { stayData = new Array(); moveData = new Array(); spawnData = null; moveAnimation = false; setTimeout(\"\", 1); render(); return; } if (timeNow - timeStampStartAnimation < 150) { // Move Rendering stayData.forEach(function(data) { renderSingleElement((data.slot % 4) * 26.0 + 4, parseInt(data.slot / 4) * 26.0 + 4, data.data, ctx); }); moveData.forEach(function(data) { var progress = (timeNow - timeStampStartAnimation) / 150.0; var fromX = (data.from % 4) * 26 + 4; var toX = (data.to % 4) * 26 + 4; var x = progress * toX + (1 - progress) * fromX; var fromY = parseInt(data.from / 4) * 26 + 4; var toY = parseInt(data.to / 4) * 26 + 4; var y = progress * toY + (1 - progress) * fromY; renderSingleElement(x, y, data.data, ctx); }); } else { var progress = (timeNow - timeStampStartAnimation) / 50 - 3; for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) { if(spawnData.slot != i * 4 + j) { var numberNow = gameTable[i][j]; if (numberNow != 0) renderSingleElement(4 + 26 * j, 4 + 26 * i, numberNow, ctx); } } ctx.scale(progress, progress); var x = ((spawnData.slot % 4) * 26.0 + 4 + 10 * (1 - progress)) / progress; var y = (parseInt(spawnData.slot / 4) * 26.0 + 4 + 10 * (1 - progress)) / progress; renderSingleElement(x, y, spawnData.data, ctx); } setTimeout(render, 3); } function render() { ctx.restore(); ctx.save(); ctx.scale(1, 1); ctx.clearRect(0, 0, 540, 540); // Background ctx.fillStyle = 'rgb(240, 240, 240)'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(540, 0); ctx.lineTo(540, 540); ctx.lineTo(0, 540); ctx.closePath(); ctx.fill(); // Slots ctx.fillStyle = 'white'; ctx.scale(5, 5); for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) { ctx.beginPath(); ctx.moveTo(4 + 26 * i, 5 + 26 * j); ctx.arcTo(4 + 26 * i, 4 + 26 * j, 5 + 26 * i, 4 + 26 * j, 1); ctx.lineTo(25 + 26 * i, 4 + 26 * j); ctx.arcTo(26 + 26 * i, 4 + 26 * j, 26 + 26 * i, 5 + 26 * j, 1); ctx.lineTo(26 + 26 * i, 25 + 26 * j); ctx.arcTo(26 + 26 * i, 26 + 26 * j, 25 + 26 * i, 26 + 26 * j, 1); ctx.lineTo(5 + 26 * i, 26 + 26 * j); ctx.arcTo(4 + 26 * i, 26 + 26 * j, 4 + 26 * i, 25 + 26 * j, 1); ctx.closePath(); ctx.fill(); } if(moveAnimation) { renderAnimation(ctx); } else { for (var i = 0; i < 4; i++) for (var j = 0; j < 4; j++) { var numberNow = gameTable[i][j]; if (numberNow != 0) renderSingleElement(4 + 26 * j, 4 + 26 * i, numberNow, ctx); } } } window.onload = function() { canvas = document.getElementById(\"play2048\"); ctx = canvas.getContext(\"2d\"); window.onkeydown = function(event) { var success = true; if(event.keyCode >= 37 && event.keyCode"},{"title":"","date":"2021-11-04T05:53:11.689Z","updated":"2021-11-04T05:53:11.689Z","comments":true,"path":"links/index.html","permalink":"http://nickid2018.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Java ASM详解：MethodVisitor与Opcode（四）其他流程结构","slug":"Java ASM详解：MethodVisitor与Opcode（四）其他流程结构","date":"2021-11-20T18:02:53.000Z","updated":"2021-11-20T14:05:07.734Z","comments":true,"path":"2021/11/21/Java ASM详解：MethodVisitor与Opcode（四）其他流程结构/","link":"","permalink":"http://nickid2018.github.io/2021/11/21/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/","excerpt":"","text":"上一篇文章中，我们已经了解了基本的流程结构。这篇专栏将详细描述Java中其他的流程结构。 异常捕获结构在平常我们使用流程结构时，除了选择结构和循环结构外，使用最多的大概就是异常捕获结构了。 异常捕获结构的写入都使用了visitTryCatchBlock方法（内部的实现是JSR和RET字节码），它需要早于其他所有字节码写入，也就是在方法写入一开始就要定义。它的定义如下： public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) 其中，start是try块开始的标签；end是try结束后的标签（try的范围不包括这个标签）；handler是try块内抛出Throwable对象后跳转到的标签，即相应的catch块标签；type是catch接受的异常类型，要求传入异常类的全限定名（例外是finally块）。 try-catch在讲述完整的try-catch-finally块之前，我们先来看看普通的try-catch块怎么写入。 普通的try-catch块类似这样： try &#123; // try块 &#125; catch (FirstException e) &#123; // 处理FirstException &#125; catch (SecondException e) &#123; // 处理SecondException &#125; 对于一个指定的try块，可能有多个catch块和它对应。每一个catch块都需要用一次visitTryCatchBlock声明。对于catch块对应的跳转标签目标，它的栈帧信息应该和try块前的局部变量相同，但是操作栈上有一个对应的异常对象。下面给出了使用try-catch块的例子： public static int parseIntSafely(String s) &#123; try &#123; /* labelTryStart */ return Integer.parseInt(s); &#125; catch (NumberFormatException e) &#123; /* labelCatch */ return 0; &#125; &#125; 使用asm写入如下: javac编译时生成的字节码和这里不太一样——它会把已经在操作栈上的Throwable对象先存入局部变量，这是为了输出文件的行号。而这里我们选择直接忽视栈上的Throwable对象。 // 初始栈帧信息 [java/lang/String] Label labelTryStart = new Label(); Label labelCatch = new Label(); mv.visitTryCatchBlock(labelTryStart, labelCatch, labelCatch, &quot;java/lang/NumberFormatException&quot;); // try的范围是[labelTryStart, labelCatch) mv.visitLabel(labelTryStart); // try块内部 mv.visitVarInsn(ALOAD, 0); // 加载s mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Integer&quot;, &quot;parseInt&quot;, &quot;(Ljava/lang/String;)I&quot;, false); // Integer::parseInt mv.visitInsn(IRETURN); // try结束 mv.visitLabel(labelCatch); // catch块开始 // 栈帧信息 [java/lang/String] [java/lang/NumberFormatException] mv.visitFrame(F_SAME1, 0, null, 1, new Object[] &#123; &quot;java/lang/NumberFormatException&quot; &#125;); mv.visitInsn(ICONST_0); mv.visitInsn(IRETURN); mv.visitMaxs(2, 1); // 最大栈帧为2 （catch块内），局部变量1 multi-catch除了普通的catch外，还有一种multi-catch结构： try &#123; // try块 &#125; catch (FirstException | SecondException e) &#123; // catch块 &#125; multi-catch可以看做几个catch块被共用，这时栈帧信息上的操作栈压入的是multi-catch中所有异常类的共有超类。例如一个multi-catch块能捕获NumberFormatException和NullPointerException，它的字节码写入如下： Label labelTryStart = new Label(); Label labelCatch = new Label(); mv.visitTryCatchBlock(labelTryStart, labelCatch, labelCatch, &quot;java/lang/NumberFormatException&quot;); // try的范围是[labelTryStart, labelCatch) mv.visitTryCatchBlock(labelTryStart, labelCatch, labelCatch, &quot;java/lang/NullPointerException&quot;); // 代码和try块，略 mv.visitLabel(labelCatch); mv.visitFrame(F_XXXX, X, XXX, 1, new Object[] &#123; &quot;java/lang/RuntimeException&quot; &#125;); // 栈帧其他信息忽略，操作栈上是共有超类RuntimeException // catch块及之后的代码... try-finally说完了try-catch，我们再看看try-finally语句。 try &#123; // try块内容 &#125; finally &#123; // finally块内容 &#125; finally其实类似catch，它们都会在操作栈上压入Throwable对象（如果产生了异常），但是它是无跳转条件（null）的，无论是否出现异常都会执行一次finally，即代码流必须经过finally。如果try块内包含return，也必须先执行finally的内容之后再执行return。如果finally中含有return，则try内的所有return将被忽略，通常IDE会对这种情况给出警告。 在finally执行之后，如果是没有发生异常进入finally，则正常向下运行；如果是因为异常进入了finally，那么在finally执行之后必须抛出异常————这就意味着你必须把finally的字节码重复两遍，一次没有异常进入finally，一次发生异常进入finally。 下面是一个例子： public static int parseIntAndHello(String s) &#123; try &#123; /* labelTry */ return Integer.parseInt(s); /* labelReturn */ &#125; finally &#123; /* labelFinally */ System.out.println(&quot;hello&quot;); &#125; &#125; asm写入： javac编译还是不是这样，但是运行结果是一样的。javac会让一行语句的执行前后操作栈是空，所以在labelReturn前会进行ISTORE，在IRETURN前ILOAD Label labelTry = new Label(); Label labelReturn = new Label(); Label labelFinally = new Label(); mv.visitTryCatchBlock(labelTry, labelReturn, labelFinally, null); // try位于[labelTry, labelReturn)，发生任何异常都会跳转finally mv.visitLabel(labelTry); // try开始 mv.visitVarInsn(ALOAD, 0); // s mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Integer&quot;, &quot;parseInt&quot;, &quot;(Ljava/lang/String;)I&quot;, false); // Integer::parseInt // try结束，无异常进入finally mv.visitLabel(labelReturn); mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // System.out.println mv.visitInsn(IRETURN); // 正常进入finally结束 mv.visitLabel(labelFinally); // 发生异常进入finally mv.visitFrame(F_SAME1, 0, null, 1, new Object[] &#123; &quot;java/lang/Throwable&quot; &#125;); // finally接受Throwable对象 mv.visitVarInsn(ASTORE, 1); // 保存到槽位1用于之后抛出 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // 重复finally内容 mv.visitVarInsn(ALOAD, 1); // 取出Throwable对象 mv.visitInsn(ATHROW); // 抛出 mv.visitMaxs(3, 2); try-catch-finally接下来，我们把try-catch和try-finally整合到一起。 finally块的意义是无论发生什么异常都要保证执行，所以catch块的异常也会被finally接受。也就是说，一个完整的try-catch-finally语句需要$1+2catch$次visitTryCatchBlock，并且需要重复finally块字节码$1+catch$次。（其中$catch$是catch块的数量） 下面是个整合的例子： public static int parseIntSafelyHello(String s) &#123; try &#123; /* ltry */ return Integer.parseInt(s); /* lreturn */ &#125; catch (NumberFormatException e) &#123; /* lcatch */ return -1; /* lcatchRet */ &#125; finally &#123; /* lfinally */ System.out.println(&quot;hello&quot;); &#125; &#125; asm写入： Label ltry = new Label(), lreturn = new Label(), lcatch = new Label(), lcatchRet = new Label(), lfinally = new Label(); mv.visitTryCatchBlock(ltry, lreturn, lcatch, &quot;java/lang/NumberFormatException&quot;); mv.visitTryCatchBlock(ltry, lreturn, lfinally, null); mv.visitTryCatchBlock(lcatch, lcatchRet, lfinally, null); mv.visitLabel(ltry); // try块开始 mv.visitVarInsn(ALOAD, 0); // s mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Integer&quot;, &quot;parseInt&quot;, &quot;(Ljava/lang/String;)I&quot;, false); // Integer::parseInt // try结束，try无异常进入finally mv.visitLabel(lreturn); mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // System.out.println mv.visitInsn(IRETURN); // try无异常finally结束 mv.visitLabel(lcatch); // catch块开始 mv.visitFrame(F_SAME1, 0, null, 1, new Object[] &#123; &quot;java/lang/NumberFormatException&quot; &#125;); // 栈帧信息：压入异常对象 mv.visitInsn(POP); // 我们不需要这个对象,直接弹栈（javac会进行ASTORE，无论是否使用，因为要记录名称） mv.visitLabel(lcatchRet); // catch无异常进入finally mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // 重复一遍finally... mv.visitInsn(ICONST_M1); mv.visitInsn(IRETURN); // 返回-1 mv.visitLabel(lfinally); // 发生异常跳转finally mv.visitFrame(F_SAME1, 0, null, 1, new Object[] &#123; &quot;java/lang/Throwable&quot; &#125;); mv.visitVarInsn(ASTORE, 1); // 保存到槽位1 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // 再重复一遍finally... mv.visitVarInsn(ALOAD, 1); mv.visitInsn(ATHROW); // 抛出 mv.visitMaxs(3, 2); try-with-resources除了try-catch、multi-catch、try-finally、try-catch-finally结构外，还有一种结构：try-with-resources。这种结构要求一个AutoClosable的对象在try后的语句中初始化： try (AutoClosable res1 = getObject1(), res2 = getObject2(), ...) &#123; // try内的语句 &#125; catch (Exception e) &#123; // catch块 &#125; finally &#123; // finally... &#125; 它可以转化为普通的try-catch-finally块，类似于这样： javac编译之后内部不是这样，这里是将执行流程强制转换为可读Java源码 AutoClosable res = null; try &#123; res = getObject1(); // try块内容... &#125; catch (Exception e) &#123; // catch块内容... // 这里res也会被close，但是因为Java代码没法表现就没有写 &#125; catch (Throwable t) &#123; try &#123; res.close(); // 这里其实res已经被创建了，但是因为Java代码没法表现就放在这里了 &#125; catch (Throwable t2) &#123; t.addSupressed(t2); &#125; throw t; &#125; finally &#123; // finally... &#125; 使用try-with-resources结构写入字节码的时候，只要记住每一个出口都会进行一次带try-catch的close就可以。由于这种结构很复杂且代码量巨大，就不举例子了。 switch多分支结构在一些情况下，if...else if...else结构非常的长，这时我们可以用switch替代。 可直接表示为int的switch多分支语句最简单的switch是键为整形数字常量（可以用int表示的）的，类似于这样： int i = ...; switch (i) &#123; case 0: case 1: ... ... default: ... &#125; 在写入switch中，我们有两个方法可以选择： public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label... labels) public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) 它们的相同之处是：它们都需要操作栈顶上有一个int类型的值。它们的不同之处在于它们对于键值的存储方式和使用的字节码： visitTableSwitchInsn写入的键值是一个连续的数组——一个$[min,max]$的一个整形数字数组。如果switch中没有中间的某些键值，那么这些键值会和dflt一致，即default的标签（如果没有default块，则dflt应该指向switch结束后的第一条语句）。它使用TABLESWITCH字节码。 visitLookupSwitchInsn要求传入一个switch键值的数组，数组内的数字要从小到大排序。labels数组的长度要与keys一致。dflt也是指向default或者switch结束后的第一条语句的标签。它使用LOOKUPSWITCH字节码。 回到最简单的switch上来。我们需要按照键值的特性选择我们的写入方式： 如果switch内的键值差异小，并且键值组成一个连续整数数组的空缺不超过6个，则使用visitTableSwitchInsn 如果switch内的键值差异大，则使用visitLookupSwitchInsn 先看个简单的小例子： public static void test(int i) &#123; switch (i) &#123; case 0: case 1: /* label1 */ System.out.println(&quot;1&quot;); case 2: /* label2 */ System.out.println(&quot;2&quot;); break; case 3: /* label3 */ System.out.println(&quot;3&quot;); &#125; /* labelEnd */ &#125; 可以看到，键值$\\{0,1,2,3\\}$组成了一个连续的整数数组，所以这里我们应该使用visitTableSwitchInsn。 mv.visitVarInsn(ILOAD, 0); // i Label label1 = new Label(), label2 = new Label(), label3 = new Label(), labelEnd = new Label(); mv.visitTableSwitchInsn(0, 3, labelEnd, label1, label1, label2, label3); // 解释：没有default块所以指向了switch结束的下一条语句，0和1用了一个跳转位置 mv.visitLabel(label1); // 0和1处理 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;1&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(label2); // 2的处理，注意这里0和1处理之后也会经过这个地方 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;2&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitJumpInsn(GOTO, labelEnd); // break的作用，跳出switch mv.visitLabel(label3); // 3的处理，这里不会被0、1、2访问了 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;3&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // switch结束 mv.visitLabel(labelEnd); mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitInsn(RETURN); mv.visitMaxs(2, 1); 这是对于switch最简单的一种清况之一。因为byte、short、char在JVM内解释为int，所以这些步骤基本相同。 使用枚举的switch多分支语句switch语句还可以用于枚举类型，下面我们定义了一个枚举，并使用了它： enum TestEnum &#123; FIRST, SECOND, THIRD, FOURTH &#125; public static void test(TestEnum i) &#123; switch (i) &#123; case FIRST: case SECOND: System.out.println(&quot;1&quot;); case THIRD: System.out.println(&quot;2&quot;); break; case FOURTH: System.out.println(&quot;3&quot;); default: System.out.println(&quot;4&quot;); &#125; &#125; 枚举类型不能直接作为两种switch字节码的参数，它必须先变为一个int才能传入字节码。为此，javac在编译的时候会自动创建一个内部类，用于保存这个类里面出现的所有使用枚举对象switch的一个映射表。对于我们定义的TestEnum，它对应的映射类应该像这样（假设我们方法定义的类是Test）： // 注意：这个类和字段都要有ACC_SYNTHETIC访问标志 class Test$1 &#123; static final int[] $SwitchMap$TestEnum; static &#123; $SwitchMap$TestEnum = new int[TestEnum.values().length]; try &#123; $SwitchMap$TestEnum[TestEnum.FIRST.ordinal()] = 1; &#125; catch (NoSuchFieldError e) &#123; &#125; try &#123; $SwitchMap$TestEnum[TestEnum.SECOND.ordinal()] = 2; &#125; catch (NoSuchFieldError e) &#123; &#125; try &#123; $SwitchMap$TestEnum[TestEnum.THIRD.ordinal()] = 3; &#125; catch (NoSuchFieldError e) &#123; &#125; try &#123; $SwitchMap$TestEnum[TestEnum.FOURTH.ordinal()] = 4; &#125; catch (NoSuchFieldError e) &#123; &#125; &#125; &#125; 这个内部类中含有所有在这个类中出现的枚举对象，每个枚举类都会创建一个字段，命名为$SwitchMap$+.替换成$的类型名，它们的长度是对应枚举类枚举字段的数量，按照ordinal大小排序将1-n写入数组（n是本类使用了多少个这个类的枚举字段）。 接下来，switch的传入方式也发生了变化： TestEnum i ... switch (Test$1.$SwitchMap$TestEnum[i.ordinal()]) &#123; ... &#125; 那么之前给出的例子我们可以用asm写入为： mv.visitFieldInsn(GETSTATIC, &quot;Test$1&quot;, &quot;$SwitchMap$TestEnum&quot;, &quot;[I&quot;); // 获取常量字段 mv.visitVarInsn(ALOAD, 0); // i mv.visitMethodInsn(INVOKEVIRTUAL, &quot;TestEnum&quot;, &quot;ordinal&quot;, &quot;()I&quot;, false); // Enum::ordinal mv.visitInsn(IALOAD); // 取出常量 Label label1 = new Label(), label2 = new Label(), label3 = new Label(), labelDefault = new Label(), labelEnd = new Label(); mv.visitTableSwitchInsn(1, 4, labelDefault, label1, label1, label2, label3); // default标签-labelDefault, 1/2用了同一个跳转目标 mv.visitLabel(label1); // 1/2 FIRST/SECOND mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;1&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(label2); // 3 THIRD mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;2&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitJumpInsn(GOTO, labelEnd); // break mv.visitLabel(label3); // 4 FOURTH mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;3&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(labelDefault); // default mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;4&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(labelEnd); // switch结束 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitInsn(RETURN); mv.visitMaxs(2, 2); 如果是我们自己写入asm，推荐不要用这种方式写入——毕竟太麻烦了。最好的方案是使用Enum::ordinal获取序号对序号进行switch，而不是存一个新的表。 使用字符串的switch多分支语句除了枚举和基本int之外，switch还允许字符串传入。下面就是一个例子： public static void test(String s) &#123; switch (s) &#123; case &quot;HELLO&quot;: System.out.println(&quot;hello&quot;); break; case &quot;BYEBYE&quot;: System.out.println(&quot;byebye&quot;); break; default: System.out.println(&quot;ss&quot;); &#125; &#125; 很明显，String不能直接转换成为int。在String中，hashCode这个方法可以让我们将字符串映射到int上，这样就能把它作为键值。但是还有一个问题需要解决：String和int不能一一对应——不同的字符串可能有相同的hashCode，例如ddnqavbj和166lr735ka3q6的哈希码值都为0。因此，javac在编译时将这个switch块拆开为两个，并使用一个临时量保存字符串的映射。这样，上面的例子就变成了下面这样： public static void test(String s) &#123; &#123; String tempStr = s; int temp = -1; switch (tempStr.hashCode()) &#123; case 68624562: // &quot;HELLO&quot;的哈希码 /* hashHello */ if (tempStr.equals(&quot;HELLO&quot;)) temp = 0; break; case 1973839168: // &quot;BYEBYE&quot;的哈希码值 /* hashBye */ if (tempStr.equals(&quot;BYEBYE&quot;)) temp = 1; break; &#125; /* switch2 */ switch (temp) &#123; case 0: /* case0 */ System.out.println(&quot;hello&quot;); break; case 1: /* case1 */ System.out.println(&quot;byebye&quot;); break; default: /* caseDefault */ System.out.println(&quot;ss&quot;); &#125; &#125; /* end */ &#125; 按照上面的Java代码，我们能用asm将它写入： // 初始帧 [java/lang/String] mv.visitVarInsn(ALOAD, 0); // s mv.visitVarInsn(ASTORE, 1); // 转存到tempStr mv.visitInsn(ICONST_M1); // -1 mv.visitVarInsn(ISTORE, 2); // 存入temp mv.visitVarInsn(ALOAD, 1); // tempStr mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;hashCode&quot;, &quot;()I&quot;, false); // tempStr.hashCode() Label hashHello = new Label(), hashBye = new Label(), switch2 = new Label(); mv.visitLookupSwitchInsn(switch2, new int[]&#123; 68624562, 1973839168 &#125;, new Label[]&#123; hashHello, hashBye &#125;); mv.visitLabel(hashHello); // HELLO的哈希码 // 栈帧 [java/lang/String java/lang/String I] mv.visitFrame(F_APPEND, 2, new Object[]&#123;&quot;java/lang/String&quot;, Opcodes.INTEGER&#125;, 0, null); mv.visitVarInsn(ALOAD, 1); // tempStr mv.visitLdcInsn(&quot;HELLO&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false); // 判断 mv.visitJumpInsn(IFEQ, switch2); // 反转判断，失败直接跳转出去 mv.visitInsn(ICONST_0); // 0 mv.visitVarInsn(ISTORE, 2); // 赋值给temp mv.visitJumpInsn(GOTO, switch2); // 也跳转出去 mv.visitLabel(hashBye); // BYEBYE的哈希码 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitVarInsn(ALOAD, 1); // tempStr mv.visitLdcInsn(&quot;BYEBYE&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false); // 判断 mv.visitJumpInsn(IFEQ, switch2); // 反转判断，失败直接跳转 mv.visitInsn(ICONST_1); // 1 mv.visitVarInsn(ISTORE, 2); // 赋值给temp mv.visitLabel(switch2); // 第一个switch结束 mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitVarInsn(ILOAD, 2); // 加载temp Label case0 = new Label(), case1 = new Label(), caseDefault = new Label(), end = new Label(); mv.visitLookupSwitchInsn(caseDefault, new int[]&#123; 0, 1 &#125;, new Label[]&#123; case0, case1 &#125;); // 这里可以用tableswitch，但是javac是这样编译出来的 mv.visitLabel(case0); // HELLO mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;hello&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitJumpInsn(GOTO, end); // 跳转结束 mv.visitLabel(case1); // BYEBYE mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;byebye&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitJumpInsn(GOTO, end); // 跳转结束 mv.visitLabel(caseDefault); // default mv.visitFrame(F_SAME, 0, null, 0, null); // 栈帧无变化 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); mv.visitLdcInsn(&quot;ss&quot;); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitLabel(end); // 结束 // 栈帧信息 [java/lang/String] mv.visitFrame(F_CHOP, 2, null, 0, null); mv.visitInsn(RETURN); mv.visitMaxs(2, 3); 增强型switch最后来看看Java 14新加的增强型switch。 首先，增强型switch可以返回一个值赋给变量或者进行操作： System.out.println(switch (s) &#123; case &quot;HELLO&quot; -&gt; 3; case &quot;BYEBYE&quot; -&gt; 4; default -&gt; 5; &#125;); 这种操作的本质还是和上面的一样，下面是展开增强型switch但是不展开String转换的结果： int temp; switch (s) &#123; case &quot;HELLO&quot;: temp = 3; break; case &quot;BYEBYE&quot;: temp = 4; break; default: temp = 5; &#125; System.out.println(temp); 另一种增强型switch使用了yield关键字： System.out.println(switch (s) &#123; case &quot;HELLO&quot;: System.out.println(&quot;case0&quot;); yield 3; case &quot;BYEBYE&quot;: System.out.println(&quot;case1&quot;); yield 4; default: System.out.println(&quot;default&quot;); yield 5; &#125;); 它的原理也和上面差不多： int temp; switch (s) &#123; case &quot;HELLO&quot;: System.out.println(&quot;case0&quot;); temp = 3; break; case &quot;BYEBYE&quot;: System.out.println(&quot;case1&quot;); temp = 4; break; default: System.out.println(&quot;default&quot;); temp = 5; &#125; System.out.println(temp); 这篇文章到这里就结束了（最后不写例子主要是因为这两种结构需要的代码量太大了）。 这回一共讲了4个字节码，加上以前的一共190个。 有错误可以在评论区指出~ 下一期 Java ASM详解：MethodVisitor与Opcode（五）invokedynamic、方法引用、BSM","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：MethodVisitor与Opcode（三）标签，条件结构，循环结构，栈帧","slug":"Java ASM详解：MethodVisitor与Opcode（三）标签，条件结构，循环结构，栈帧","date":"2021-11-06T11:09:19.000Z","updated":"2021-11-06T04:37:32.781Z","comments":true,"path":"2021/11/06/Java ASM详解：MethodVisitor与Opcode（三）标签，条件结构，循环结构，栈帧/","link":"","permalink":"http://nickid2018.github.io/2021/11/06/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%B8%89%EF%BC%89%E6%A0%87%E7%AD%BE%EF%BC%8C%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%8C%E6%A0%88%E5%B8%A7/","excerpt":"","text":"在之前的文章中，我们已经知道了基础的字节码。但是，这些字节码只能构建起一个简单的结构，不能实现循环条件等高级结构。这篇文章将讨论关于程序流程结构的字节码。 标签标签（Label）是用来划明一部分字节码的标识（通常意义上标签就是一个标记点，但是为了接下来的讲述就用它代表一块字节码）。一个标签下的字节码块，应该从操作栈空开始到操作栈被清空结束——也就是说，一个标签代表的字节码块反编译之后应该是完整的一或多条语句。 在通常情况下，javac编译器会把每条单独语句都分配一个标签，这么做的目的是为了输出行号和局部变量名称。 标签也可以在我们使用Java时自己定义，下面的LABEL就是一个标签： LABEL: while(true) &#123; for(int i = 0; i &lt; 10; i++) if(Math.random() &gt; 0.1) break LABEL; &#125; 在字节码中，标签代表的字节码块是从这个标签写入开始到下一个标签写入或该方法的字节码读取完毕的一部分字节码。 在ASM库中，标签用org.objectweb.asm.Label进行表示，构造方法如下： public Label() 写入一个Label，需要用到MethodVisitor的方法，方法如下： public void visitLabel(final Label label) 正如前面所说，两个标签的写入之间的字节码可以看作这个标签代表的一块字节码块。因此，两个visitLabel之间的语句也可以被看作前一个Label代表的一部分字节码区域。 MethodVisitor mv = ... Label l1 = new Label(); mv.visitLabel(l1); // --- l1代表的字节码块开始 mv.... mv.... // --- l1代表的字节码块结束 Label l2 = new Label(); mv.visitLabel(l2); 那么标签有什么用呢？ 首先它可以保存代码的行号，这就用到了MethodVisitor::visitLineNumber这个方法了。 public void visitLineNumber(final int line, final Label start) 第一个参数代表了这条语句的行号，第二个参数就是这条语句的标签。标签必须先于行号被写入，否则就会抛出IllegalArgumentException。 其次，它可以保存局部变量的名称。局部变量有作用域，而作用域可以用两个标签指定。在这两个标签之内且在指定局部变量槽位上的变量就是我们要命名的局部变量。写入局部变量的名称使用MethodVisitor::visitLocalVariable。 public void visitLocalVariable( final String name, final String descriptor, final String signature, final Label start, final Label end, final int index) 参数的意义分别是：名称、描述符、泛型签名、开始的标签、结束的标签、局部变量槽位。在javac编译生成的类文件中，局部变量名称的写入都要在最后写入。 最后，标签的最重要意义就是它可以用于跳转字节码上。 跳转字节码用于跳转的字节码都使用了visitJumpInsn方法： public void visitJumpInsn(final int opcode, final Label label) 第一个就是字节码，第二个是跳转的目标。字节码决定了是否进行跳转，标签决定了跳转的目的地。 跳转字节码分为两种——比较跳转和无条件跳转。 无条件跳转字节码无条件跳转，也就是goto字节码： 输入：无 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(GOTO, label1); goto字节码是当程序运行到这里时，就直接跳转到对应的标签继续执行，通常都是用在循环内部的。 比较跳转字节码比较跳转是大多数条件结构和循环结构使用的字节码，它有四套字节码，分别对应了int比较、int与0比较、对象比较和对象空检测： if_icmp&lt;cond&gt;&lt;cond&gt; = eq/ne/lt/ge/gt/le 输入：两个int数据 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(IF_ICMPEQ, label1); 这六个字节码分别对应了两个int数据进行相等、不相等、小于、大于等于、大于、小于等于的比较测试。如果比较成功，就跳转到指定的标签处运行。如果比较不成功，就沿着当前的流程继续运行。 if&lt;cond&gt;&lt;cond&gt; = eq/ne/lt/ge/gt/le 输入：一个int数据 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(IFEQ, label1); 这六个字节码分别对应了一个int数据进行等于0、不等于0、小于0、大于等于0、大于0、小于等于0的比较测试。测试结果和跳转方式和上文相同。 if_acmp&lt;cond&gt;&lt;cond&gt; = eq/ne 输入：两个对象 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(IF_ACMPNE, label1); 这两个字节码分别对应两个对象相等和不相等。这个字节码比较的是对象的引用，而不是内部的值——也就是说，即使两个String对象内部存储字符串一样，也不能保证它们的检测结果为真！（例外是使用了String::intern，它会把字符串放进常量池，并返回一个固定的引用）所以判断字符串相等必须使用equals方法而不是==。 ifnull/ifnonnull输入：一个对象 输出：无 方法：visitJumpInsn 参数：标签 使用范例： mv.visitJumpInsn(IFNULL, label1); 这两个字节码分别测试对象是空还是非空。执行流程和之前3个一样。 可以看到，这几个字节码指针对了int和对象引用的情况，而没有考虑long、float、double的情况。于是Java加入了下面几个字节码用于比较它们，获取到值后就可以传递给各个IF字节码判断。 比较字节码lcmp输入：两个long 输出：一个int 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LCMP); 它用于比较两个long的大小：如果第一个数字比第二个小，返回-1；如果第二个数字比第一个小，返回1；如果相等，返回0。 xcmp&lt;op&gt;x=f/d, &lt;op&gt;=l/g 输入：两个浮点数 输出：一个int 方法：visitInsn 参数：无 使用范例： mv.visitInsn(FCMPG); 这套字节码和lcmp的逻辑差不多：如果第一个数小于第二个数，返回-1；如果第二个数小于第一个数，返回1；如果相等，返回0。但是，如果其中一方是NaN，&lt;op&gt;就决定了它们返回的值：l版本返回-1，而g版本返回1。 接下来，我们将用这22个字节码实现程序的复杂流程结构。 条件结构在Java中，条件结构类似于下面： if (condition1) &#123; // ... &#125; else if (condition2) &#123; // ... // N 个else if &#125; else if (conditionN) &#123; // ... &#125; else &#123; // ... &#125; 在编译期间，这种代码可以被看为： if (condition1) &#123; // ... &#125; else if (condition2) &#123; // ... &#125; else // N 个else if.. if (conditionN) &#123; // ... &#125; else &#123; // ... &#125; 也就是说，这种结构就是由一个一个的if...else结构组合形成的。一个简单的if…else结构用字节码写入后可以表示为这样的流程： if判断条件通常都使用了返回boolean的表达式（除了特殊字节码指定的比较方式外都需要这样传入），而boolean值的true是1，false是0，使用IFEQ字节码相当于被反向判断。相类似的，javac在编译时经常将字节码操作反转来保证if块先于else块写入。 返回boolean值传入if中的选择结构类似于这样： ...返回一个boolean ifeq label2 label1: if块内内容 goto label3 label2: else块内内容 label3: if块外部代码 在跳转之后，我们的操作栈和局部变量表会和跳转之前相等。同时，visitMaxs的参数变成了所有分支下最大的局部变量表大小和最大的操作栈深度。 下面举一个例子。要生成这样的Java代码： public static int max(int a, int b) &#123; if(a &gt; b) return a; else return b; &#125; 我们的字节码应该像下面这样写： // 省略ClassWriter和MethodVisitor创建和其他内容 mv.visitVarInsn(ILOAD, 0); mv.visitVarInsn(ILOAD, 1); // 加载a、b Label label1 = new Label(); // 创建标签 mv.visitJumpInsn(IF_ICMPLE, label1); // a &gt; b 的反转判断（小于等于），这样能保证if块在前 // if部分内容 mv.visitVarInsn(ILOAD, 0); mv.visitInsn(IRETURN); // return a 方法结束 mv.visitLabel(label1); // else部分内容 mv.visitVarInsn(ILOAD, 1); mv.visitInsn(IRETURN); // return b 方法结束 mv.visitMaxs(2, 2); // 两个int变量，操作栈深度最大2 条件结构可以被简化为三元运算符，三元运算符的字节码也类似于if…else。 下面是一个使用三元运算符的例子： public static int compute(int val) &#123; int endVal = val &lt; 0 ? -val : val; return endVal * 2; &#125; 字节码写入： // 省略ClassWriter和MethodVisitor创建和其他内容 Label labelElse = new Label(); // else 块的标签 mv.visitJumpInsn(IFGE, labelElse); // 反转判断val // 三元运算符中前面的表达式 mv.visitVarInsn(ILOAD, 0); mv.visitInsn(INEG); Label labelIfEnd = new Label(); // if...else之后的标签 mv.visitJumpInsn(GOTO, labelIfEnd); // 结束，跳转 mv.visitLabel(labelElse); // 三元运算符后面的表达式 mv.visitVarInsn(ILOAD, 0); mv.visitLabel(labelIfEnd); // 保存到endVal中 mv.visitVarInsn(ISTORE, 1); // 计算 endVal * 2 mv.visitVarInsn(ILOAD, 1); mv.visitInsn(ICONST_2); mv.visitInsn(IMUL); mv.visitInsn(IRETURN); mv.visitMaxs(2, 2); 循环结构循环结构都比较类似，都是流程返回到之前的代码部分。先从最简单的while语句开始： while循环while循环的流程类似与这样： 接下来用一段Java代码写一个例子： public static int test() &#123; int sum = 0; int now = 0; while(sum &lt; 1000) &#123; sum += ++now; &#125; return now; &#125; 这是用字节码的方式写入： mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 0); // 存入sum mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 1); // 存入now Label labelCondition = new Label(); mv.visitLabel(labelCondition); // 循环条件 mv.visitVarInsn(ILOAD, 0); // 加载sum mv.visitIntInsn(SIPUSH, 1000); Label labelEnd = new Label(); mv.visitJumpInsn(IF_ICMPGE, labelEnd); // 反转比较sum &lt; 1000 mv.visitVarInsn(ILOAD, 0); mv.visitIincInsn(1, 1); mv.visitVarInsn(ILOAD, 1); mv.visitInsn(IADD); mv.visitVarInsn(ISTORE, 0); mv.visitJumpInsn(GOTO, labelCondition); // 流程跳转回到条件处 mv.visitLabel(labelEnd); mv.visitVarInsn(ILOAD, 1); mv.visitInsn(IRETURN); mv.visitMaxs(2, 2); do…while循环类似于while，do...while结构也用了和它基本一致的思路，只不过是循环条件写到了后面，并且循环条件不用反转： do…while循环就不再举例子了，下面来看看for循环。 for循环for循环有两种：普通的for语句和for-each语句。普通的for循环语句在定义时包括了三条语句：一条初始化、一条条件和一条循环结束执行语句。它的流程类似于while多加了一些部分： 接下来就是一个例子，使用for循环： public static int test() &#123; int sum = 0; for(int i = 0; i &lt; 100; i++) sum += i; return sum; &#125; 在字节码里面要这样写： mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 0); // 存入sum mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 1); // int i = 0，for循环初始化语句 Label labelCondition = new Label(); mv.visitLabel(labelCondition); mv.visitVarInsn(ILOAD, 1); // i mv.visitIntInsn(BIPUSH, 100); // 100 Label labelEnd = new Label(); mv.visitJumpInsn(IF_ICMPGE, labelEnd); // i &lt; 100的反转 mv.visitVarInsn(ILOAD, 0); // sum mv.visitVarInsn(ILOAD, 1); // i mv.visitInsn(IADD); mv.visitVarInsn(ISTORE, 0); mv.visitIincInsn(1, 1); // i++， for循环结束语句 mv.visitJumpInsn(GOTO, labelCondition); // 回到条件 mv.visitLabel(labelEnd); mv.visitVarInsn(ILOAD, 0); mv.visitInsn(IRETURN); mv.visitMaxs(2, 2); 另一种for循环，即for-each循环，它的实现和for循环很不一样。 for-each需要一个Iterable的对象才能使用，它的原理就是通过iterator进行迭代。下面这两种形式是等价的： // 设 T extends Iterable&lt;E&gt; T set = ...; // for-each写法 for(E element : set) &#123; ... &#125; // 等价写法 Iterator&lt;E&gt; iterator = set.iterator(); while(iterator.hasNext()) &#123; E element = iterator.next(); ... &#125; 也就是说，for-each本质是while循环。由于没有讲泛型，所以就不细讲此处。 栈帧我相信你已经把上面的例子都跑了一遍（没跑也没事，我默认已经跑了），可是这些东西在你尝试运行它们的时候都会报错。它们报的错无一例外都是VerifyError，这是出了什么毛病？这就有关于栈帧了。 Java中执行方法时，JVM会分配给当前线程一个栈帧，栈帧和方法绑定，它的内部就是现在的局部变量表和操作栈数据（这在第三篇文章说过）。栈帧内的局部变量表大小和操作栈大小来自visitMaxs。栈帧在方法开始执行时创建，在方法返回时（包括抛出异常）销毁。 但是在类文件中，我们不能保证一个类它的数据是不是异常的——有可能它规定的栈帧局部变量表或者操作栈小于真正运行时的大小。所以Java引入了类的验证阶段，检查类内部数据。其中有一项就是检查方法栈帧——检查方法字节码是否正确排序、变量类型是不是一致等。但是这种验证很耗费时间，所以JVM验证器引入了StackMapTable进行辅助，这样就能在线性的运行下检查。但是每一行都加入栈帧映射（stack map frame）实在是太浪费空间了，所以JVM做了优化，规定每个跳转目标之后都必须有一个映射用于表示栈帧变化。 栈帧映射中并不是一个真的局部变量表和操作栈类型表，它是以一种和前面的映射比较的方式保存——比如这个映射要比前面的映射少两个元素等。第一个映射前面并没有别的映射，所以它和空的操作栈与参数列表组成的局部变量表的栈帧比较。 （可以看看https://stackoverflow.com/questions/25109942/what-is-a-stack-map-frame下面的评论） 所以引发异常的真正原因我们找到了——看来验证器没有检查到方法内部跳转指令后的栈帧映射，导致了验证失败抛出异常。 那么怎么写入栈帧映射呢？ MethodVisitor提供了一个方法，叫visitFrame。它就是用于写入当前栈帧数据变化的方法。这个方法需要在每个跳转目标的visitLabel后面去写，不是用于跳转的标签不需要visitFrame。 visitFrame的方法原型如下： public void visitFrame( final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) 它有5个参数，指明了这个映射和前面的映射的比较方式和数据。先讲后面的参数，最后再讲第一个参数。 第三个参数是一个代表局部变量变化的一个数组，长度应该为第二个参数。数组内的取值分为这几种： 如果变量是一个没有初始化的对象，那么这个值是指向这个对象NEW字节码的标签对象。 如果变量是this并且在调用父类构造函数之前被调用，这个值是UNINITIALIZED_THIS。 如果变量类型不是基本类型，值就应该是它的类的全限定名/描述符字符串。 如果是基本类型，那么取值是固定的：int用INTEGER代替，float用FLOAT代替，long用LONG代替，double用DOUBLE代替，空用NULL代替。long和double即使需要占两个槽位也不需要写两遍，byte、short、char、boolean要用INTEGER代替。 如果这个局部变量槽位上暂时是空位（注意不是空对象），用TOP代替。 第五个参数类似，是表示操作栈变化的一个数组，长度是第四个参数。 下面是重点——第一个参数的意义。它的不同取值和意义如下： F_NEW，只能在Java 6使用（或者ClassWriter被指定扩展栈帧映射），它的写入和之后的版本不一样（其实是类似F_FULL，写入和之前的栈帧信息无关）。这篇文章不会介绍Java 6的栈帧映射写入。 F_SAME，代表这里的局部变量表和之前的栈帧信息相比没有变化，numLocal和numStack为0，两个数组都为null。（即使不是null也不会写入） F_SAME1，代表这里的局部变量表和之前的栈帧信息一样，而操作栈上有一个变量。numLocal是0，numStack是1，local是null，stack是一个数组，内部只有一个元素，代表现在栈上对象的类型。 F_APPEND，代表现在的局部变量表和之前的栈帧信息一样，但是会多出1-3个新的局部变量。numLocal是新增加的局部变量的数量，local是一个长度为numLocal的数组，存储新增加的局部变量的类型。numStack是0，stack为null。 F_CHOP，代表现在的局部变量表要比之前的栈帧信息少1-3个局部变量。numLocal就是局部变量缺少的数量，numStack是0，local和stack都是null。 F_FULL，这代表现在的栈帧和之前的栈帧没有关系，相当于复写了栈帧的信息。numLocal是局部变量数量，local是局部变量类型数组，numStack是操作栈深度，stack是操作栈类型数组。当现在的栈帧比之前的栈帧多/少3个以上的局部变量，或者操作栈上有变量（除非局部变量表不变且栈深度为1可以使用F_SAME1对应），都需要用这个标志重新写入。 在编译时，编译器会尽量减少F_FULL的出现次数，保证类文件不会因为额外栈帧信息变得臃肿。在我们自己生成字节码时，也尽量不要用F_FULL。 接下来，我们来回顾我们报错的代码： public static int test() &#123; int sum = 0; for(int i = 0; i &lt; 100; i++) sum += i; return sum; &#125; 按照之前的代码，我们要在每个跳转目标上加上栈帧信息： // 初始栈帧信息 局部变量表 [] mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 0); // 存入sum mv.visitInsn(ICONST_0); mv.visitVarInsn(ISTORE, 1); // int i = 0，for循环初始化语句 Label labelCondition = new Label(); mv.visitLabel(labelCondition); // 这个标签是跳转目标，加入visitFrame // 这里的栈帧信息 局部变量表 [I I] 操作栈 [] mv.visitFrame(F_APPEND, 2, new Object[] &#123; INTEGER, INTEGER &#125;, 0, null); mv.visitVarInsn(ILOAD, 1); // i mv.visitIntInsn(BIPUSH, 100); // 100 Label labelEnd = new Label(); mv.visitJumpInsn(IF_ICMPGE, labelEnd); // i &lt; 100的反转 mv.visitVarInsn(ILOAD, 0); // sum mv.visitVarInsn(ILOAD, 1); // i mv.visitInsn(IADD); mv.visitVarInsn(ISTORE, 0); mv.visitIincInsn(1, 1); // i++， for循环结束语句 mv.visitJumpInsn(GOTO, labelCondition); // 回到条件 mv.visitLabel(labelEnd); // 跳转目标，加入栈帧信息 // 这里的栈帧信息 局部变量表 [I] 操作栈 [] mv.visitFrame(F_CHOP, 1, null, 0, null); mv.visitVarInsn(ILOAD, 0); mv.visitInsn(IRETURN); mv.visitMaxs(2, 2); 为了方便用户操作，asm自己加了一个计算栈帧信息的标识：COMPUTE_FRAMES。在ClassWriter构造函数中使用。 ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES); 使用这个后，所有的visitFrame和visitMaxs都不需要我们自己写。ClassWriter会根据字节码推断栈帧信息等并写入，代价是增加近一倍的运行时间。 实战下面，我们将用字节码写出一个简单的阶乘程序，使用for循环计算阶乘并且用if判断是否溢出。对应的Java代码如下： public static long secureFactorial(long number) &#123; long result = 1; for (int i = 1; i &lt;= number; i++) &#123; result *= i; if (result &lt; 0) // Overflow throw new IllegalArgumentException(&quot;Overflow!&quot;); &#125; return result; &#125; 首先计划一下程序标签的位置： public static long secureFactorial(long number) &#123; long result = 1; for (int i = 1; /* labelCondition*/ i &lt;= number; i++) &#123; result *= i; if (result &lt; 0) // Overflow throw new IllegalArgumentException(&quot;Overflow!&quot;); /* labelNoError */ &#125; /* labelEnd */ return result; &#125; 下面我们用不开启COMPUTE_FRAMES的ClassWriter进行写入： // 初始帧 局部变量 [J] mv.visitInsn(LCONST_1); mv.visitVarInsn(LSTORE, 2); // 存入result mv.visitInsn(ICONST_1); mv.visitVarInsn(ISTORE, 4); // 存入i Label labelCondition = new Label(); mv.visitLabel(labelCondition); // 栈帧信息 局部变量 [J J I] 操作栈 [] mv.visitFrame(F_APPEND, 2, new Object[]&#123; LONG, INTEGER &#125;, 0, null); mv.visitVarInsn(ILOAD, 4); // i mv.visitInsn(I2L); // 拉长比较 mv.visitVarInsn(LLOAD, 0); // number mv.visitInsn(LCMP); Label labelEnd = new Label(); mv.visitJumpInsn(IFGT, labelEnd); // 反向比较i &lt;= number mv.visitVarInsn(LLOAD, 2); // result mv.visitVarInsn(ILOAD, 4); // i mv.visitInsn(I2L); // 拉长计算 mv.visitInsn(LMUL); // 相乘 mv.visitVarInsn(LSTORE, 2); // 存入result mv.visitVarInsn(LLOAD, 2); // result mv.visitInsn(LCONST_0); mv.visitInsn(LCMP); Label labelNoError = new Label(); mv.visitJumpInsn(IFGE, labelNoError); // 反向比较 result &lt; 0 // 创建异常对象抛出 mv.visitTypeInsn(NEW, &quot;java/lang/IllegalArgumentException&quot;); mv.visitInsn(DUP); mv.visitLdcInsn(&quot;Overflow!&quot;); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/IllegalArgumentException&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitInsn(ATHROW); mv.visitLabel(labelNoError); // 栈帧信息 局部变量 [J J I] 操作栈 [] mv.visitFrame(F_SAME, 0, null, 0, null); mv.visitIincInsn(4, 1); // i++ mv.visitJumpInsn(GOTO, labelCondition); // 回到判断条件 mv.visitLabel(labelEnd); // 栈帧信息 局部变量 [J J] 操作栈 [] mv.visitFrame(F_CHOP, 1, null, 0, null); mv.visitVarInsn(LLOAD, 2); // result mv.visitInsn(LRETURN); // 返回 mv.visitMaxs(4, 5); // 最大操作栈深度4（两个long比较），局部变量5个槽位 然后我们对生成的类进行测试： Class&lt;?&gt; generated = new Loader().defineClassNow(&quot;Test&quot;, cw.toByteArray()); System.out.println(generated.getMethod(&quot;secureFactorial&quot;, long.class).invoke(null, 20)); System.out.println(generated.getMethod(&quot;secureFactorial&quot;, long.class).invoke(null, 50)); 得到下面的输出： 2432902008176640000 Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:568) at io.github.nickid2018.asmtest.ASMMain.main(ASMMain.java:60) Caused by: java.lang.IllegalArgumentException: Overflow! at Test.secureFactorial(Unknown Source) ... 5 more 这就代表成功了！ 全部源代码：https://paste.ubuntu.com/p/Gyhn3wHMQ3/ 下一期：Java ASM详解：MethodVisitor与Opcode（四）其他流程结构 这篇文章一共讲了22个字节码，加上以前讲过的一共186个。 有错误可以在评论区指出","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步","slug":"Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步","date":"2021-10-05T12:22:46.000Z","updated":"2021-11-03T15:50:55.454Z","comments":true,"path":"2021/10/05/Java ASM详解：MethodVisitor和Opcode（二）类型、数组、字段、方法、异常与同步/","link":"","permalink":"http://nickid2018.github.io/2021/10/05/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E5%92%8COpcode%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E6%AE%B5%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%90%8C%E6%AD%A5/","excerpt":"","text":"上次讲过了操作栈与数值运算操作，这篇专栏主要讲ASM中有关于类型、数组与方法调用的字节码。 P.S.ASM库已经更新到了9.2版本，可以试试解析Java 18的类了。 有关于类型的字节码有关于类型的字节码都是用visitTypeInsn进行写入的。这类字节码共有4个：NEW，ANEWARRAY，INSTANCEOF和CHECKCAST。ANEWARRAY在之后的数组字节码里面会仔细去讲。 new输入：无 输出：一个指定类型的对象 方法：visitTypeInsn 参数：类型 使用范例： mv.visitTypeInsn(NEW, &quot;java/lang/Object&quot;); NEW只进行创建对象，不负责调用构造函数，所以内部字段的值都为默认值。调用构造函数必须用invokespecial字节码进行调用（下文）。 在调用这个字节码时，如果指向的类没有初始化，就它的调用静态初始化函数&lt;clinit&gt;。如果在初始化中发生异常就会抛出错误。如果目标类的类格式有误，则抛出异常。如果目标类时抽象的，则抛出InstantiationError。 instanceof输入：一个对象 输出：布尔值，代表是否为指定类的对象（栈上表示为一个四字节数据） 方法：visitTypeInsn 参数：类型（对于数组是描述符） 使用范例： mv.visitTypeInsn(INSTANCEOF, &quot;java/lang/String&quot;); instanceof用于检查对象是否为这个类型的实例，如果是则返回boolean值true，即操作栈上的一个int数据1；如果不是就返回0。 对于null对象，该字节码永远返回0。 checkcast输入：一个对象 输出：类型检查后的对象 方法：visitTypeInsn 参数：类型（对于数组是描述符） 使用范例： mv.visitTypeInsn(CHECKCAST, &quot;java/io/InputStream&quot;); checkcast用于检查对象的类型，类似于instanceof。但不同的是，如果无法将对象转换为指定类型，该字节码会抛出ClassCastException。这个字节码经常见于泛型中。 加入这个字节码通常是为了指定对象是某个类型好让验证器验证，在局部变量无法得知确切类型时必须加入此字节码保证验证通过（运行时报错就是另一回事了）。 下面是这三个字节码组合的例子： 要生成的Java代码如下： public static String testTypeASM() &#123; Object object = new String(&quot;Hello&quot;); boolean bool = object instanceof String; return (String) object; &#125; 对应的生成这段代码的字节码程序如下： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 // ---- 第一行语句 ----- mv.visitTypeInsn(NEW, &quot;java/lang/String&quot;); mv.visitInsn(DUP); // 栈上复制一份对象 mv.visitLdcInsn(&quot;Hello&quot;); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/String&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false); // 执行构造函数 mv.visitVarInsn(ASTORE, 0); // 存在局部变量表0号位 // ---- 第二行语句 ----- mv.visitVarInsn(ALOAD, 0); // 取出局部变量object mv.visitTypeInsn(INSTANCEOF, &quot;java/lang/String&quot;); mv.visitVarInsn(ISTORE, 1); // ---- 第三行语句 ----- mv.visitVarInsn(ALOAD, 0); mv.visitTypeInsn(CHECKCAST, &quot;java/lang/String&quot;); // 注：此处可以不加这个CHECKCAST，因为局部变量表已知是String。如果局部变量表无法判断是否真的为String且没有加入这个语句，在验证时下方ARETURN字节码会报错 mv.visitInsn(ARETURN); // ---- 结束 ---- mv.visitMaxs(3, 2); mv.visitEnd(); 数组操作的字节码数组操作的字节码一共有20个，其中加载指令8个，存储指令8个，三个创建还有一个获取数组长度的字节码。 newarray输入：int，代表数组长度 输出：指定长度的数组 方法：visitIntInsn 参数：数组的类型，有8个常量值分别代表了不同的值类型 使用范例： mv.visitIntInsn(NEWARRAY, T_INT); 和newarray字节码用于创建基本类型的数组，它的参数代表了它的类型，在Opcodes类中一共有8个：T_BOOLEAN（boolean），T_CHAR（char），T_FLOAT（float），T_DOUBLE（double），T_BYTE（byte），T_SHORT（short），T_INT（int）和T_LONG（long）。 如果数组长度小于0，这个字节码会抛出NegativeArraySizeException。 anewarray输入：int，代表数组长度 输出：指定长度的数组 方法：visitTypeInsn 参数：类型 使用范例： mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;); 基本类型的数组由newarray创建，而不是基本类型的数组由anewarray创建。 和newarray一样，如果数组长度小于0，这个字节码会抛出NegativeArraySizeException。 multianewarray输入：一系列的int，代表多维数组中每一维的长度 输出：多维数组 方法：visitMultiANewArrayInsn 参数：描述符和维度 使用范例： mv.visitMultiANewArrayInsn(&quot;[[Ljava/lang/String;&quot;, 2); mv.visitMultiANewArrayInsn(&quot;[[[I&quot;, 3); 创建一个多维数组，多维数组的描述符要与第二个参数维度相匹配。和另两个字节码相同，如果多维数组任意一维的长度小于0，这个字节码就会抛出NegativeArraySizeException。 下面是使用这三个字节码的例子： Java代码： int[] arrayInt = new int[10]; int[][] multi2Int = new int[100][2]; String[] strings = new String[30]; String[][] multiStrings = new String[127][128]; 生成这些代码的字节码程序： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 // new int[10] mv.visitIntInsn(BIPUSH, 10); mv.visitIntInsn(NEWARRAY, T_INT); mv.visitVarInsn(ASTORE, 0); // new int[100][2] mv.visitIntInsn(BIPUSH, 100); mv.visitInsn(ICONST_2); mv.visitMultiANewArrayInsn(&quot;[[I&quot;, 2); mv.visitVarInsn(ASTORE, 1); // new String[30] mv.visitIntInsn(BIPUSH, 30); mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;); mv.visitVarInsn(ASTORE, 2); // new String[127][128] mv.visitIntInsn(BIPUSH, 127); mv.visitIntInsn(SIPUSH, 128); mv.visitMultiANewArrayInsn(&quot;[[Ljava/lang/String;&quot;, 2); mv.visitVarInsn(ASTORE, 3); 在创建数组时，如果是一维数组就用newarray或anewarray。multianewarray也能创建一维数组，但是使用上面的两个更加高效。 arraylength输入：数组 输出：数组长度 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ARRAYLENGTH); 获取数组的长度，返回int。如果数组输入为null，抛出空指针异常。 xaloadx=a,b,c,d,f,i,l,s, 其中b同时负责了byte和boolean 输入：数组，int类型的下标 输出：数组元素 方法：visitInsn 参数：无 使用范例： mv.visitInsn(BALOAD); xaload的作用是从数组指定下标取元素。如果下标超过数组长度，抛出ArrayIndexOutOfBoundsException。对于多维数组的提取元素方式类似下面： // Java 代码： // 设int[][] multi = new int[10][20];位于局部变量表0位 return multi[1][4]; // 字节码： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitVarInsn(ALOAD, 0); mv.visitInsn(ICONST_1); mv.visitInsn(AALOAD); mv.visitInsn(ICONST_4); mv.visitInsn(IALOAD); mv.visitInsn(IRETURN); xastorex=a,b,c,d,f,i,l,s, 其中b同时负责了byte和boolean 输入：数组，int类型的下标，一个变量 输出：无 方法：visitInsn 参数：无 使用范例： mv.visitInsn(BASTORE); 将对象存入数组指定下标。如果下标超过数组长度，抛出ArrayIndexOutOfBoundsException。对于多维数组，存储对象需要和xaload一起配合。 // Java 代码： // 设int[][] multi = new int[10][20];位于局部变量表0位 multi[1][4] = 20; // 字节码： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitVarInsn(ALOAD, 0); mv.visitInsn(ICONST_1); mv.visitInsn(AALOAD); mv.visitInsn(ICONST_4); mv.visitIntInsn(BIPUSH, 20); mv.visitInsn(IASTORE); 操作字段的字节码在代码中我们经常会调用类中的字段，例如System.out。Java提供了四个字节码用于访问和修改字段。 getfield输入：一个对象 输出：对应字段的值 方法：visitFieldInsn 参数：字段所处的类、字段名、字段描述符 使用范例： mv.visitFieldInsn(GETFIELD, &quot;org/objectweb/asm/MethodVisitor&quot;, &quot;mv&quot;, &quot;Lorg/objectweb/asm/MethodVisitor;&quot;); getfield用于获取非静态字段的值。如果它作用目标是一个静态字段，则在类连接验证时抛出IncompatibleClassChangeError。 如果输入的对象是null，这个字节码会在运行时抛出空指针异常。 这个字节码不能调用数组的length字段，在编译的时候length字段会自行转变成arraylength字节码。 getstatic输入：无 输出：对应字段的值 方法：visitFieldInsn 参数：字段所处的类、字段名、字段描述符 使用范例： mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); getstatic用于获取静态字段的值。如果它作用目标是一个非静态字段，则在类连接验证时抛出IncompatibleClassChangeError。 putfield输入：一个对象、准备修改成的对象 输出：无 方法：visitFieldInsn 参数：字段所处的类、字段名、字段描述符 使用范例： mv.visitFieldInsn(PUTFIELD, &quot;org/objectweb/asm/MethodVisitor&quot;, &quot;mv&quot;, &quot;Lorg/objectweb/asm/MethodVisitor;&quot;); putfield用于修改非静态字段的值。如果它作用目标是一个静态字段，则在类连接验证时抛出IncompatibleClassChangeError。 如果输入的对象是null，这个字节码会在运行时抛出空指针异常。 对于final字段，如果不是在初始化对象时修改（构造函数中），那么就会抛出IllegalAccessError。 putstatic输入：准备修改成的对象 输出：无 方法：visitFieldInsn 参数：字段所处的类、字段名、字段描述符 使用范例： mv.visitFieldInsn(PUTSTATIC, &quot;io/github/nickid2018/Constants&quot;, &quot;test&quot;, &quot;Z&quot;); putstatic用于修改静态字段的值。如果它作用目标是一个非静态字段，则在类连接验证时抛出IncompatibleClassChangeError。 对于final字段，如果不是在类初始化时修改（&lt;clinit&gt;中），那么就会抛出IllegalAccessError。 调用方法的字节码调用方法的字节码共有五个：invokevirtual，invokespecial，invokestatic，invokeinterface和invokedynamic。invokedynamic使用了BSM（BootStrap Method），讲解起来很复杂，所以这个要单独分出来一篇文章去讲。这篇文章主要讨论前四个。 invokevirtual输入：一个对象，传入参数 输出：与方法返回值有关 方法：visitMethodInsn 参数：方法所在的类，方法名，方法描述符，固定值false 使用范例： mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false); 这个字节码用于调用实例方法：如果对象是子类的对象且子类复写了这个方法，则调用子类的方法；如果对象就是该类的直接对象或者对象所属子类没有复写这个方法，就调用现在类的方法。 在编译时，如果子类调用了父类的方法且子类没有实现此方法，那么方法所在的类要写为父类。如果使用super，要用invokespecial调用（下文）。 如果方法调用目标是静态的，在连接验证时会抛出IncompatibleClassChangeError。 如果方法调用目标是抽象的，并且在继承树上没有任何实现此方法的类，在调用时会抛出AbstractMethodError。 如果方法调用目标是抽象的，而继承树上由多个实现此方法的类，且这些方法都是可被选中成为调用目标的方法（比如一个类继承于一个抽象类，又实现了两个接口，两个接口中都有一个同样的default方法可作为抽象类中抽象方法的实现目标），这时此字节码会抛出IncompatibleClassChangeError。 如果方法调用目标是native的，且没有任何JNI连接查询到这个方法和哪个C函数相连接，这时这个字节码抛出UnsatisfiedLinkError。 invokespecial输入：一个对象，传入参数 输出：与方法返回值有关 方法：visitMethodInsn 参数：方法所在的类，方法名，方法描述符，固定值false 使用范例： mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false); invokespecial类似于invokevirtual，但不同的是，它和调用方法的对象的类型无关：它的方法调用对象就是字节码内部标定的方法，如果这个类找不到就寻找直接超类的方法，而不是像invokevirtual要考虑继承树所有的方法。 这个方法经常在构造函数中看到，因为无论什么类都需要有一个构造函数，而构造函数内部必须自动调用父类构造函数。 一个默认的构造函数类似于下面： public class Test &#123; public Test() &#123; super(); &#125; &#125; 在生成类时，如果没有自定义其他构造函数，就要加上这个默认构造函数： ClassWriter cw = new ClassWriter(0); cw.visit(V17, ACC_PUBLIC + ACC_SUPER, &quot;Test&quot;, null, &quot;java/lang/Object&quot;, null); MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null); mv.visitVarInsn(ALOAD, 0); // 加载自身(this) mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); // 调用父类构造函数 mv.visitInsn(RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); cw.visitEnd(); invokestatic输入：一个对象，传入参数 输出：与方法返回值有关 方法：visitMethodInsn 参数：方法所在的类，方法名，方法描述符，固定值false 使用范例： mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Math&quot;, &quot;sin&quot;, &quot;(D)D&quot;, false); invokestatic用于调用静态方法，如果调用目标不是个静态方法，抛出IncompatibleClassChangeError。 和invokevirtual一样，如果目标是个native方法而JNI找不到连接的C函数，该字节码抛出UnsatisfiedLinkError。 invokeinterface输入：一个对象，传入参数 输出：与方法返回值有关 方法：visitMethodInsn 参数：方法所在的类，方法名，方法描述符，固定值true 使用范例： mv.visitMethodInsn(INVOKEINTERFACE, &quot;java/util/Set&quot;, &quot;clear&quot;, &quot;()V&quot;, true); 这个字节码类似于invokevirtual，异常情况的处理也和它类似。它用于调用接口方法，而不是像invokevirtual的实例方法。 抛出异常的字节码：athrow输入：一个Throwable对象 输出：操作栈不变 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ATHROW); athrow负责将一个Throwable对象抛出。如果对象是null，那么就不会抛出这个null，而是抛出NullPointerException。 通常情况下，我们都是直接new一个Throwable对象然后直接抛出，就像这样： throw new Exception(&quot;error!&quot;); 翻译为字节码如下： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitTypeInsn(NEW, &quot;java/lang/Exception&quot;); mv.visitInsn(DUP); mv.visitLdcInsn(&quot;error!&quot;); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Exception&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false); mv.visitInsn(ATHROW); 同步字节码同步操作共有两个字节码，monitorenter和monitorexit，成套使用。 输入：一个对象 输出：无 方法：visitInsn 参数：无 使用范例： mv.visitInsn(MONITORENTER); mv.visitInsn(MONITOREXIT); 输入的对象必须是引用类型对象，不能是基本类型的值。 使用同步块时，代码类似这样： Object lock = new byte[0];//设0号位 synchronized(lock) &#123; //... &#125; 对应的字节码： // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitInsn(ICONST_0); mv.visitIntInsn(NEWARRAY, T_BYTE); mv.visitVarInsn(ASTORE, 0); mv.visitVarInsn(ALOAD, 0); mv.visitInsn(MONITORENTER); //... mv.visitVarInsn(ALOAD, 0); mv.visitInsn(MONITOREXIT); monitorenter就是尝试加锁的操作。如果这个对象的监视器条目计数为0，此线程会把这个计数设置为1，这时此线程就是这个对象的监视器；如果不为0且线程不是该对象的监视器，线程会阻塞直到计数为0时重新尝试加锁；如果线程已经是这个对象的监视器，计数递增。 monitorexit就是释放锁的操作。如果线程是这个对象的监视器，计数递减，当计数减为0时该线程就不是这个对象的监视器了。如果线程不是这个对象的监视器，这个字节码会抛出IllegalMonitorStateException。 monitorenter可以和很多monitorexit一起出现，在一个方法的所有可能流程中的加锁次数和释放次数必须相同，否则在调用时会发生IllegalMonitorStateException。 对于同步方法（访问标志含有ACC_SYNCHRONIZED），不需要手动对自身对象或类加锁。JVM在调用方法前隐式加锁，在调用之后隐式释放。 应用：计算两数之积学到了这些字节码，接下来我们要试试用纯字节码解决这道简单的问题。 输入：两个双精度浮点数a,b 输出：一个保留5位小数部分的双精度浮点数，代表a*b 例： 3.22 6.11 输出： 19.67420 在Java代码下，我们可以这样写： // 这里不写main方法，而是写了一个静态的test方法用于后续调用 import java.util.Scanner; public class Test &#123; public static void test() &#123; Scanner scanner = new Scanner(System.in); double a = scanner.nextDouble(); double b = scanner.nextDouble(); System.out.printf(&quot;%.5f&quot;, a * b); &#125; &#125; 下面是用ASM生成的步骤： 首先还是创建类和方法，不再多说。 第一行，创建Scanner对象，这里用到的就是new。 // 省略了ClassWriter和MethodVisitor的创建，mv是MethodVisitor实例 mv.visitTypeInsn(NEW, &quot;java/util/Scanner&quot;); mv.visitInsn(DUP); mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;in&quot;, &quot;Ljava/io/InputStream;&quot;); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/util/Scanner&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/io/InputStream;)V&quot;, false); mv.visitVarInsn(ASTORE, 0); 第二行和第三行都是读取double，这里是调用了Scanner的nextDouble方法，这里只给第二行的例子： mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/util/Scanner&quot;, &quot;nextDouble&quot;, &quot;()D&quot;, false); mv.visitVarInsn(DSTORE, 1); 接下来是个重头戏。首先来看看PrintStream::printf的定义： public PrintStream printf(String format, Object ... args) 可以看到，args是个不定长参数，这怎么表示呢？ 在Java中，不定长参数都被解析为数组，也就是说，它在字节码中的表示其实是这样的： public PrintStream printf(String format, Object[] args) 现在我们需要传递的参数就是一个字符串和一个Object数组。可是double不是引用类型，这又要怎么办呢？ 在Java中，基本类型都有它们的“包装类”。double的包装类是java.lang.Double，通过Double::valueOf方法就可以把double值转变为Double对象，也就是装箱操作。在平常编写时，Java编译器会自动为我们添加装箱操作，也就是自动装箱。 经过这样的解析，最后这句话的Java代码表示就像这样： System.out.printf(&quot;%.5f&quot;, new Object[] &#123; Double.valueOf(a * b) &#125;); 其中Object[]是一个长度为1的数组，也就是先创建它然后将Double对象用aastore字节码放入就行。 mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;); // System.out mv.visitLdcInsn(&quot;%.5f&quot;); // printf的第一个参数 mv.visitInsn(ICONST_1); // Object[]的长度 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/Object&quot;); // 创建Object[] mv.visitInsn(DUP); // 复制一份数组，一份用于放入对象，一份用于传入方法 mv.visitInsn(ICONST_0); // 放入数组的位置，0 mv.visitVarInsn(DLOAD, 1); // 取出a mv.visitVarInsn(DLOAD, 3); // 取出b（3是因为double要占两个局部变量槽位！） mv.visitInsn(DMUL); // 计算 a * b mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/Double&quot;, &quot;valueOf&quot;, &quot;(D)Ljava/lang/Double;&quot;, false); // 装箱 mv.visitInsn(AASTORE); // 放入数组 mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;printf&quot;, &quot;(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;&quot;, false); 最后写入return和visitMaxs，局部变量一共5个槽位，最大的操作栈大小是9： mv.visitInsn(RETURN); mv.visitMaxs(9, 5); 下面就可以实验了！ 3.22 6.11 19.67420 测试结果和预测一样！ 全部代码：https://paste.ubuntu.com/p/NXDfFpQ4y6/ 这篇专栏的内容结束了，下一篇：Java ASM详解：MethodVisitor与Opcode（三）标签，选择结构，循环结构，栈帧 这篇文章一共讲了34个字节码，从开始到现在一共讲了164个。 有错误在评论中指出。","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"JEP 412 Foreign Function & Memory (FFM) API 外部函数与内存API","slug":"JEP412 Foreign Function Memory FFM API外部函数与内存API","date":"2021-08-08T00:00:00.000Z","updated":"2021-08-30T11:30:21.000Z","comments":true,"path":"2021/08/08/JEP412 Foreign Function Memory FFM API外部函数与内存API/","link":"","permalink":"http://nickid2018.github.io/2021/08/08/JEP412%20Foreign%20Function%20Memory%20FFM%20API%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E5%AD%98API/","excerpt":"","text":"这篇专栏翻译自https://openjdk.java.net/jeps/412，”JEP 412: Foreign Function &amp; Memory API (Incubator)”，讲述了有关于Java 17中加入的FFM API。 前言引入一个可以让Java程序与Java运行时以外的代码和数据进行交换的API。通过高效的调用外部函数（即JVM外部的代码），并且通过安全地访问外部内存（即不是由JVM管理的内存），这套API能让Java程序调用本地库和操作本地数据的同时避免JNI的脆弱性和不安全性。 目标 易用性 - 将Java本地接口（JNI）替换为优越的，纯Java开发的模型 性能 - 提供与现有 API（如 JNI 和 sun.misc.Unsafe）相媲美（如果不是更好的话）的性能 通用性 - 提供操作不同类型的外部内存（如：本地内存，永久内存和堆内存）的方法，并且随着时间的推移，去适应其他的平台（如：32bit x86）和除C以外的语言（如：C++,Fortran）编写的外部函数 安全性 - 在默认情况下禁用不安全的操作，仅在从应用程序开发人员或最终用户明确选择后才能禁用它们 非目标 在此 API 之上重新实现JNI，或以任何方式修改JNI 在此 API 之上重新实现传统 Java API，例如：sun.misc.Unsafe类 提供从本地代码头文件中自动生成 Java 代码的工具，或者 更改与本地库交互的 Java 应用程序的包装和部署方式（例如，通过多平台 JAR 文件） 内容外部内存存储在Java运行时之外的内存的数据被称为堆外数据(off-heap data)。”heap”（堆）是Java对象生存（对象生命周期）的地方，也是垃圾回收（Garbage Collector，GC）处理的地方。访问堆外数据对于Tensorflow、Ignite、Lucene和Netty等Java库的性能至关重要，这主要是因为这避免了由垃圾回收引起的成本和不可预测性，并且这也允许程序通过mmap等将文件映射入内存中进行数据结构的序列化和反序列化。但是，Java平台到今天没有为访问堆外数据提供令人满意的解决方案。 ByteBuffer API（java.nio）允许创建直接缓冲区（direct buffer），这些缓冲区在堆外分配，但是它们的最大大小限制为2GB并且不能及时释放。这些和其他的限制都来源于一个事实：ByteBuffer API不仅被用于访问堆外内存，还被用于生产者/消费者之间批量数据的交换，如字符集的编码/解码和部分I/O操作。在这方面，它无法满足多年来提出的许多堆外内存增强请求。 sun.misc.Unsafe API暴露了堆内内存的访问操作，这对堆外内存也适用。使用它很高效，因为它的内存操作被定义在HotSpot JVM内部并且会被JIT编译器优化。但是，因为它可以访问任何内存位置，使用它是危险的。这意味着一个Java程序可以通过访问一个已经释放的内存位置使JVM崩溃。因为这个和其他的原因，使用Unsafe是强烈不被推荐的。 使用JNI调用本地库来访问堆外内存是可能的，但是因为它的效率开销（较高）而很少找到适用的地方：从Java到本地代码的速度要比直接访问内存的速度慢几个数量级，因为JNI方法调用并不能从常见的JIT优化（如内联）中获益。 总之，当访问堆外数据时，Java开发者就面临着两难的境地：他们是选择安全但效率不高的方式（ByteBuffer API）还是放弃安全转而选择性能（Unsafe API）？开发者需要的是一个Java支持的API，用于在JIT优化下从头到脚安全地访问堆外数据（即外部内存）。 外部函数从Java 1.1开始，JNI就已经支持本地代码的调用（即外部函数），但是因为很多原因它并不适合。 JNI涉及几个乏味的构件:Java API（本地方法）、源自Java API的C头文件（译注：即javah.exe的工作，当Java 10移除javah.exe后，这项工作由javac -h完成），以及调用感兴趣的本地库的C实现。Java开发人员必须跨多个工具链工作，以保持与平台相关的构件同步，当本地库快速发展时，这尤其繁重。 JNI只能与以一些语言（通常为C/C++）进行交互，这些库使用了JVM在构建中使用的操作系统和CPU的约定。本地方法不能被用于去调用一个由不同约定的语言编写的函数。 JNI没有协调Java类型系统和C类型系统。Java中的聚合数据是用对象表示的，但C中的聚合数据是用结构体表示的，因此传递给本地方法的任何Java对象都必须费力地由本地代码解包。例如，考虑一个Java中的记录（record，Java 16加入）类Person：将Person对象传递给本地方法将要求本地代码使用JNI的C API从对象中提取字段（例如，firstName和lastName）（译注：提取字段就是使用JNIEnv*的函数）。结果是，Java开发者们有些时候会把他们的数据转变成一个单独的对象（如：一个字节数组或一个direct ByteBuffer），但更常见的是，因为通过JNI传递Java对象很慢，他们就使用Unsafe API去分配堆外内存并且以long的形式将内存地址传递给本地方法（译注：比如LWJGL）——可悲的是这使得Java代码变得不安全！ 多年来，有许多框架填补JNI留下的空白，这其中包括JNA、JNR和JavaCPP。虽然这些框架通常被视为JNI的改进，但是情况依旧不理想，尤其是当与提供一流的本地代码交互的语言相比。比如，Python的ctypes包可以动态地将函数包装在本地库中而不用生成任何的粘合代码。其他语言，例如Rust，提供了可以从C/C++头文件中自动派生本地代码包装的工具。 总之，Java开发者应该有一个让他们能直接使用任何被认为对特定任务有用的本机库并且避免使用JNI带来的繁琐与沉闷的API。对于此的一个绝佳的抽象是方法句柄（Method Handle），它在Java 7被引入，用于支持在JVM上的快速动态语言（invokedynamic，inDy）。通过方法句柄公开本机代码将从根本上简化编写、构建和分发依赖于本机库的Java库的任务。此外，能够建模外部函数（即本机代码）和外部内存（即堆外数据）的API将为第三方本机交互框架提供坚实的基础。 描述外部函数与内存API（Foreign Function &amp; Memory API，下文简称为”FFM API”）定义了一系列类与接口以便于在库与应用程序中的客户端代码： 分配外部内存（MemorySegment，MemoryAddress和SegmentAllocator）,操作和访问结构化外部内存（MemoryLayout，MemoryHandles和MemoryAccess），管理外部资源的生命周期（ResourceScope）和调用外部函数（SymbolLookup和CLinker） FFM API定义在jdk.incubator.foreign模块下的jdk.incubator.foreign包内。 例子下面是一个简单的使用FFM API的例子，Java代码获得了一个C库函数radixsort的方法句柄，然后用它来对Java数组中的四个字符串进行排序（一些细节被省略了）： // 1. 在C库路径下寻找外部函数 MethodHandle radixSort = CLinker.getInstance().downcallHandle( CLinker.systemLookup().lookup(&quot;radixsort&quot;), ...); // 2. 分配堆内内存储存4个字符串 String[] javaStrings = &#123; &quot;mouse&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;car&quot; &#125;; // 3. 分配堆外内存储存4个指针 MemorySegment offHeap = MemorySegment.allocateNative( MemoryLayout.ofSequence(javaStrings.length, CLinker.C_POINTER), ...); // 4. 将字符串从堆内复制到堆外 for (int i = 0; i &lt; javaStrings.length; i++) &#123; // 分配一个堆外的字符串， 然后储存一个指向它的指针 MemorySegment cString = CLinker.toCString(javaStrings[i], newImplicitScope()); MemoryAccess.setAddressAtIndex(offHeap, i, cString.address()); &#125; // 5. 通过调用外部函数将堆外数据排序 radixSort.invoke(offHeap.address(), javaStrings.length, MemoryAddress.NULL, &#x27;\\0&#x27;); // 6. 将（已经排序后）的字符串数组从堆外复制到堆内 for (int i = 0; i &lt; javaStrings.length; i++) &#123; MemoryAddress cStringPtr = MemoryAccess.getAddressAtIndex(offHeap, i); javaStrings[i] = CLinker.toJavaStringRestricted(cStringPtr); &#125; assert Arrays.equals(javaStrings, new String[] &#123;&quot;car&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;mouse&quot;&#125;); // true 这段代码比任何使用JNI的解决方案都清晰得多，因为原本隐藏在本机方法调用后面的隐式转换和内存解引用现在直接用Java表示了。也可以使用现代Java语言特性；例如，流可以允许多个线程并行地在堆内和堆外内存之间复制数据。 内存段（Memory Segments）内存段是对位于堆外或堆内的连续内存区域进行建模的抽象。内存段可以为 本地段，在本地内存内从头开始分配（例如通过malloc），映射段，将映射包装在本地内存区域中（例如通过mmap），或者数组或缓冲区段，将现有的Java数组或字节缓冲区相关的内存分别包装 所有的内存段都提供了空间、时间和线程限制的保证，为了使内存解引用操作安全，这些保证都是强制的。例如，下面的代码在堆外分配了100个字节： MemorySegment segment = MemorySegment.allocateNative(100, newImplicitScope()); 段的空间边界决定了与段相关联的内存地址的范围。上面代码中段的边界由表示为MemoryAddress实例的基础地址b和以字节为单位的大小（100）定义，结果是地址范围从b到b + 99（包括b + 99）。 段的时间边界决定了段的生存期，也就是这个段什么时候会被释放。段的生存期和线程限制状态是通过ResourceScope抽象建模的，下面将对此进行讨论。上面代码中的资源作用域是一个新的隐式作用域，它确保当垃圾回收器认为MemorySegment对象不可达时才释放与此段相关的内存。隐式作用域还确保可以从多个线程访问内存段。 换句话说，上面的代码创建了一个行为与allocateDirect工厂分配的ByteBuffer的行为紧密匹配的段。FFM API还支持还支持确定性内存释放和其他线程限制选项，将在下面讨论。 解引用内存段与段关联的内存解引用是通过获取变量句柄来实现的，它是Java 9中引入的数据访问抽象模型。特别地，段是用内存访问变量句柄来解引用的。这种类型的变量句柄使用一对访问坐标： 以MemorySegment对象表示的坐标——也就是控制的内存要被解引用的段，和以long表示的坐标——也就是偏移量（offset），从段的基础地址到解引用开始的偏移量 内存访问变量句柄可以通过在MemoryHandles类中的工厂方法获取。例如，这段代码获取了可以将int写入本地内存段的内存访问变量句柄，并且使用它在连续的偏移下写入25个4字节的值（译注：指int为4字节）： MemorySegment segment = MemorySegment.allocateNative(100, newImplicitScope()); VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()); for (int i = 0; i &lt; 25; i++) &#123; intHandle.set(segment, /* 偏移 */ i * 4, /* 要写入的数据 */ i); &#125; 更高级的访问用法可以通过使用MemoryHandles类提供的一个或多个组合子方法来组合内存访问变量句柄来表达。使用这些客户端可以，例如，对给定的内存访问变量句柄进行重排序，删除一个或多个坐标，或插入新的坐标。这允许创建接受一个或多个逻辑索引到一个在堆外内存区域的多维数组中的内存访问变量句柄。 为了使FFM API更容易访问，MemoryAccess类提供了静态访问器来解引用内存段，而不需要构造内存访问变量句柄。例如，有一个访问器可以在给定偏移量的段中设置一个int值，允许上面的代码简化为： MemorySegment segment = MemorySegment.allocateNative(100, newImplicitScope()); for (int i = 0; i &lt; 25; i++) &#123; MemoryAccess.setIntAtOffset(segment, i * 4, i); &#125; 内存布局（Memory Layouts）为了减少对内存布局的繁琐计算(例如，上面例子中的i * 4)， MemoryLayout可以用更声明式的方式来描述内存段的内容。例如，上面例子中需要的本地内存段的布局可以用以下方式描述： SequenceLayout intArrayLayout = MemoryLayout.sequenceLayout(25, MemoryLayout.valueLayout(32, ByteOrder.nativeOrder())); 这将创建一个序列内存布局（sequence memory layout），内部由重复了25次的32比特值布局（一个描述了单一32字节值的布局）构成。给定一个内存布局，我们可以避免在代码中计算偏移量，并简化内存分配和创建内存访问变量句柄： MemorySegment segment = MemorySegment.allocateNative(intArrayLayout, newImplicitScope()); VarHandle indexedElementHandle = intArrayLayout.varHandle(int.class, PathElement.sequenceElement()); for (int i = 0; i &lt; intArrayLayout.elementCount().getAsLong(); i++) &#123; indexedElementHandle.set(segment, (long) i, i); &#125; intArrayLayout对象通过创建布局路径来驱动内存访问变量句柄的创建，该路径用于从复杂布局表达式中选择嵌套布局。intArrayLayout对象也驱动了本地内存段的分配，这个内存段基于来自于布局的大小和对齐信息。在之前的例子中的循环常数，也就是25，已经被序列布局的元素数量所替代。 资源作用域（Resource Scopes）在前面的例子中看到的所有内存段都使用了非确定性的释放：一旦内存段实例变得不可达，垃圾收集器就会释放与这些段相关的内存。我们说这样的段是隐式释放的。 在某些情况下，客户端可能希望控制何时发生内存释放。试想，例如，使用MemorySegment::map从一个文件中映射出一个很大的内存段。客户端可能更喜欢在段不再需要时释放（即取消映射）与段相关的内存，而不是等待垃圾收集器这样做，因为等待可能会对应用程序的性能产生不利影响。 内存段支持通过资源作用域的确定性释放。资源作用域对与一个或多个资源（如内存段）相关联的生命周期进行建模。新创建的资源作用域处于活动状态，这意味着可以安全地访问它管理的所有资源。在客户端请求时，可以关闭资源作用域，这意味着不再允许访问由该作用域管理的资源。因为ResourceScope类实现了AutoClosable接口，所以它可以使用try-with-resource语句： try (ResourceScope scope = ResourceScope.newConfinedScope()) &#123; MemorySegment s1 = MemorySegment.map(Path.of(&quot;someFile&quot;), 0, 100000, MapMode.READ_WRITE, scope); MemorySegment s2 = MemorySegment.allocateNative(100, scope); ... &#125; // 这两个内存段到这里被释放 这段代码创建了一个受限（confined）的资源作用域，并将其用于创建两个段：映射段（s1）和本地段（s2）。这两个段的生命周期与资源作用域的生命周期相关联，因此在try-with-resources语句完成后访问段（例如，使用内存访问变量句柄对它们进行解引用）将导致抛出一个运行时异常。 除了管理内存段的生命周期外，资源作用域还可以作为一种方法来控制哪些线程可以访问内存段。受限资源作用域只允许创建作用域的线程的访问，而共享资源作用域允许从任何线程访问。 资源作用域，无论是受限的还是共享的，都可能与java.lang.ref.Cleaner对象相关联，该对象负责执行隐式释放，以防在客户端调用close方法之前，资源作用域对象变得不可达。 一些称为隐式资源作用域的资源作用域不支持显式释放——调用close将失败。隐式资源作用域总是使用Cleaner来管理它们的资源。隐式作用域可以使用ResourceScope::newImplicitScope工厂创建，如前面的示例所示。 段分配器（Segment Allocators）当客户端使用堆外内存时，内存分配通常是一个瓶颈。FFM API包括一个SegmentAllocator抽象模型，它定义了分配和初始化内存段的操作。段分配器是通过SegmentAllocator接口中的工厂获得的。例如，下面的代码创建了一个基于区域（arena-based）的分配器，并使用它来分配一个内容是从Java int数组初始化的段： try (ResourceScope scope = ResourceScope.newConfinedScope()) &#123; SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope); for (int i = 0 ; i &lt; 100 ; i++) &#123; MemorySegment s = allocator.allocateArray(C_INT, new int[] &#123; 1, 2, 3, 4, 5 &#125;); ... &#125; ... &#125; // 所有分配的内存在此处被释放 这段代码创建一个受限的资源范围，然后创建与该范围相关联的无边界区域分配器（unbounded arena allocator）。这个分配器将分配特定大小的内存块，并通过返回预先分配的内存块的不同片（译注：也就是分配器先分配一定大小的块后，用户要求内存时按用户需求在内存块中取出相当长度的内存切片）来响应分配请求。如果一个内存块没有足够的空间来容纳一个新的分配请求，那么就分配一个新的内存块。如果与区域分配器相关联的资源作用域被关闭，所有与分配器创建的段相关联的内存（例如，在for循环体中）都会被以原子方式释放。这种用法结合了ResourceScope抽象提供的确定性释放的优点，以及更灵活和可伸缩的分配方案。在编写管理大量堆外内存段的代码时，它非常有用。 不安全的内存段到目前为止，我们已经看到了内存段、内存地址和内存布局。解引用操作只能在内存段上进行。由于内存段具有空间和时间边界，Java运行时总是可以确保与给定段相关联的内存被安全解引用。然而，在某些情况下，客户端可能只有MemoryAddress实例，这在与本机代码交互时经常发生。由于Java运行时无法知道与内存地址相关的空间和时间边界，因此FFM API禁止直接解引用内存地址。 为了解引用内存地址，客户端有两种选择： 如果已知地址位于一个内存段，客户端可以通过MemoryAddress::segmentOffset进行重新基准（rebase）操作。重新基准操作会重新定义地址相对于段的基本地址的偏移量，以产生一个新的可以应用于现有段上的偏移量——然后可以安全地对该段解引用。 或者，如果没有这样的段存在，那么客户端可以使用MemoryAddress::asSegment工厂不安全地创建一个。这个工厂有效地将新的空间和时间边界附加到一个原始的内存地址，以便允许解引用操作。该工厂返回的内存段是不安全的：一个原始内存地址可能与一个10字节长的内存区域相关联，但客户端可能意外地高估了该区域的大小，并创建了一个100字节长的不安全内存段。这可能会导致稍后试图对与不安全段关联的内存区域边界之外的内存的解引用，这可能会导致JVM崩溃，或者更糟的是，导致在无形中的内存损坏。因此，创建不安全的段被视为受限操作，默认情况下是禁用的（参见下面的详细内容）。 寻找外部函数任何对外部函数的支持的第一个组成部分都是加载本地库的机制。在JNI中，这是通过System::loadLibrary和System::load方法完成的，它们在内部映射到对dlopen或其等效函数的调用。使用这些方法加载的库总是与类加载器（即调用System方法的类加载器）相关联。库和类加载器之间的关联是至关重要的，因为它管理装入的库的生命周期：只有当类加载器不再可访问时，它的所有库才能被安全卸载。 FFM API没有提供加载本地库的新方法。开发者使用System::loadLibrary和System::load方法来加载将通过FFM API调用的本地库。库和类加载器之间的关联被保留，因此库将以与JNI相同的可预测方式卸载。 与JNI不同，FFM API提供了在加载的库中查找给定标识地址的功能。这种由SymbolLookup对象表示的功能对于将Java代码链接到外部函数至关重要（参见下面）。有两种方法可以获得SymbolLookup对象： SymbolLookup::loaderLookup返回一个包括本加载器内加载的所有库内部的标识的查找器 CLinker::systemLookup返回一个特定于平台的标识查找器，它能查找标准C库内的标识 给定一个标识查找器，客户端可以使用SymbolLookup::lookup(String)方法找到一个外部函数。如果指定的函数出现在标识查找器所包括的标识中，则该方法返回指向函数入口点的MemoryAddress。例如，下面的代码加载OpenGL库（使它与当前类加载器相关联），并找到它的glGetString函数的地址： System.loadLibrary(&quot;GL&quot;); SymbolLookup loaderLookup = SymbolLookup.loaderLookup(); MemoryAddress clangVersion = loaderLookup.lookup(&quot;glGetString&quot;).get(); 将Java代码链接到外部函数CLinker接口是Java代码与本地代码交互的核心。虽然CLinker专注于提供Java和C库之间的互操作，但接口中的概念已经足够通用，可以在未来支持其他非Java语言。该接口支持向下调用（downcall，从Java代码调用本地代码）和向上调用（upcall，从本地代码调用回Java代码）。 interface CLinker &#123; MethodHandle downcallHandle(MemoryAddress func, MethodType type, FunctionDescriptor function); MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope); &#125; 对于向下调用，downcallHandle方法接受外部函数的地址——通常是从库查找中获得的MemoryAddress——并将外部函数作为向下调用方法句柄公开。稍后，Java代码通过调用invokeExact方法调用downcall方法句柄，然后运行外部函数。传递给方法句柄的invokeExact方法的任何参数都会传递给外部函数。 对于上行调用，upcallStub方法接受一个方法句柄——通常是指一个Java方法句柄，而不是下行调用方法句柄——并将其转换为内存地址。稍后，当Java代码调用downcall方法句柄时，将内存地址作为参数传递。实际上，内存地址充当函数指针。（欲了解更多关于upcall的信息，请参阅下面） 假设我们想从Java向下调用定义在C标准库中的strlen函数： size_t strlen(const char *s); 一个暴露strlen的向下调用方法句柄可以像下面这样获取（关于MethodType和FunctionDescriptor的细节将会简短介绍）： MethodHandle strlen = CLinker.getInstance().downcallHandle( CLinker.systemLookup().lookup(&quot;strlen&quot;).get(), MethodType.methodType(long.class, MemoryAddress.class), FunctionDescriptor.of(C_LONG, C_POINTER) ); 调用向下调用方法句柄会执行strlen并且让结果在Java端可见。对于strlen的参数，我们使用一个helper方法将Java的字符串转变为堆外内存段并且传递这个段的地址： MemorySegment str = CLinker.toCString(&quot;Hello&quot;, newImplicitScope()); long len = strlen.invokeExact(str.address()); // 5 方法句柄在公开外部函数时工作得很好，因为JVM已经优化了方法句柄的调用，一直优化到本地代码。当方法句柄引用类文件中的方法时，调用方法句柄通常会导致目标方法被JIT编译；随后，JVM通过将控制转移到为目标方法生成的汇编代码来解释调用MethodHandle::invokeExact的Java字节码。因此，调用传统方法句柄已经几乎是外部调用；以C库中的函数为目标的downcall方法句柄只是一种更外部的方法句柄形式。方法句柄还具有一个名为签名多态性的属性，该属性允许基本类型参数的非装箱传入（译注：就是直接传int而不是Integer避免装箱/拆箱操作）。总之，方法句柄让CLinker以一种自然、有效和可扩展的方式公开外部函数。 在Java中描述C类型为了创建向下调用方法句柄，FFM API需要客户端提供对于目标C函数的两种签名：使用非透明的Java对象（MemoryAccess和MemorySegment）的高级别签名和使用透明的Java对象（MemoryLayout）的低级别签名。依次取每个签名： 高级别签名，即MethodType，用作向下调用方法句柄的类型。每个方法句柄都是强类型的，这意味着可以传递给它的invokeExact方法的参数的数量和类型是严格的。例如，为接受一个MemoryAddress参数而创建的方法句柄不能通过invokeExact(MemoryAddress, MemoryAddress)或通过invokeExact(“Hello”)调用。因此，MethodType描述了客户端在调用向下调用方法句柄时必须使用的Java签名。实际上，它是C函数的Java视图。 低级别签名，即FunctionDescriptor，包含MemoryLayout对象。这使CLinker能够精确地理解C函数的参数，以便它能够正确地安排它们，如下所述。客户端通常有MemoryLayout对象，以便解引用外部内存中的数据，这样的对象可以在这里作为外部函数签名重用。 例如，为接受int值并返回long值的C函数获取向下调用方法句柄时，downcallHandle方法需要以下MethodType和FunctionDescriptor参数： MethodType mtype = MethodType.methodType(long.class, int.class); FunctionDescriptor fdesc = FunctionDescriptor.of(C_LONG, C_INT); 这个例子的目标系统是Linux/x64和macOS/x64，其中Java类型long和int分别与预定义的CLinker布局C_LONG和C_INT关联。Java类型与内存布局的关联因平台而异：例如，在Windows/x64上，Java long与C_LONG_LONG布局相关联 译注：这里的原因是C中long的位数取决于系统，而long long为确定64位；在Java中，int确定32位而long为64位，为了确保数据的对齐需要调整布局 另一个例子，获取一个带有指针的void C函数的向下调用方法句柄需要以下MethodType和FunctionDescriptor： MethodType mtype = MethodType.methodType(void.class, MemoryAddress.class); FunctionDescriptor fdesc = FunctionDescriptor.ofVoid(C_POINTER); C语言中的所有指针类型在Java中都表示为MemoryAddress对象，对应的布局是C_POINTER，其大小取决于当前平台。客户端不会区分int*和char**，因为传递给CLinker的Java类型和内存布局包含足够的信息来正确地将Java参数传递给C函数 最后，与JNI不同的是，CLinker支持将结构化数据传递给外部函数。获取一个接受struct的无返回值C函数的向下调用方法句柄需要以下MethodType和FunctionDescriptor： MethodType mtype = MethodType.methodType(void.class, MemorySegment.class); MemoryLayout SYSTEMTIME = MemoryLayout.ofStruct( C_SHORT.withName(&quot;wYear&quot;), C_SHORT.withName(&quot;wMonth&quot;), C_SHORT.withName(&quot;wDayOfWeek&quot;), C_SHORT.withName(&quot;wDay&quot;), C_SHORT.withName(&quot;wHour&quot;), C_SHORT.withName(&quot;wMinute&quot;), C_SHORT.withName(&quot;wSecond&quot;), C_SHORT.withName(&quot;wMilliseconds&quot;) ); FunctionDescriptor fdesc = FunctionDescriptor.ofVoid(SYSTEMTIME); 对于高级别的MethodType签名，Java客户端总是使用不透明的类型MemorySegment，其中C函数需要一个按值传递的struct。对于低级别的FunctionDescriptor签名，与C结构类型相关联的内存布局必须是一个复合布局，它定义了C的struct中所有字段的子布局，包括可能由本地编译器插入的填充 如果C函数返回由低级别签名表示的按值struct，则必须在堆外分配一个新的内存段并返回给Java客户端。为了实现这一点，downcallHandle返回的方法句柄需要一个额外的SegmentAllocator参数，FFM API使用该参数分配内存段来保存C函数返回的struct。 为C函数打包Java参数不同语言之间的交互操作需要一个调用约定来指定一种语言中的代码如何调用另一种语言中的函数、如何传递参数以及如何接收任何结果。CLinker实现具有一些”开箱即用”的调用约定的知识：Linux/x64、Linux/AArch64、macOS/x64和Windows/x64。CLinker是用Java编写的，维护和扩展起来要比JNI容易得多，JNI的调用约定是硬连接到HotSpot的C++代码中的（译注：JNI的调用约定即JNIEnv*）。 考虑上面显示的SYSTEMTIME结构和布局的函数描述符（FunctionDescriptor）。根据运行JVM的操作系统和CPU的调用约定，当使用MemorySegment参数调用向下调用方法句柄时，CLinker使用函数描述符来推断结构体的字段应该如何传递给C函数。对于一个调用约定，CLinker可以安排分解传入的内存段，使用通用CPU寄存器传递前四个字段，并在C堆栈上传递其余字段。对于不同的调用约定，CLinker可以安排FFM API通过分配一个内存区域来间接传递结构体，将传入内存段的内容批量复制到该区域，并将指向该内存区域的指针传递给C函数。这种最低层次的参数打包是在幕后进行的，不需要任何客户端代码的监督。 向上调用有时，将Java代码作为函数指针传递给某个外部函数是很有用的。我们可以通过使用对上行调用的CLinker支持来实现这一点。在本节中，我们将逐块构建一个更复杂的示例，该示例演示了CLinker的全部功能，以及代码和数据跨Java/本地边界的完全双向互操作。 考虑标准C库中定义的以下函数： void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 为了从Java端调用qsort，我们首先需要创建向下调用方法句柄： MethodHandle qsort = CLinker.getInstance().downcallHandle( CLinker.systemLookup().lookup(&quot;qsort&quot;).get(), MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class), FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER) ); 和前面一样，我们使用C_LONG和long.class来映射C size_t类型，并且在第一个指针形式参数（数组指针）和最后一个形式参数（函数指针）上使用MemoryAddress.class。 qsort使用作为函数指针传递的自定义比较器函数compar对数组的内容进行排序。因此，要调用向下调用方法句柄，我们需要一个函数指针作为最后一个参数传递给方法句柄的invokeExact方法。CLinker::upcallStub通过使用现有的方法句柄帮助我们创建函数指针，如下所示。 首先，我们在Java中编写一个静态方法来比较两个long值，间接表示为MemoryAddress对象： class Qsort &#123; static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) &#123; return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue()) - MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue()); &#125; &#125; 接着，我们创建一个指向Java比较方法的MethodHandle： MethodHandle comparHandle = MethodHandles.lookup() .findStatic(Qsort.class, &quot;qsortCompare&quot;, MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)); 之后，现在我们有了Java比较器的方法句柄，我们可以使用CLinker::upcallStub创建函数指针。就像向下调用一样，我们使用CLinker类中的布局来描述函数指针的签名： MemoryAddress comparFunc = CLinker.getInstance().upcallStub(comparHandle, FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER), newImplicitScope()); ); 我们终于有了一个内存地址，comparFunc，它指向一个方法存根，可以用来调用我们的Java比较方法，所以现在我们有了调用qsort向下调用句柄所需的所有东西： MemorySegment array = MemorySegment.allocateNative(4 * 10, newImplicitScope()); array.copyFrom(MemorySegment.ofArray(new int[] &#123; 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 &#125;)); qsort.invokeExact(array.address(), 10L, 4L, comparFunc); int[] sorted = array.toIntArray(); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 这段代码创建了一个堆外数组，将Java数组的内容复制到其中，然后将数组连同我们从CLinker获得的比较器函数（指针）传递给qsort句柄。调用之后，堆外数组的内容将根据我们用Java编写的比较器函数进行排序。然后从段中提取一个新的Java数组，其中包含已排序的元素。 安全基本上，Java代码和本机代码之间的任何交互都可能危及Java平台的完整性。链接到预编译库中的C函数本质上是不可靠的，因为Java运行时不能保证函数的签名符合Java代码的期望，甚至不能保证C库中的标识是真正的函数。此外，如果链接了一个合适的函数，实际上调用该函数可能会导致如分段错误的底层故障，最终导致VM崩溃。Java运行时无法阻止此类故障，Java代码也无法捕获此类故障。 使用JNI函数的本地代码尤其危险。这样的代码可以在没有命令行标志（例如--add-open）的情况下，通过使用getStaticField和callVirtualMethod等函数访问JDK内部。它还可以在final字段初始化很久之后更改它们的值。它允许本地代码绕过应用于Java代码的检查，这会破坏JDK中的每个边界和假设。换句话说，JNI本质上就是不安全的。 JNI不能被禁用，因此无法确保Java代码不会调用使用危险的JNI函数的本地代码。这是对平台完整性的一种风险，应用程序开发人员和最终用户几乎看不到这种风险，因为这些函数99%的使用通常来自夹在应用程序和JDK之间的第三、第四和第五方库。 大多数FFM API的设计是安全的。过去需要使用JNI和本地代码的许多场景都可以通过调用不会危及Java平台的FFM API中的方法来实现。例如，JNI的一个主要用例——灵活的内存分配——是由一个简单的方法MemorySegment::allocateNative支持的，该方法不涉及本机代码，并且总是返回由Java运行时管理的内存。一般来说，使用FFM API的Java代码不会使JVM崩溃。 然而，FFM API的一部分本身就是不安全的。当与CLinker交互时，Java代码可以通过指定与底层C函数不兼容的参数类型来请求向下调用方法句柄。在Java中调用向下调用方法句柄会导致与在JNI中调用本机方法时相同的结果——VM崩溃或未定义的行为。FFM API也可以产生不安全的段，即内存段的空间和时间边界是用户提供的，这种段不能由Java运行时验证（参见上文的MemoryAddress::asSegment）。 FFM API中的不安全方法不会带来与JNI函数相同的风险：例如，它们不能更改Java对象中的final字段的值。另一方面，FFM API中的不安全方法很容易从Java代码中调用。由于这个原因，FFM API中不安全方法的使用受到限制：默认情况下，不安全方法的访问是禁用的，调用这些方法会抛出一个IllegalAccessException异常。要使某些模块M中的代码能够访问不安全的方法，请在命令行中指定java --enable-native-access=M。（在以逗号分隔的列表中指定多个模块；指定ALL-UNNAMED以允许类路径上的所有代码访问不安全方法）FFM API的大多数方法都是安全的，Java代码可以使用这些方法，不管是否给出了—enable-native-access。 我们在这里不建议限制JNI的任何方面。在Java中仍然可以调用本地方法，本地代码也可以调用不安全的JNI函数。然而，在未来的版本中，我们可能会以某种方式限制JNI。例如，不安全的JNI函数（如newDirectByteBuffer）可能会在默认情况下被禁用，就像FFM API中的不安全方法一样。更广泛地说，JNI机制是如此的危险，以至于我们希望库在安全和不安全的操作中偏向于纯Java的FFM API，这样我们就可以在默认情况下禁用所有JNI。这与使平台成为“开箱即用”的安全平台的更广泛的Java路线图一致，要求终端用户选择不安全的行为，如破坏强封装或链接到未知代码。 我们不建议以任何方式去修改sun.misc.Unsafe。FFM API对堆外内存的支持是对sun.misc.Unsafe中的malloc和free，即allocateMemory, setMemory, copyMemory，和freeMemory的一个很好的替代方案。我们希望需要非堆存储的库和应用程序采用FFM API，以便及时地弃用并最终删除这些sun.misc.Unsafe方法。 选择继续使用java.nio.ByteBuffer，sun.misc.Unsafe，JNI和其他第三方框架。 风险和假设创建一个API以既安全又高效的方式访问外部内存是一项艰巨的任务。由于前几节中描述的空间和时间检查需要在每次访问时执行，因此JIT编译器能够优化这些检查是至关重要的，例如，将它们提升到热循环之外。JIT实现可能需要做一些工作，以确保API的使用与ByteBuffer和Unsafe等现有API的使用一样有效和可优化。JIT实现还需要确保从API中检索到的本地方法句柄的使用至少与使用现有JNI本地方法一样有效和可优化。 依赖 外部函数和内存API可以用来访问非易失性内存，已经可以通过JEP 352（非易失性映射字节缓冲区，Non-Volatile Mapped Byte Buffers，Java 14引入）用一种更通用和更有效的方式访问 这里描述的工作可能会使后续工作能够提供一个工具，jextract，它从给定本地库的头文件开始，机械地生成与该库交互操作所需的本机方法句柄。这将进一步减少使用Java本地库的开销","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"JEP","slug":"JEP","permalink":"http://nickid2018.github.io/tags/JEP/"}]},{"title":"Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算","slug":"Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算","date":"2021-04-07T00:00:00.000Z","updated":"2021-08-29T00:00:00.000Z","comments":true,"path":"2021/04/07/Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算/","link":"","permalink":"http://nickid2018.github.io/2021/04/07/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AMethodVisitor%E4%B8%8EOpcode%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BF%90%E7%AE%97/","excerpt":"","text":"前文我们说到了很多Visitor，它们用于给类中定义类型，添加字段，附上注释。但是对于一个语言来说，最重要的那一部分我们还没有说到——那就是：方法。 方法定义在ClassVisitor中，我们看到了有一个方法名为visitMethod，参数是(int，String，String，String，String[])，按照参数列表的顺序，它们分别指访问标志，方法名，方法描述符，泛型签名和抛出异常列表，返回一个MethodVisitor。（关于方法描述符，请看此系列的第一篇；关于访问标志，请看第二篇） 对于方法名，有下面的规则： 1.方法名不能是关键字或保留字（goto） 2.方法名不能以数字开头 3.可以为&lt;init&gt;和&lt;clinit&gt; 其中，&lt;init&gt;是构造函数，一个类可以有不止一个构造函数。而&lt;clinit&gt;每个类最多有一个，并且方法描述符必须为()V，它在类初始化阶段被JVM调用。（包括调用这个类的成员和Class.forName，但不包括Class.forName的initialize参数为false时的调用） 若方法名不正确，在尝试加载这个类的时候会抛出java.lang.ClassFormatError: Illegal method name。 抛出异常列表中，所有的类名称都为全限定名。 操作栈（Operand Stack）操作栈是一个方法被调用时JVM分配出来的一个栈空间，它用于存储方法内加载的数据和进行字节码指令操作。当JVM接收到一个字节码指令（例如iadd），就会取出栈顶的几项元素（对于iadd来说，就是栈顶的两项），在进行操作之后，将计算或获得的数据放回栈顶（比如iadd计算栈顶两个int的加和之后会放回加和数字）。 对于普通的对象，只会占用一个栈元素。但对于long或double这种对象，会占用两个栈元素。这有关于之后要介绍的visitMaxs。 如果一个字节码需要超过了现在操作栈内的元素数量的元素，那么在调用生成的方法时会抛出java.lang.VerifyError: Unable to pop operand off an empty stack。 如果一个字节码需要的类型与现在操作栈中元素类型不同，那么在调用生成的方法时抛出java.lang.VerifyError: Register &lt;slot&gt; contains wrong type或java.lang.VerifyError: Bad type on operand stack。 在之后的讲解中，我们会大量的使用这个名词，在接下来的编写中，操作栈的变化将会像下面这样写： 输入：XXX YYY 输出：ZZZ 局部变量表（Local Variable Table）局部变量表在方法调用中分配的另一个空间，用于存储现在方法内所有的局部变量，表中的数据可以被编号为0-n，叫Slot。普通的元素只会占用一个Slot，但long和double这种数据会占用两个。关于这个的详细使用，请看下面的xload和xstore的字节码介绍。 当这个方法为静态方法时，局部变量表会将参数列表中的变量按顺序放入局部变量表中。 当这个方法不是静态方法，局部变量表的0位是this，之后才会将参数列表变量依次放入表中。 如果局部变量表大小超过了256，那么字节码将会发生变化，xload、xstore等都会受到影响（需要以wide字节码辅助才能进行正常的局部变量读取写入）。但是ASM9中不提供wide字节码，因为MethodWriter中有ASM库自己的处理，所以在用户层编写ASM是无影响的。 MethodVisitor的方法在说完操作栈的概念之后，我们来看看MethodVisitor中都定义了哪些有关于字节码和执行的方法。 下面这些方法第一个参数都为字节码。 visitInsn(int)：访问一个零参数要求的字节码指令，如ACONST_NULL visitIntInsn(int, int)：访问一个需要零操作栈要求但需要有一个int参数的字节码指令，如BIPUSH visitVarInsn(int, int)：访问一个有关于局部变量的字节码指令，如ALOAD visitTypeInsn(int, String)：访问一个有关于类型的字节码指令，如CHECKCAST visitFieldInsn(int, String, String, String)：访问一个有关于字段的字节码，如PUTFIELD visitMethodInsn(int, String, String, String, boolean)：访问一个有关于方法调用的字节码，如INVOKESPECIAL visitJumpInsn(int, Label)：访问跳转字节码，如IFEQ 之后，是一些被包装好的字节码访问方法，这些方法都基于最基本的字节码指令，但是不需要我们自己用上面提到的那些方法直接调用字节码。 visitInvokeDynamicInsn(String, String, Handle, Object...)：基于INVOKEDYNAMIC，动态方法调用，会在lambda表达式和方法引用里面说到 visitLdcInsn(Object)：基于LDC、LDC_W和LDC2_W，将一个常量加载到操作栈用（详细见下文） visitIincInsn(int, int)：基于IINC、IINC_W，自增/减表达式 visitTableSwitchInsn(int, int, Label, Label...)：基于TABLESWITCH，用于进行table-switch操作 visitLookupSwitchInsn(Label, int[], Label[])：基于LOOKUPSWITCH，用于进行lookup-switch操作 visitMultiANewArrayInsn(String, int)：基于MULTIANEWARRAY，用于创建多重维度数组，如int[][] 在下文说到它们时，会以下面的方式表达： 方法：visitXXXInsn 参数：XXX YYY ZZZ 到这里，所有有关于字节码指令的方法就结束了。块级结构的方法会在下一篇说。 最后，说一下每个方法都要在最后调用的方法：visitMaxs(int, int)。它第一个参数是操作栈的最大大小，第二个是局部变量的个数。如果你调用这个方法时局部变量数量写小了，就会在生成方法调用时抛出java.lang.ClassFormatError: Arguments can&#39;t fit into locals，如果操作栈大小写小了，在生成方法调用时会抛出java.lang.VerifyError: Stack size too large 那么下面，我们将逐系列逐条讲解所有的字节码。这篇专栏先讲基本的操作栈加载存储等操作、常量获取和运算操作。 注意：接下来的x可以为a（针对对象）、i（针对int）、l（针对long）、f（针对float）、d（针对double）、b（针对byte）、c（针对char）、s（针对short），它代表了操作对象的类型。有些时候没有针对于byte和short的专用字节码，这是因为在JVM中，byte和short在被计算时会被强制拉长为int，所以它们使用的和int一样。char和int能互相转换。boolean类似，它们也需要使用int的字节码，而且boolean值的false就是int值0，而true就是int值1。 字节码介绍啥事都不干的字节码：nop输入：无 输出：无 方法：visitInsn 参数：无 使用范例： mv.visitInsn(NOP); 这个字节码啥都不干，在实际开发中可以当做代码插入点使用。 加载字节码：xload与xload_nx=a/i/l/f/d 输入：无 输出：某一对象或基本数据类型数据 方法：visitVarInsn 参数：加载对象的位置 使用范例： mv.visitVarInsn(ALOAD, 5); mv.visitVarInsn(FLOAD, 3); // 在javap反汇编中，此处变为fload_3 如果在调用此字节码时对应位置没有初始化变量（原先为参数或已经用xstore进行值的放入被视为该位置被初始化），在生成方法调用时会抛出java.lang.VerifyError: Accessing value from uninitialized register &lt;slot&gt;。 如果要进行加载的对象位置小于等于3，可以用对应的xload_n版本代替（注意，ASM9的Opcodes中已经不存在xload_n版本的字节码常量，但是在javap反汇编时可以看到此条），例如aload_2。 存储字节码：xstore与xstore_nx=a/i/l/f/d;n=0,1,2,3 输入：某一对象或基本类型数据 输出：无 方法：visitVarInsn 参数：存储对象的位置 使用范例： mv.visitVarInsn(ASTORE, 4); mv.visitVarInsn(ISTORE, 1); // 在javap反汇编中，此处变为istore_1 存储对象的位置规则与加载相同。与加载规则不同的是，xstore可以指定到一个未初始化的位置，并将这个位置初始化。有意思的一点是，你可以不遵循初始化位置的连续性，也就是说，假如2、3位置都未初始化，你可以通过xstore将对象放入3中并初始化它，这时位置2变为了未定义的状态，它在被xload加载时都会抛出java.lang.VerifyError: Register &lt;slot&gt; contains wrong type，即使你用的加载指令与放入指令类型相同。这时你只能通过另一次xstore将对象放入位置2，才能使这个位置类型固定。 和xload一样，xstore也有xstore_n版本，但ASM9已经不支持直接写入它们了。 返回字节码：(x)returnx=a/i/l/f/d 输入：某一对象或基本类型数据 输出：清空操作栈并返回 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ARETURN); mv.visitInsn(RETURN); // 无返回，用于void方法 返回字节码是每个方法必有的，包括void无返回值方法。如果一个方法没有写任何的返回字节码指令，在调用这个生成的方法时就会抛出java.lang.VerifyError: Falling off the end of the code。 返回字节码无视操作栈内剩余的所有值，只会将栈顶元素返回，并清除操作栈。 在这个方法为同步方法的前提下，所在线程不是已经锁定的监视器对象所有者时，这条指令会抛出IllegalMonitorStateException。这种情况在普通状况下根本无法发生，只有当这个同步方法上在其同步对象上使用了monitorexit却没有使用monitorenter时可能发生。 复制栈顶字节码：dup家族方法：visitInsn 参数：无 使用范例： mv.visitInsn(DUP); 每种字节码的解析： 1. DUP 输入：...v1 输出：...v1 v1 2. DUP_X1 输入：...v2 v1 输出：...v1 v2 v1 3. DUP_X2 输入：...v3 v2 v1 输出：...v1 v3 v2 v1 4. DUP2 输入：...v2 v1 输出：...v2 v1 v2 v1 5. DUP2_X1 输入：...v3 v2 v1 输出：...v2 v1 v3 v2 v1 6. DUP2_X2 输入：...v4 v3 v2 v1 输出：...v2 v1 v4 v3 v2 v1 这个字节码是用于复制栈顶元素并插入到栈中的字节码，可以节省xload和xstore的使用量。在这里，…指栈顶下的其他元素。 DUP家族的名称规律是：DUP后紧接着的数字代表了复制数量，Xn代表插入到栈顶下第几层。 弹出栈顶字节码：pop，pop2输入：一（pop）或两（pop2）个元素 输出：弹出栈顶一（pop）或两（pop2）个元素 方法：visitInsn 参数：无 使用范例： mv.visitInsn(POP); mv.visitInsn(POP2); 这个字节码也是用于操作操作栈的。它的使用情况举一个例子：调用了一个有返回值的方法但返回值我们不需要，就可以采用POP。 交换元素字节码：swap输入：两个元素 输出：交换栈顶两个元素 方法：visitInsn 参数：无 使用范例： mv.visitInsn(SWAP); 这个字节码可以交换栈顶的两个操作数。 常量池常量读取字节码：ldc（ldc_w, ldc2_w）输入：无 输出：从常量池读取出的数据 方法：visitLdcInsn 参数：常量值（见下文） [在JVM中，此处是常量池中对应常量的序号，长度分为三种，由三种LDC指令决定] 使用范例： mv.visitLdcInsn(&quot;helloworld&quot;); mv.visitLdcInsn(20.0f); // 注意，此处自动装箱成为Float mv.visitLdcInsn(Type.getType(&quot;I&quot;)); // 类型 常量池（Constant Pool）中，含有以下几种数据：整数Integer、浮点数Float、字符串字面值常量String、类的引用Type、句柄Handle或动态常量值ConstantDynamic，所以LDC值可能有这些。 在JVM中，如果常量值是Integer或Float，就会直接将它们放到操作栈顶；如果为String，将String类的引用放到操作栈顶；若为Type，将对应的类型初始化，并将其Class实例引用放到操作栈顶；对于Handle，将java.lang.invoke.MethodHandle/MethodType的引用至于操作栈顶。 在解析类型的引用期间（Type），这条指令可能会抛出有关于类加载的异常；同样的，解析有关于句柄（Handle）的时候也有可能抛出和句柄有关的异常。 空值常量字节码：aconst_null输入：无 输出：常量值null 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ACONST_NULL); 当程序中使用了null，就可以用这个字节码。 普通数字常量字节码：xconst_nx=i/l/f/d;对于iconst，n=m1,0,1,2,3,4,5;对于lconst、dconst，n=0,1;对于fconst，n=0,1,2 输入：无 输出：数字常量值，类型与字节码有关 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ICONST_M1); // -1 mv.visitInsn(FCONST_0); // +0.0f mv.visitInsn(LCONST_1); // 1L 当数字较小时，获得数字常量可以不使用LDC，可以直接用这些字节码代替（节省常量池空间）。 整数常量字节码：bipush和sipush输入：无 输出：数字常量值 方法：visitIntInsn 参数：某一具体整数 对于bipush，数字属于byte范围（-128~127） 对于sipush，数字属于short范围（-32768~32767） 使用范例： mv.visitIntInsn(BIPUSH, 27); // 27 mv.visitIntInsn(SIPUSH, -2700); // -2700 当一个数字没有超过这两个字节码规定的范围，我们都可以使用这两个字节码获取整数常量。在编译中，属于这个范围的数字都是用它们进行获取整数（除非是-1~5），而更大/小的整数都是用LDC。 说完了基本的加载存储常量指令，下面来看看程序的最基本功能：计算。 取反运算字节码：xnegx=i/l/f/d 输入：数字 输出：数字的相反数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(INEG); mv.visitInsn(DNEG); 这个字节码用于计算取反（-x）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于整数（int和long），计算规则就是(~x)+1，当它们处于MIN_VALUE时，取反结果仍为MIN_VALUE。 对于浮点数（double和float），这个字节码运算为： 取反与从零减去不等价，若x为+0.0，0.0-x结果为+0.0，而-x为-0.0 若数字为NaN（Not A Number，float的0x7fc00000或double的0x7ff8000000000000L），结果也为NaN 若数字为无穷大（float正0x7f800000负0xff800000，double正0x7ff0000000000000L负0xfff0000000000000L），结果为相反符号的无穷大 若数字为0，结果为相反符号的0 加法运算字节码：xaddx=i/l/f/d 输入：加数1 加数2 输出：数字的和 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IADD); mv.visitInsn(DADD); 这个字节码用于计算加法（a+b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于浮点数（double和float），这个字节码运算为： 如果两个数都为NaN，结果是NaN。 如果两个数为相反符号的无穷大，和为NaN 同一符号的无穷大结果是该符号的无穷大 有限值与无穷大的和还是无穷大 相反符号的两个0（+0.0和-0.0）结果为+0.0 相同符号的两个0和为该符号的0 0与非零值的和为非零值 符号相反，绝对值相等的有限值和为+0.0 若不属于上面的情况，结果将以IEEE 754舍入到最近可表示的浮点值。如果结果太大无法表示为浮点数（超过最大表示范围“溢出”，也就是绝对值超过float的3.4028235e+38f或double的1.7976931348623157e+308），结果为对应符号的无穷大；如果结果太小无法表示为浮点数（超过最小表示范围“下溢”，也就是绝对值小于float的1.4e-45f或double的4.9e-324），结果是对应符号的0。 减法运算字节码：xsubx=i/l/f/d 输入：被减数 减数 输出：两数字之差 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ISUB); mv.visitInsn(DSUB); 这个字节码用于计算减法（a-b），等价于a+(-b)。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 浮点数运算法则请同时参照xadd与xneg。 乘法运算字节码：xmulx=i/l/f/d 输入：乘数1 乘数2 输出：两数字之积 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IMUL); mv.visitInsn(DMUL); 这个字节码用于计算乘法（a*b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于浮点数（double和float），这个字节码运算为： 两个数字中有一个是NaN，结果为NaN 无穷大乘以一个0，结果为NaN 无穷大与有限值相乘，结果为无穷大，符号取决于两个数字的符号是否相同，相同为正，相反为负 其余情况为IEEE 754规定，在xadd那里有完整说明 除法运算字节码：xdivx=i/l/f/d 输入：被除数 除数 输出：两数字之商 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IDIV); mv.visitInsn(DDIV); 这个字节码用于计算除法（a/b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于整数（int和long），这个字节码只会保留商的整数部分。如果除数为0，这个字节码会抛出java.lang.ArithmeticException: / by zero 对于浮点数（double和float），这个字节码运算为： 两个数字中有一个是NaN，结果为NaN 无穷大除以无穷大，结果为NaN 无穷大除以有限值，结果为无穷大，符号取决于两个数字的符号（规则见xmul） 有限值除以无穷大，结果为0，符号同上 0除以0为NaN 0除以有限值为0，符号同上 有限值除以0为无穷大，符号同上 其余情况为IEEE 754规定，在xadd那里有完整说明 取余运算字节码：xremx=i/l/f/d 输入：被除数 除数 输出：余数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IREM); mv.visitInsn(DREM); 这个字节码用于计算取余操作（a%b）。注意：如果计算时数字溢出、下溢或精度丢失，这个字节码也不会反馈任何警告。 对于浮点数（double和float），这个字节码运算为： 两个数字中有一个是NaN，结果为NaN 符号取决于被除数 被除数为无穷大或除数为0，结果为NaN 被除数为有限值而除数为无穷大，结果为被除数 被除数为0，结果为0 其余情况为IEEE 754规定，在xadd那里有完整说明 自增字节码：iinc（iinc_w）输入：无 输出：无 方法：visitIincInsn 参数：对象位置，自增大小（int范围） 使用范例： mv.visitIincInsn(0, 200); mv.visitIincInsn(1, -40); 自增字节码是适用于int的字节码，在以下情境中会用到: i++或i—或++i或—i i+=x或i-=x 自增字节码可以使用负数。 按位且运算字节码：xandx=i/l 输入：整数1 整数2 输出：按位且的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(IAND); 这个字节码用于计算按位且操作（a&amp;b）。 按位或运算字节码：xorx=i/l 输入：整数1 整数2 输出：按位或的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LOR); 这个字节码用于计算按位或操作（a|b）。 按位异或运算字节码：xxorx=i/l 输入：整数1 整数2 输出：按位异或的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LXOR); 这个字节码用于计算按位或操作（a^b）。 同时，这个字节码还可以用于计算按位取反（这也是JVM的实现）：~x=x^(-1)。 mv.visitVarInsn(ILOAD, 0); mv.visitInsn(ICONST_M1); mv.visitInsn(IXOR); 按位左移运算字节码：xshlx=i/l 输入：整数 左移位数 输出：按位左移的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LSHL); 这个字节码用于计算按位左移操作（a&lt;&lt;b）。如果左移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行左移操作。 按位右移运算字节码：xshrx=i/l 输入：整数 右移位数 输出：按位右移的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(ISHR); 这个字节码用于计算按位右移操作（a&gt;&gt;b）。如果右移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行右移操作。 按位无符号右移运算字节码：xushrx=i/l 输入：整数 右移位数 输出：按位无符号右移的整数 方法：visitInsn 参数：无 使用范例： mv.visitInsn(LUSHR); 这个字节码用于计算按位无符号右移操作（a&gt;&gt;&gt;b）。如果右移位数超过了32（int）或64（long）位，系统只会采取最低的5（int）或6（long）位进行无符号右移操作。 运算字节码说完之后，最后，来看看数字转换的字节码。 转换为float的字节码：x2fx=i/l/d 输入：数字 输出：转换为float的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(I2F); 转换为float采取了IEEE 754的取值规律，详见xadd。虽然对于int，float转换是由低级拓宽范围，但是由于float值不能取到所有int可表示的数字（float仅有24位精确数字，其他为指数和符号位），所以此转换仍然不精确。 转换为double的字节码：x2dx=i/l/f 输入：数字 输出：转换为double的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(F2D); 转换为double采取了IEEE 754的取值规律，详见xadd。对于int，这种转换是完全精确的。对于float，如果这个方法是FP-Strict，也就是采取了ACC_STRICT修饰（Java中的strictfp），这个计算就是精确的；如果不是，这个计算可能进行舍入。对于long，由于double值不能取到long表示的所有数字（double仅有53位精确数字，其他为指数和符号位），所以计算不精确。 转换为int的字节码：x2ix=d/l/f 输入：数字 输出：转换为int的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(F2I); 由于int在四种数字中级别最低，long转换为它时都有可能丢失精度（甚至符号位），float和double会使用IEEE 754“向零舍入”。特殊情况下，如果浮点数的NaN转换为int，值为0；如果浮点数超出int最大范围，则为相应符号下的最大值。 转换为long的字节码：x2lx=i/f/d 输入：数字 输出：转换为long的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(D2L); 由于long级别大于int，int转换为long不丢失精度。在浮点数下，long与int的转换规则类似。 int转换为其他基本类型的字节码：i2xx=b/c/s 输入：数字 输出：转换为byte/char/short的数字 方法：visitInsn 参数：无 使用范例： mv.visitInsn(I2B); 这三个字节码能分别将int缩小转换为byte（-128~127）、short（-32768~32767）和char（0~65535）。由于是缩小变换，可能丢失精度甚至符号位。 下面是使用例子：计算平方和Java代码如下： public static double computeSquare2(int x1, int x2)&#123; return x1 * x1 + x2 * x2; &#125; 使用ASM写入，如下： ClassWriter cw = new ClassWriter(ASM9); cw.visit(V1_8, ACC_PUBLIC, &quot;TestClass&quot;, null, &quot;java/lang/Object&quot;, null); MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;computeSquare2&quot;, &quot;(II)D&quot;, null, null); mv.visitVarInsn(ILOAD, 0); mv.visitInsn(DUP); mv.visitInsn(IMUL); mv.visitVarInsn(ILOAD, 1); mv.visitInsn(DUP); mv.visitInsn(IMUL); mv.visitInsn(IADD); mv.visitInsn(I2D); mv.visitInsn(DRETURN); mv.visitMaxs(3, 2); mv.visitEnd(); cw.visitEnd(); 将生成的类加载并调用，以参数100和21传入，结果为10441.0。 这篇博客到这里就结束了，下一期：Java ASM详解：MethodVisitor与Opcode（二）类、数组与调用 这篇文章一共讲了130个字节码呢~","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解：ASM库使用","slug":"Java ASM详解：ASM库使用","date":"2021-02-13T00:00:00.000Z","updated":"2021-08-30T12:23:13.000Z","comments":true,"path":"2021/02/13/Java ASM详解：ASM库使用/","link":"","permalink":"http://nickid2018.github.io/2021/02/13/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9AASM%E5%BA%93%E4%BD%BF%E7%94%A8/","excerpt":"","text":"几个月之后，终于来到了ASM的第二篇专栏（指直接咕了半年） 这篇专栏主要说一说ASM库怎么用，电脑端观看更佳。 读取的起源：ClassReaderClassReader位于org.objectweb.asm包下（基础类都在这个包），它是读取字节码的开始，通过它我们才能进行字节码解析。 首先是构造函数： public ClassReader(byte[] classFile) public ClassReader(byte[] classFileBuffer, int classFileOffset, int classFileLength) ClassReader(byte[] classFileBuffer, int classFileOffset, boolean checkClassVersion) public ClassReader(InputStream inputStream) throws IOException public ClassReader(String className) throws IOException 这几种构造函数都是以传入数据为目标的：前两个，根据传入的byte数组（第二个指定了偏移量和长度）解析类；倒数第二个，通过InputStream传入；倒数第一个，根据类的全限定名获得对象；中间的则是不开放的API，可以忽略。下面是使用的例子： ClassReader reader = new ClassReader(&quot;com/github/nickid2018/asm/TestClass&quot;); ClassReader reader2 = new ClassReader(classBytes, 0, 3370); ClassReader reader3 = new ClassReader(inputStreamClassFile); 说完了对象的构建，下面是它的用法。它最重要的方法是accept，其余的方法基本用不上（都内部自己用的） public void accept(ClassVisitor classVisitor, int parsingOptions) public void accept(ClassVisitor classVisitor, Attribute[] attributePrototypes, int parsingOptions) 先抛开Attribute[]这个参数，这个以后可能会说。第一个参数ClassVisitor是你要传入的访问器：ASM整体是Visitor设计模式。最后一个参数int是代表读取模式，它有4个基本取值，这些值可以被or（|）连接： 常量值 读取方式 SKIP_CODE 跳过代码属性 SKIP_DEBUG 跳过源文件、局部变量表、局部变量类型表、方法参数列表、行号 SKIP_FRAME 跳过帧（visitFrame），帧是JVM验证类阶段使用的数据 EXPANDS_FRAMES 扩展堆栈映射帧 下面是例子： ClassVisitor cv = ...; classReader.accept(cv, 0); classReader.accept(cv, ClassWriter.SKIP_CODE); 关于ClassReader的使用到这里差不多结束了，下面先讲一下访问标志，然后再说ClassVisitor等类。 访问标志（Access Flag）访问标志是用于JVM访问类、字段、方法检查和调用的一个int。这些标志既包含了我们常见的public这种访问限定符，还包含了static、final这种修饰符，除此之外还有声明类为接口的interface，为枚举的enum。 完整的访问标志如下表（省略了前缀ACC_）： Access Flag 常量值 修饰目标 用途 PUBLIC 0x0001 class, field, method 访问限定，公开 PRIVATE 0x0002 class, field, method 访问限定，私密 PROTECTED 0x0004 class, field, method 访问限定，受保护 STATIC 0x0008 field, method 静态 FINAL 0x0010 class, field, method, parameter 对于类为不可继承，对于其他为不可修改 SUPER 0x0020 class 调用invokespecial时会特殊处理超类方法 SYNCHRONIZED 0x0020 method 同步方法 OPEN 0x0020 module 指示模块为开放的 TRANSITIVE 0x0020 module requires 指示依赖于此模块的所有模块都隐式依赖此模块 VOLATILE 0x0040 field volatile字段，在内存中不会缓存 BRIDGE 0x0040 method “桥”方法，由编译器生成 STATIC_PHASE 0x0040 module requires 指示模块在编译时必须但运行时可选 VARARGS 0x0080 method 方法使用@SafeVarargs注释，与static或final连用 TRANSIENT 0x0080 field 被默认序列化忽略 NATIVE 0x0100 method 本地方法（JNI） INTERFACE 0x0200 class 声明类为接口，与abstract连用 ABSTRACT 0x0400 class, method 定义抽象类或抽象方法 STRICT 0x0800 method 严格浮点数定义（strictfp），可能在Java 17失效（？） SYNTHETIC 0x1000 class, field, method, parameter, module * 既不属于显性声明也不属于隐式声明，通常是编译器优化生成 ANNOTATION 0x2000 class 注释类型，与interface、abstract连用 ENUM 0x4000 class(?) field inner 枚举类或枚举字段 MANDATED 0x8000 field, method, parameter, module, module * 隐式声明的数据 MODULE 0x8000 class 声明这个类是模块定义类 JVM定义的Access Flags，真正我们能用到的不多，详见https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25 ASM自己也有定义Access Flag，由于JVM定义的有效位只有16位，所以这两个标志不会与JVM的访问标志冲突，但是这些标志在写入类之前必须清除（用&amp;操作即可） Access Flag 常量值 修饰目标 用途 RECORD 0x10000 class 记录类型（record） DEPRECATED 0x20000 class, field, method 弃用，要和@Deprecated连用 这些常量可以用or叠加修饰，如果访问标志不合法（比如吧ACC_PUBLIC和ACC_PRIVATE用or联系起来当了访问标志），在ASM写入时是不会报错的，但是在JVM试图加载这个类的时候可能会抛出ClassFormatError。 解析类的信息：ClassVisitorClassVisitor是一个抽象类，它的构造函数仅需要ASM API版本（在Opcodes中可以找到，1-9），或者再加上另一个ClassVisitor用于一起解析，下面是一个模板： public ClassParser(int api) &#123; super(api); &#125; public ClassParser() &#123; super(ASM9); &#125; 当这个Visitor被传入accept之后，ClassReader会以下面的顺序调用： visit [ visitSource ] [ visitModule ][ visitNestHost ][ visitPermittedSubclass ][ visitOuterClass ] ( visitAnnotation | visitTypeAnnotation | visitAttribute )* ( visitNestMember | visitInnerClass | visitRecordComponent | visitField | visitMethod )* visitEnd 不够清晰？那么下面简单说一下流程： 首先访问类的信息（visit），传入的是类文件的版本（version，从V1_1到V16）、访问标志（access），类的全限定名（name），泛型签名（signature，可能为空），父类全限定名（无指定为java/lang/Object），实现接口列表（全限定名，可为空） 之后访问注释信息（visitAnnotation），传入的是注释描述符（descriptor，这里可能包含有@Repeatable的注释类型，所以这里不是全限定名）和可见性（visible，@Retention定义的作用范围，为CLASS传入false，为RUNTIME传入true，为SOURCE不会写入类文件），该方法返回AnnotationVisitor。 同时，访问泛型注释信息（visitTypeAnnotation），传入的是注释引用类型（typeRef，可能为TypeReference定义的几个值：CLASS_TYPE_PARAMETER \\&lt;以泛型类的类型参数为目标的类型引用的类型，常量值0>，CLASS_EXTENDS \\&lt;以泛型类的超类或它实现的接口之一为目标的类型引用的类型，常量值16>，CLASS_TYPE_PARAMETER_BOUND \\&lt;以泛型类的类型参数的绑定为目标的类型引用的类型，常量值17>），泛型类引用路径（可为空），注释描述符和可见性，返回AnnotationVisitor。 接着，访问字段、方法和内部类。 字段调用visitField方法，传入访问标志，字段名，描述符，泛型签名和默认值，返回FieldVisitor。 方法调用visitMethod方法，传入访问标志，方法名，描述符，泛型签名和异常列表（全限定名），返回MethodVisitor。 内部类调用visitInnerClass方法，传入内部类全限定名，外部类全限定名，内部类名称（不带包路径，也就是没有“.”的名称，如果这个写错了IDE无法识别到这个类，但是不影响调用），和访问标志（这个和类声明定义的标志不同，可以有static，这样类里面就不会带有this$0）。内部类调用指的不只是类中定义了内部类，还包括引用到了其他类的内部类。 当所有信息都访问结束，调用visitEnd。 这里的内容只是简单介绍了一下，具体的下文和接下来几篇专栏会写。 解析注释信息：AnnotationVisitorAnnotationVisitor用于解析注释信息，除了最后会调用的visitEnd外，其他都与注释类型本身定义的方法返回值有关。下面是不同的类型： visit方法：传入注释方法名称和值，值必须是基本类型（基本数字、char及其数组，String和类） visitArray方法：传入注释方法名称，返回另一个AnnotationVisitor。这个新的Visitor会被传入数组内的值，所有的name传入都为null。注意：visit一个基本数字或char数组等价于使用visitArray，但是在ClassReader解析中不会调用visitArray而是直接调用visit。 visitAnnotation方法：传入注释方法名称和值的描述符，返回的是值的AnnotationVisitor。 visitEnum方法：传入注释方法名、值的描述符和枚举名称。 对于带有@Repeatable注释的注释类型，在Java使用反射时会返回容器注释，也就是在普通编写时有两种等价的编写方式。在ASM中，这两种方式也等价，写入按照第一种处理： @T.Ts(value = &#123; @T(value = &quot;ss&quot;), @T(value = &quot;dd&quot;) &#125;) public class A &#123; ... &#125; @T(value = &quot;ss&quot;) @T(value = &quot;dd&quot;) public class A &#123; ... &#125; 对于带有@Repeatable注释的注释类型，这两种使用方式在反射和ASM中完全等价（T.Ts是T的注释容器） 解析字段：FieldVisitorFieldVisitor的构成比较简单，除了visitEnd在最后调用外，比较常用的就是visitAnnotation和visitTypeAnnotation。这些方法的使用都和ClassVisitor的使用差不多，唯一的不同是visitTypeAnnotation的注释引用类型必为FIELD（常量值19） 到此简单的解析就讲完了。什么？还差一个MethodVisitor？这是我们之后要说的重要内容，所以这里不会提到它。接下来，是应用ASM的例子。 使用范例：解析一个类解析一个类需要从文章最开始说的ClassReader写起，它能将一个类的字节码解析并且进行Visitor模式调用。在下面的范例中，我们将尝试读取一个类的名称、字段和注释。 首先是一个测试类的编写，之后用javac编译。 package com.github.nickid2018.asm; public class TestClass &#123; @Deprecated public String string; public static int integer; &#125; 接着，我们尝试读取这个类的信息，因为测试类和运行ASM的类在同一个项目之下，可以用它的全限定名初始化ClassReader。 ClassReader reader = new ClassReader(&quot;com/github/nickid2018/asm/TestClass&quot;); 之后我们需要继承三个Visitor：ClassVisitor、FieldVisitor和AnnotationVisitor。我们只需要一些信息，所以不需要将它们的所有方法进行覆盖。 创建一个ClassParser继承ClassVisitor，选择要覆盖的方法。在访问类的时候，我们只需要类名，所以需要覆盖visit；又因为需要解析字段，我们还需要覆盖visitField，并且将我们的字段访问器作为返回值。 @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; super(version, access, name, signature, superName, interfaces); System.out.println(&quot;类名: &quot; + name); &#125; @Override public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) &#123; System.out.println(&quot;字段: &quot; + name + &quot; 描述符: &quot; + descriptor); return new FieldParser(); &#125; 创建FieldParser继承FieldVisitor解析字段。在读取字段时，我们还需要读取字段中的注释，所以需要覆盖visitAnnotation，返回我们自己的AnnotationVisitor。 @Override public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) &#123; System.out.println(&quot;注释: &quot; + descriptor + &quot; 可见性: &quot; + visible); return new AnnotationParser(); &#125; 由于@Deprecated不具有任何的注释方法，我们创建的AnnotationParser可以不覆盖任何方法。 这些访问器写完之后，就要递呈给ClassReader开始解析，代码如下： ClassParser cv = new ClassParser(); reader.accept(cv, 0); 现在，我们的解析程序就完成了。运行结果如下： 类名: com/github/nickid2018/asm/TestClass 字段: string 描述符: Ljava/lang/String; 注释: Ljava/lang/Deprecated; 可见性: true 字段: integer 描述符: I 代码样例：https://paste.ubuntu.com/p/8d6jN8jVzr/ 使用范例：生成一个类生成类我们用到的是ClassWriter，它本质上就是ClassVisitor，我们只要用可以构建类的数据按照刚才的格式传给它就能生成对应的类。 它的构造函数有两个，一个只传入一个int，它的值可为三个数：0、COMPUTE_MAXS和COMPUTE_FRAMES。那两个常量值是自动计算方法visitMaxs和visitFrame的，对于现在来说还用不到。另一个构造函数还需要传入ClassReader，这是下一部分可能用到的。 首先确定我们要构建产生的类： package com.github.nickid2018.asm; public class WillGenerate &#123; @Deprecated public static final int HELLO = 0; private String hi; &#125; 首先创建ClassWriter实例： ClassWriter cw = new ClassWriter(0); 接着，创建类，用到的正是visit方法。由于没有指定父类，这个类的父类将被强行指定为java/lang/Object，接口、抽象类、注释类型也如此。这个类没有实现任何接口，所以interfaces可以传null。同理，它没有泛型，所以泛型的signature为null。访问标志是public，再加上super，整体下来就是这句： cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, &quot;com/github/nickid2018/asm/WillGenerate&quot;, null, &quot;java/lang/Object&quot;,null); 接下来我们需要创建默认构造函数。javac编译时会把没有定义构造函数的普通类加入默认的构造函数。这种构造函数里面包括了父类构造函数调用和本身的非基本类型字段赋值。如果没有非基本类型字段赋值，那么它的代码就像这样： public WillGenerate() &#123; super(); &#125; 由于这篇专栏主要是有关于类、字段、注释的解析，方法的解析暂时先不讲，所以这里只给出它的写入代码，不做讲解。 public static void writeDefaultInit(ClassWriter cw) &#123; MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null); mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); mv.visitInsn(RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); &#125; 接下来写入HELLO这个字段。它的访问标志是public+static+final，由于它是弃用的，它也可以加上deprecated这个ASM自己定义的Access Flag。它的类型是int，所以描述符是I。没有泛型，所以signature为null。有默认值，为0。所以它的写入像这样： FieldVisitor fv = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC + ACC_DEPRECATED, &quot;HELLO&quot;, &quot;I&quot;, null, (Integer) 0); 保留这个FieldVisitor，因为它还具有一个注释@Deprecated。注释类型的描述符为Ljava/lang/Deprecated;。又因为@Deprecated的作用范围是RUNTIME，所以可见性为true，代码如下： AnnotationVisitor av = fv.visitAnnotation(&quot;Ljava/lang/Deprecated;&quot;, true); 这时，这个字段就写入信息就完成了，调用visitEnd。 av.visitEnd(); fv.visitEnd(); 下面写hi这个字段，和上面的差不多，直接给代码： fv = cw.visitField(ACC_PRIVATE, &quot;hi&quot;, &quot;Ljava/lang/String;&quot;, null, null); fv.visitEnd(); 这时候类的所有信息都已经写完了，调用ClassWriter的visitEnd。 cw.visitEnd(); 接下来调用ClassWriter的toByteArray获得字节码信息，写入到文件中就能得到类。 运行之后调用反编译器的结果： package com.github.nickid2018.asm; public class WillGenerate &#123; @Deprecated public static final int HELLO = 0; private String hi; &#125; 代码样例：https://paste.ubuntu.com/p/cqfDPVZbsH/ 使用范例：修改一个类修改类需要ClassReader和ClassWriter互相配合。利用ClassVisitor等进行数据的转移和修改。 接下来用ASM改一下我们的TestClass。 public class TestClass &#123; // 改为抽象类 @Deprecated public String string; // 重命名为str public static int integer; // 加上final和默认值10 &#125; 首先，创建ClassReader和ClassWriter。 ClassWriter cw = new ClassWriter(0); ClassReader cr = new ClassReader(&quot;com/github/nickid2018/asm/TestClass&quot;); 之后在我们的ClassParser里面改一下，传入一个ClassWriter，使用父类的第二个构造函数：以int，ClassVisitor为参数的构造函数。这样，ClassReader传入的信息可以直接写到ClassWriter里面，我们只需要修改我们所需要的方法就可以达到修改的效果，而不用将所有ClassVisitor的方法实现。 public ClassParser(ClassWriter cw) &#123; super(ASM9, cw); &#125; 接下来解决第一个修改：改为抽象类。这个我们可以在visit里面修改，将原先的访问标志加一个abstract就好。 @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; super.visit(version, access + ACC_ABSTRACT, name, signature, superName, interfaces); &#125; 第二个修改是重命名字段。这个在visitField里面判断就行，像下面一样： if (name.equals(&quot;string&quot;)) return super.visitField(access, &quot;str&quot;, descriptor, signature, value); 第三个就是修改为final和加默认值，也是在visitField里面改动： if (name.equals(&quot;integer&quot;)) return super.visitField(access + ACC_FINAL, name, descriptor, signature, (Integer) 10); 最后用accept传入ClassParser，输出文件就是改好的类文件。 cr.accept(new ClassParser(cw), 0); 生成之后，用反编译器看一下结果。 package com.github.nickid2018.asm; public abstract class TestClass &#123; @Deprecated public String str; public static final int integer = 10; &#125; 代码样例：https://paste.ubuntu.com/p/yXVvdJs3WH/ 这篇专栏到这里就结束了，下一期专栏：MethodVisitor和Opcode（一） 如果文章中有任何错误，可以在评论区留言，我将会修正错误。 如果使用ASM中有问题，可以在下面评论。","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]},{"title":"Java ASM详解： 基础知识","slug":"Java ASM详解：基础知识","date":"2020-07-23T00:00:00.000Z","updated":"2021-08-29T00:00:00.000Z","comments":true,"path":"2020/07/23/Java ASM详解：基础知识/","link":"","permalink":"http://nickid2018.github.io/2020/07/23/Java%20ASM%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"ASM是什么，字节码又是什么 ASM是一个Java字节码分析、创建和修改的开源应用框架。它可以动态生成二进制格式的stub类或其他代理类，或者在类被Java虚拟机装入内存之前，动态修改类。在ASM中提供了诸多的API用于对类的内容进行字节码操作的方法。与传统的BCEL和SERL不同，在ASM中提供了更为优雅和灵活的操作字节码的方式 这是ASM官网上给出的没用解释，一句话概括：ASM是一个修改，分析Java类文件的框架。先抛开ASM框架的基本定义，先来看看字节码是什么 字节码（Byte-code）是一种包含执行程序，由一序列 op 代码/数据对组成的二进制文件 又是一段废话。从这里可以的知，字节码是一种介于翻译语言和底层语言的东西，与底层语言（C/C++）相比较你可以从它这里知道程序的运行方式，而与翻译语言（JavaScript）对比来看，你又无法从字节码中轻易看出什么。但是由于字节码的这个特性，我们得以修改它，操纵它，并且我们还可以反编译它。 官网：https://asm.ow2.io/ 添加ASM库依赖首先，是有关于ASM的Maven依赖&lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-all&lt;/artifactId&gt; &lt;version&gt;6.0_BETA&lt;/version&gt; &lt;/dependency&gt; 或者 &lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-commons&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-tree&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm-analysis&lt;/artifactId&gt; &lt;version&gt;9.0&lt;/version&gt; &lt;/dependency&gt; 如果使用第一种，那么你最高能依赖的版本是6.0_BETA。而第二种是现在仍在持续更新的，它相当于把原先的asm-all库分开成为不同的部分，但是基本的asm库是必须的。 这个库以后会详细讲述，这里先说几个强有力的工具。 帮助学习ASM的工具ASMifier: 自动生成ASM代码ASM库中有不少实用类，为了了解晦涩难懂的ASM代码，可以用ASMifier来进行解析。这是一个可执行类，你可以通过java.exe运行它。 注意：在9.0已经没有这个类了 运行方法：下载ASM的jar（比如asm-all-6.0_beta.jar）或者从你的.m2文件夹（asm-all）里面找到它，然后运行： java -classpath asm-all-6.0_BETA.jar org.objectweb.asm.util.ASMifier DemoDump.class 你会得到这样的输出： javap.exe: Java自带的字节码解析工具javap是你在安装JDK时就有的一个程序文件，是JDK的原生字节码解析工具，关于它的使用因篇幅有限不再细说，可以参考这篇文章 https://www.cnblogs.com/frinder6/articles/5440173.html Eclipse插件: Enhanced Class Decompiler这个插件是反编译器，可以在你没有库的源代码时反编译出源代码进行调试。当然，这个也可以作为你ASM程序的结果测试方案，通常反编译结果会很贴近于源代码，如果相差很大可以换一种方式反编译。 ASM中经常会用到的名词类(型)的不同名称 类的二进制名称/类全名/简单名称 这个三个名称是等价的，也就是我们平常说的类名，例如 java.lang.Thread java.lang.Thread$UncaughtExceptionHandler这样的名称。 全限定名 这个名称是用于class文件中的名称，其实就是将二进制名称的所有”.”换为”/“，这个名称只有非数组引用类型才有。例如 java/lang/Thread java/io/IOException。 类型描述符 类型描述符是有关于class文件内定义字段等的类型的名称。 类型描述符 原始类型的描述符一一对应 原始类型的描述符都对应相应的一个字母，具体来说是这样的： byte -&gt; B short -&gt; S int -&gt; I long -&gt; J float -&gt; F double -&gt; D char -&gt; C void -&gt; V boolean -&gt; Z 非数组的引用类型为 L+全限定名+; 数组引用类型为 [+数组内类型的描述符 例子: java.lang.Thread -&gt; Ljava/lang/Thread; java.lang.Object[] -&gt; [Ljava/lang/Object; int[][] -&gt; [[I 方法描述符了解类名称和类型描述符，下面讲一下方法描述符（其实类型描述符和方法描述符统称描述符） 方法描述符是class文件中保存参数类型列表和返回值类型的方式，在各种方法调用的操作码里面都会涉及到。 规则： 格式为 ( + 参数列表 + ) + 返回值 所有类型名称都为类型描述符 参数列表中不需要逗号分隔 下面是抽象含义下的具体例子（省略了参数名称，只保留了参数类型）： void a(int,int,int) -&gt; (III)V String s(double[],boolean) -&gt; ([DZ)Ljava/lang/String; int[] i(Object) -&gt; (Ljava/lang/Object;)[I void t() -&gt; ()V 操作码(OpCode)Opcode是用于JVM解释运行Java程序的关键。每一个Opcode都有自己独特的含义与操作，如0x60，助记符iadd，将两个int相加。 有一点要注意：操作码其实就是一个数字，我们平时经常看到的iadd，invokestatic并不是操作码，而是助记符。 而Java中字节码的名称也与操作码有关，因为每个操作码都是用一个字节，所以叫字节码。 每一个字节用来表示一个指令，理论上可以有 256 个操作码。 对于ASM库来说，所有的Opcode都存储于org.objectweb.asm.Opcodes里面，其中还有包括它们在什么方法中作用的注释。 有关于所有操作码的网页：https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html 这是ASM系列的第一篇，之后会持续更新。 bilibili专栏同步： https://www.bilibili.com/read/cv6875366","categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://nickid2018.github.io/tags/Java/"},{"name":"ASM","slug":"ASM","permalink":"http://nickid2018.github.io/tags/ASM/"},{"name":"JEP","slug":"JEP","permalink":"http://nickid2018.github.io/tags/JEP/"}]}